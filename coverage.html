
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">nextdeploy/cli/cmd/build.go (0.0%)</option>
				
				<option value="file1">nextdeploy/cli/cmd/init.go (0.0%)</option>
				
				<option value="file2">nextdeploy/cli/cmd/prepare.go (0.0%)</option>
				
				<option value="file3">nextdeploy/cli/cmd/preview.go (0.0%)</option>
				
				<option value="file4">nextdeploy/cli/cmd/provision.go (0.0%)</option>
				
				<option value="file5">nextdeploy/cli/cmd/root.go (0.0%)</option>
				
				<option value="file6">nextdeploy/cli/cmd/run.go (0.0%)</option>
				
				<option value="file7">nextdeploy/cli/cmd/secrets.go (0.0%)</option>
				
				<option value="file8">nextdeploy/cli/cmd/ship.go (0.0%)</option>
				
				<option value="file9">nextdeploy/cli/internal/build/build.go (0.0%)</option>
				
				<option value="file10">nextdeploy/cli/internal/initialcommand/init.go (0.0%)</option>
				
				<option value="file11">nextdeploy/cli/internal/prompt/prompter.go (0.0%)</option>
				
				<option value="file12">nextdeploy/cli/internal/server/server.go (0.0%)</option>
				
				<option value="file13">nextdeploy/cli/internal/ship/ship.go (0.0%)</option>
				
				<option value="file14">nextdeploy/cli/main.go (0.0%)</option>
				
				<option value="file15">nextdeploy/daemon/bluegreen.go (0.0%)</option>
				
				<option value="file16">nextdeploy/daemon/caddy.go (0.0%)</option>
				
				<option value="file17">nextdeploy/daemon/commands.go (0.0%)</option>
				
				<option value="file18">nextdeploy/daemon/config.go (0.0%)</option>
				
				<option value="file19">nextdeploy/daemon/decryptFiles.go (0.0%)</option>
				
				<option value="file20">nextdeploy/daemon/lock.go (0.0%)</option>
				
				<option value="file21">nextdeploy/daemon/logger.go (0.0%)</option>
				
				<option value="file22">nextdeploy/daemon/main.go (0.0%)</option>
				
				<option value="file23">nextdeploy/daemon/registry.go (0.0%)</option>
				
				<option value="file24">nextdeploy/shared/agent.go (0.0%)</option>
				
				<option value="file25">nextdeploy/shared/caddy/caddy.go (0.0%)</option>
				
				<option value="file26">nextdeploy/shared/config/Summary.go (0.0%)</option>
				
				<option value="file27">nextdeploy/shared/config/config.go (0.0%)</option>
				
				<option value="file28">nextdeploy/shared/config/io.go (0.0%)</option>
				
				<option value="file29">nextdeploy/shared/config/load.go (0.0%)</option>
				
				<option value="file30">nextdeploy/shared/config/nextdeploy.generator.go (0.0%)</option>
				
				<option value="file31">nextdeploy/shared/config/prompts.go (0.0%)</option>
				
				<option value="file32">nextdeploy/shared/config/template.go (0.0%)</option>
				
				<option value="file33">nextdeploy/shared/config/types.go (0.0%)</option>
				
				<option value="file34">nextdeploy/shared/crypto.go (0.0%)</option>
				
				<option value="file35">nextdeploy/shared/docker/docker.go (0.0%)</option>
				
				<option value="file36">nextdeploy/shared/envstore/env.go (0.0%)</option>
				
				<option value="file37">nextdeploy/shared/failfast/fail.go (0.0%)</option>
				
				<option value="file38">nextdeploy/shared/fs/fileWriter.go (0.0%)</option>
				
				<option value="file39">nextdeploy/shared/git/git.go (0.0%)</option>
				
				<option value="file40">nextdeploy/shared/health/checker.go (0.0%)</option>
				
				<option value="file41">nextdeploy/shared/jwt.go (0.0%)</option>
				
				<option value="file42">nextdeploy/shared/logger.go (0.0%)</option>
				
				<option value="file43">nextdeploy/shared/message.go (0.0%)</option>
				
				<option value="file44">nextdeploy/shared/nextcore/fake.go (0.0%)</option>
				
				<option value="file45">nextdeploy/shared/nextcore/metadatafuncs.go (0.0%)</option>
				
				<option value="file46">nextdeploy/shared/nextcore/nextconfig.go (0.0%)</option>
				
				<option value="file47">nextdeploy/shared/nextcore/nextcore.go (0.0%)</option>
				
				<option value="file48">nextdeploy/shared/nextcore/nextjs.go (0.0%)</option>
				
				<option value="file49">nextdeploy/shared/nextcore/package.go (0.0%)</option>
				
				<option value="file50">nextdeploy/shared/nextcore/routes.go (0.0%)</option>
				
				<option value="file51">nextdeploy/shared/nextcore/runtime.go (0.0%)</option>
				
				<option value="file52">nextdeploy/shared/nextdeploy/yaml.go (0.0%)</option>
				
				<option value="file53">nextdeploy/shared/registry/awsconfig.go (0.0%)</option>
				
				<option value="file54">nextdeploy/shared/registry/awsecr.go (0.0%)</option>
				
				<option value="file55">nextdeploy/shared/registry/awsprofiles.go (0.0%)</option>
				
				<option value="file56">nextdeploy/shared/registry/awsuser.go (0.0%)</option>
				
				<option value="file57">nextdeploy/shared/registry/digitalocean.go (0.0%)</option>
				
				<option value="file58">nextdeploy/shared/registry/dockerhub.go (0.0%)</option>
				
				<option value="file59">nextdeploy/shared/registry/utils.go (0.0%)</option>
				
				<option value="file60">nextdeploy/shared/secrets/crypto.go (0.0%)</option>
				
				<option value="file61">nextdeploy/shared/secrets/doppler.go (0.0%)</option>
				
				<option value="file62">nextdeploy/shared/secrets/fileprocessing.go (0.0%)</option>
				
				<option value="file63">nextdeploy/shared/secrets/keyoperations.go (0.0%)</option>
				
				<option value="file64">nextdeploy/shared/secrets/provideroperations.go (0.0%)</option>
				
				<option value="file65">nextdeploy/shared/secrets/secretmanager.go (0.0%)</option>
				
				<option value="file66">nextdeploy/shared/secrets/secretoperations.go (0.0%)</option>
				
				<option value="file67">nextdeploy/shared/secrets/secretvariables.go (0.0%)</option>
				
				<option value="file68">nextdeploy/shared/types.go (0.0%)</option>
				
				<option value="file69">nextdeploy/shared/utils.go (0.0%)</option>
				
				<option value="file70">nextdeploy/shared/websocket/websocket.go (0.0%)</option>
				
				<option value="file71">nextdeploy/start.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "context"
        "fmt"
        "nextdeploy/shared"
        "nextdeploy/shared/config"
        "nextdeploy/shared/docker"
        "nextdeploy/shared/git"
        "os"
        "regexp"
        "strings"
        "time"

        "github.com/spf13/cobra"
)

var (
        buildlogger      = shared.PackageLogger("BUILD", "üß± BUILD")
        ProvisionEcrUser bool
        fresh            = false // delete current exisiting user start a fresh
)

var buildCmd = &amp;cobra.Command{
        Use:   "build",
        Short: "Build Docker image from the Dockerfile using metadata from nextcore collected by nextdeploy",
        Long: `
        Builds a Docker image with smart defaults and configuration data 
        collected by nextcore engine. 
        Our system that enables developer to use next all features in container 
        Envirenment built for cloud in a cloud agnostic way.
        .

The command automatically:
- Detects your Git repository state
- Uses appropriate naming conventions
- Applies environment-specific settings
- Handles caching appropriately
- 

Configuration:
  Create a 'nextdeploy.yml' file to customize behavior:

  docker:
    image: "my-app"             # Base image name
    registry: "ghcr.io/myorg"   # Container registry
    strategy: "branch-commit"   # Naming strategy
    alwaysPull: true            # Always pull base images
    platform: "linux/amd64"     # Target platform

Examples:
  # Basic build (auto-detects everything)
  nextdeploy build

  # Build for production (uses different defaults)
`,
        PreRunE: checkBuildConditionsMet,
        RunE:    buildCmdFunction,
}

type DockerConfig struct {
        Image    string
        Registry string
        Strategy string // "commit-hash", "branch-commit", or "simple"
}

func GenerateImageName(config DockerConfig, gitInfo *git.RepositoryInfo, env string) string <span class="cov0" title="0">{
        // Start with registry if provided
        var parts []string
        if config.Registry != "" </span><span class="cov0" title="0">{
                parts = append(parts, config.Registry)
        }</span>

        // Add image name or default
        <span class="cov0" title="0">imageName := config.Image
        if imageName == "" </span><span class="cov0" title="0">{
                imageName = "app"
        }</span>
        <span class="cov0" title="0">parts = append(parts, imageName)

        // Generate tag based on strategy
        tag := ""
        switch config.Strategy </span>{
        case "branch-commit":<span class="cov0" title="0">
                sanitizedBranch := strings.ReplaceAll(gitInfo.BranchName, "/", "-")
                tag = fmt.Sprintf("%s-%s", sanitizedBranch, gitInfo.CommitHash)</span>
        case "simple":<span class="cov0" title="0">
                tag = "latest"</span>
        default:<span class="cov0" title="0"> // "commit-hash" or fallback
                tag = gitInfo.CommitHash</span>
        }

        // Add timestamp for production builds
        <span class="cov0" title="0">if env == "production" </span><span class="cov0" title="0">{
                tag = fmt.Sprintf("%s-%s", tag, time.Now().Format("20060102-150405"))
        }</span>

        // Append tag
        <span class="cov0" title="0">if tag != "" </span><span class="cov0" title="0">{
                parts = append(parts, tag)
        }</span>

        <span class="cov0" title="0">return strings.Join(parts, ":")</span>
}

func init() <span class="cov0" title="0">{
        // No flags needed - everything comes from config or auto-detection
        rootCmd.AddCommand(buildCmd)
        // provision-ecr-user --fresh
        buildCmd.Flags().BoolVarP(&amp;fresh, "fresh", "f", false, "Delete current existing user and start fresh")
        buildCmd.Flags().BoolVarP(&amp;ProvisionEcrUser, "provision-ecr-user", "p", false, "Provision ECR user for pushing images")
}</span>

func buildCmdFunction(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Initialize components
        <span class="cov0" title="0">dm, err := docker.NewDockerClient(buildlogger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Docker client: %w", err)
        }</span>
        // Determine environment (dev/prod)
        <span class="cov0" title="0">env := os.Getenv("NODE_ENV")
        if env == "" </span><span class="cov0" title="0">{
                env = "production"
        }</span>
        <span class="cov0" title="0">var buildArgs map[string]string
        buildArgs = make(map[string]string)
        for k, v := range dm.GetBuildArgs() </span><span class="cov0" title="0">{
                // Check if the pointer is nil before dereferencing
                if v != nil </span><span class="cov0" title="0">{
                        // log out the build args
                        buildlogger.Info("Build arg: %s=%s\n", k, *v)
                        // Skip empty values
                        if *v != "" </span><span class="cov0" title="0">{
                                buildArgs[k] = *v
                        }</span>
                } else<span class="cov0" title="0"> {
                        buildlogger.Warn("Build arg %s is nil, skipping", k)
                }</span>
        }
        <span class="cov0" title="0">tag, _ := git.GetCommitHash()
        //Validate the tag
        if !ValidateDockerTag(tag) </span><span class="cov0" title="0">{
                buildlogger.Debug("Invalid Docker tag format: %s", tag)
                return fmt.Errorf("invalid Docker tag format: %s", tag)
        }</span>

        <span class="cov0" title="0">imagename := cfg.Docker.Image + ":" + tag
        // Auto-configure build options based on environment
        opts := docker.BuildOptions{
                ImageName:        imagename,
                NoCache:          env == "production", // No cache in production
                Pull:             cfg.Docker.AlwaysPull || env == "production",
                Target:           cfg.Docker.Target,
                Platform:         cfg.Docker.Platform,
                BuildArgs:        buildArgs,
                ProvisionEcrUser: ProvisionEcrUser,
                Fresh:            fresh,
        }

        // Build options for image are
        // Log what we're doing
        cmd.Printf("Building %s image for %s environment\n", opts.ImageName, env)
        if opts.NoCache </span><span class="cov0" title="0">{
                cmd.Println("Cache disabled (production build)")
        }</span>

        // Execute build
        <span class="cov0" title="0">ctx := context.Background()
        if err := dm.BuildAndDeploy(ctx, opts); err != nil </span><span class="cov0" title="0">{
                buildlogger.Error("Build failed: %v", err)
                return fmt.Errorf("build failed: %w", err)
        }</span>

        <span class="cov0" title="0">cmd.Printf("Successfully built: %s\n", opts.ImageName)

        // Handle push if configured
        if cfg.Docker.Push </span><span class="cov0" title="0">{
                cmd.Println("Pushing image to registry...")
                if err := dm.PushImage(ctx, opts.ImageName, opts.ProvisionEcrUser, opts.Fresh); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("push failed: %w", err)
                }</span>
                <span class="cov0" title="0">cmd.Println("Image pushed successfully")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func checkBuildConditionsMet(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        dm, err := docker.NewDockerClient(buildlogger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Docker client: %w", err)
        }</span>

        // Validate Docker installation
        <span class="cov0" title="0">if err := dm.CheckDockerInstalled(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("docker is not installed or not functioning: %w", err)
        }</span>
        // Check for Dockerfile
        // FIX::: we should generate the metdata need and use that to build the image
        <span class="cov0" title="0">if exists, err := dm.DockerfileExists("."); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check for Dockerfile: %w", err)
        }</span> else<span class="cov0" title="0"> if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no Dockerfile found in current directory")
        }</span>

        // Check for uncommitted changes (warning only)
        <span class="cov0" title="0">if git.IsDirty() </span><span class="cov0" title="0">{
                cmd.Printf("Warning: Building with uncommitted changes\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
func isGitCommitHash(tag string) bool <span class="cov0" title="0">{
        if len(tag) &lt; 7 || len(tag) &gt; 40 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">matched, _ := regexp.MatchString(`^[a-f0-9]+$`, tag)
        return matched</span>
}
func ValidateDockerTag(tag string) bool <span class="cov0" title="0">{
        // Check for simple git hash (7-40 hex chars)
        if isGitCommitHash(tag) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check for git hash with suffix (separated by - or _)
        <span class="cov0" title="0">hashWithSuffix := regexp.MustCompile(`^[a-f0-9]{7,40}[-_][a-z0-9][a-z0-9._-]{0,126}$`)
        if hashWithSuffix.MatchString(tag) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check for semantic version (v1.0.0)
        <span class="cov0" title="0">semVer := regexp.MustCompile(`^v\d+\.\d+\.\d+$`)
        if semVer.MatchString(tag) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// NOTE: cross compile safe
package cmd

// FEATURE: GIVE USER  ABILITY TO START FROM ZERO USING OUR OWN NEXTJS TEMPLATES

//TODO: this commands main job should be to give developers a Scaffolded and opionated NextJS web app templates
import (
        "github.com/spf13/cobra"
        "nextdeploy/cli/internal/initialcommand"
        "nextdeploy/shared/nextcore"
)

type PackageManager string

func (pm PackageManager) String() string <span class="cov0" title="0">{
        return string(pm)
}</span>

var initCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Initialize Next.js deployment configuration",
        Long: `Scaffolds deployment configuration for Next.js applications including:
- Dockerfile for containerization
- nextdeploy.yml configuration
- Optional sample files and gitignore updates`,
        PreRunE: nextcore.ValidateNextJSProject,
        RunE:    initialcommand.RunInitCommand,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(initCmd)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "context"
        "fmt"
        "io"
        "nextdeploy/cli/internal/server"
        "nextdeploy/shared"
        "nextdeploy/shared/failfast"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

var (
        PrepLogs = shared.PackageLogger("prepare", "üîß PREPARE")

        // Command flags
        verbose    bool
        timeout    time.Duration
        streamMode bool
)

var prepareCmd = &amp;cobra.Command{
        Use:   "prepare",
        Short: "Prepare target server with required tools",
        Long: `Installs Docker, Caddy and other required tools on the target server.
This command will:
1. Verify server connectivity
2. Install required packages
3. Configure necessary services
4. Validate the installation`,
        Run: runPrepare,
}

func init() <span class="cov0" title="0">{
        // Add flags for the prepare command
        rootCmd.AddCommand(prepareCmd)
}</span>

func runPrepare(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // Create context with timeout
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = 3 * time.Minute // Default timeout
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        // Set up signal handling for graceful shutdown
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                cancel()
                PrepLogs.Warn("Received interrupt signal, cancelling preparation...")
        }</span>()

        // Get the appropriate output writer
        <span class="cov0" title="0">var stream io.Writer
        if streamMode </span><span class="cov0" title="0">{
                stream = cmd.OutOrStdout()
        }</span>

        // Initialize server manager
        <span class="cov0" title="0">serverMgr, err := server.New(
                server.WithConfig(),
                server.WithSSH(),
        )
        failfast.Failfast(err, failfast.Error, "Error setting up server")

        defer func() </span><span class="cov0" title="0">{
                err := serverMgr.CloseSSHConnection()
                if err != nil </span><span class="cov0" title="0">{
                        PrepLogs.Error("Failed to close SSH connections: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        PrepLogs.Debug("SSH connections closed successfully")
                }</span>
        }()

        // Determine target server
        <span class="cov0" title="0">serverName, err := selectTargetServer(ctx, serverMgr)
        if err != nil </span><span class="cov0" title="0">{
                PrepLogs.Error("Failed to select target server: %v", err)
                return
        }</span>
        // Run preparation
        <span class="cov0" title="0">err = executePreparation(ctx, serverMgr, serverName, stream)
        if err != nil </span><span class="cov0" title="0">{
                PrepLogs.Error("Preparation failed: %v", err)
                return
        }</span>

        <span class="cov0" title="0">PrepLogs.Success("‚úÖ Server %s prepared successfully!", serverName)</span>
}

func selectTargetServer(ctx context.Context, serverMgr *server.ServerStruct) (string, error) <span class="cov0" title="0">{
        // Check for deployment server first
        if depServer, err := serverMgr.GetDeploymentServer(); err == nil </span><span class="cov0" title="0">{
                PrepLogs.Debug("Using deployment server: %s", depServer)
                return depServer, nil
        }</span>

        // Fall back to first available server
        <span class="cov0" title="0">servers := serverMgr.ListServers()
        if len(servers) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no servers configured")
        }</span>

        <span class="cov0" title="0">PrepLogs.Warn("No deployment server configured, using first server: %s", servers[0])
        return servers[0], nil</span>
}

func executePreparation(ctx context.Context, serverMgr *server.ServerStruct, serverName string, stream io.Writer) error <span class="cov0" title="0">{
        PrepLogs.Info("Starting preparation of server %s", serverName)

        // Phase 1: Pre-check
        err := verifyServerPrerequisites(ctx, serverMgr, serverName, stream)
        if err != nil </span><span class="cov0" title="0">{
                PrepLogs.Error("Server prerequisites verification failed: %v", err)
                return fmt.Errorf("server prerequisites verification failed: %w", err)
        }</span>
        <span class="cov0" title="0">err = installRequiredPackages(ctx, serverMgr, serverName, stream)
        if err != nil </span><span class="cov0" title="0">{
                PrepLogs.Error("Failed to install required packages: %v", err)
                return fmt.Errorf("failed to install required packages: %w", err)
        }</span>
        // Phase 3: Verification
        <span class="cov0" title="0">err = verifyInstallation(ctx, serverMgr, serverName, stream)
        if err != nil </span><span class="cov0" title="0">{
                PrepLogs.Error("Installation verification failed: %v", err)
                return fmt.Errorf("installation verification failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func verifyServerPrerequisites(ctx context.Context, serverMgr *server.ServerStruct, serverName string, stream io.Writer) error <span class="cov0" title="0">{
        PrepLogs.Info("Verifying server prerequisites...")

        checks := []struct {
                command string
                message string
                timeout time.Duration // Individual timeout for each check
        }{
                {"uname -a", "Checking system information...", 5 * time.Second},
                {"df -h", "Checking disk space...", 10 * time.Second},
                {"free -m", "Checking memory...", 5 * time.Second},
        }

        for _, check := range checks </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        PrepLogs.Error("Prerequisite checks cancelled: %v", ctx.Err())
                        return fmt.Errorf("prerequisite checks cancelled: %w", ctx.Err())</span>
                default:<span class="cov0" title="0">
                        if stream != nil </span><span class="cov0" title="0">{
                                PrepLogs.Debug("Running prerequisite check: %s", check.command)
                        }</span>

                        // Create a sub-context with individual timeout
                        <span class="cov0" title="0">checkCtx, cancel := context.WithTimeout(ctx, check.timeout)
                        defer cancel()

                        output, err := serverMgr.ExecuteCommand(checkCtx, serverName, check.command, stream)
                        if err != nil </span><span class="cov0" title="0">{
                                PrepLogs.Error("Failed prerequisite check %q: %v", check.command, err)
                                return fmt.Errorf("failed prerequisite check %q: %w", check.command, err)
                        }</span>
                        <span class="cov0" title="0">verbose = true

                        if verbose </span><span class="cov0" title="0">{
                                PrepLogs.Debug("Check %q output:\n%s", check.command, output)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func installRequiredPackages(ctx context.Context, serverMgr *server.ServerStruct, serverName string, stream io.Writer) error <span class="cov0" title="0">{
        PrepLogs.Info("Installing required packages...")

        // First determine package manager - trim any whitespace from output
        pkgManager, err := serverMgr.ExecuteCommand(ctx, serverName, "command -v apt-get &gt;/dev/null &amp;&amp; echo apt || echo yum", stream)
        if err != nil </span><span class="cov0" title="0">{
                PrepLogs.Error("Failed to determine package manager: %v", err)
                return fmt.Errorf("failed to determine package manager: %w", err)
        }</span>

        // Clean up the package manager string
        <span class="cov0" title="0">pkgManager = strings.TrimSpace(pkgManager)
        PrepLogs.Debug("Detected package manager: %s", pkgManager)

        // Execute appropriate installation commands
        switch pkgManager </span>{
        case "apt":<span class="cov0" title="0">
                PrepLogs.Info("Detected APT package manager")
                return installWithApt(ctx, serverMgr, serverName, stream)</span>
        case "yum", "dnf":<span class="cov0" title="0">
                PrepLogs.Info("Detected YUM/DNF package manager")
                return installWithYum(ctx, serverMgr, serverName, stream)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported package manager: %s", pkgManager)</span>
        }
}

func installWithApt(ctx context.Context, serverMgr *server.ServerStruct, serverName string, stream io.Writer) error <span class="cov0" title="0">{
        // Check and install base packages only if missing
        basePkgs := []string{"curl", "git", "make", "gcc", "build-essential"}
        err := installIfMissing(ctx, serverMgr, serverName, basePkgs, stream)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install base packages: %w", err)
        }</span>

        // Docker installation check
        <span class="cov0" title="0">if !isInstalled(ctx, serverMgr, serverName, "docker", stream) </span><span class="cov0" title="0">{
                dockerCmds := []string{
                        "curl -fsSL https://get.docker.com | sudo sh",
                        "sudo usermod -aG docker $USER",
                        "sudo systemctl enable docker",
                        "sudo systemctl start docker",
                }
                if err := executeCommands(ctx, serverMgr, serverName, dockerCmds, stream); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("docker installation failed: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logToStream(stream, "‚úì Docker already installed", color.FgGreen)
        }</span>

        // Caddy installation check
        <span class="cov0" title="0">if !isInstalled(ctx, serverMgr, serverName, "caddy", stream) </span><span class="cov0" title="0">{
                caddyCmds := []string{
                        "sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https",
                        "curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --batch --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg",
                        "curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list",
                        "sudo apt update",
                        "sudo DEBIAN_FRONTEND=noninteractive apt install -y caddy",
                        "sudo systemctl enable caddy",
                        "sudo systemctl start caddy",
                }
                err := executeCommands(ctx, serverMgr, serverName, caddyCmds, stream)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("caddy installation failed: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logToStream(stream, "‚úì Caddy already installed", color.FgGreen)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper functions
func isInstalled(ctx context.Context, serverMgr *server.ServerStruct, serverName, command string, stream io.Writer) bool <span class="cov0" title="0">{
        checkCmd := fmt.Sprintf("command -v %s &gt;/dev/null 2&gt;&amp;1", command)
        _, err := serverMgr.ExecuteCommand(ctx, serverName, checkCmd, stream)
        return err == nil
}</span>

func installIfMissing(ctx context.Context, serverMgr *server.ServerStruct, serverName string, packages []string, stream io.Writer) error <span class="cov0" title="0">{
        var missingPkgs []string
        for _, pkg := range packages </span><span class="cov0" title="0">{
                if !isInstalled(ctx, serverMgr, serverName, pkg, stream) </span><span class="cov0" title="0">{
                        missingPkgs = append(missingPkgs, pkg)
                }</span>
        }

        <span class="cov0" title="0">if len(missingPkgs) == 0 </span><span class="cov0" title="0">{
                logToStream(stream, "‚úì All base packages already installed", color.FgGreen)
                return nil
        }</span>

        // Update package lists first
        <span class="cov0" title="0">updateCmd := "sudo apt update"
        if _, err := serverMgr.ExecuteCommand(ctx, serverName, updateCmd, stream); err != nil </span><span class="cov0" title="0">{
                PrepLogs.Warn("Failed to update package lists: %v", err)
        }</span>

        // Install with retries
        <span class="cov0" title="0">installCmd := fmt.Sprintf("sudo DEBIAN_FRONTEND=noninteractive apt install -y %s", strings.Join(missingPkgs, " "))

        maxRetries := 3
        for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 1 </span><span class="cov0" title="0">{
                        PrepLogs.Info("Retry attempt %d/%d for package installation", attempt, maxRetries)
                        time.Sleep(2 * time.Second) // Wait before retry
                }</span>

                <span class="cov0" title="0">output, err := serverMgr.ExecuteCommand(ctx, serverName, installCmd, stream)
                if err == nil </span><span class="cov0" title="0">{
                        logToStream(stream, fmt.Sprintf("‚úì Installed missing packages: %s", strings.Join(missingPkgs, ", ")), color.FgGreen)
                        return nil
                }</span>

                <span class="cov0" title="0">if attempt == maxRetries </span><span class="cov0" title="0">{
                        PrepLogs.Debug("Final installation attempt failed. Output: %s", output)
                        return fmt.Errorf("failed to install packages %s after %d attempts: %w",
                                strings.Join(missingPkgs, ", "), maxRetries, err)
                }</span>

                <span class="cov0" title="0">PrepLogs.Warn("Installation attempt %d failed: %v", attempt, err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
func logToStream(stream io.Writer, message string, colorAttr color.Attribute) <span class="cov0" title="0">{
        if stream != nil </span><span class="cov0" title="0">{
                c := color.New(colorAttr)
                c.Fprintln(stream, message)
        }</span>
}

func installWithYum(ctx context.Context, serverMgr *server.ServerStruct, serverName string, stream io.Writer) error <span class="cov0" title="0">{
        commands := []string{
                "sudo yum install -y curl git make gcc glibc-static ca-certificates yum-utils device-mapper-persistent-data lvm2",
                "curl -fsSL https://get.docker.com | sudo sh",
                "sudo usermod -aG docker $USER",
                "sudo systemctl enable docker",
                "sudo systemctl start docker",
                `sudo yum install -y yum-plugin-copr &amp;&amp;
                 sudo yum copr enable -y @caddy/caddy &amp;&amp;
                 sudo yum install -y caddy`,
        }

        return executeCommands(ctx, serverMgr, serverName, commands, stream)
}</span>

func executeCommands(ctx context.Context, serverMgr *server.ServerStruct, serverName string, commands []string, stream io.Writer) error <span class="cov0" title="0">{
        for _, cmd := range commands </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0">
                        if stream != nil </span><span class="cov0" title="0">{
                                color.New(color.FgYellow).Fprintf(stream, "‚ñ∂ %s\n", cmd)
                        }</span>

                        <span class="cov0" title="0">output, err := serverMgr.ExecuteCommand(ctx, serverName, cmd, stream)
                        if err != nil </span><span class="cov0" title="0">{
                                PrepLogs.Debug("Command failed: %s, Output: %s", cmd, output)
                                return fmt.Errorf("command failed: %s: %w", cmd, err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
func verifySudoAccess(ctx context.Context, serverMgr *server.ServerStruct, serverName string, stream io.Writer) error <span class="cov0" title="0">{
        PrepLogs.Info("Verifying sudo access...")

        // Test if we can run sudo without password
        testCmd := "sudo -n true 2&gt;/dev/null &amp;&amp; echo 'SUDO_OK' || echo 'SUDO_FAILED'"

        output, err := serverMgr.ExecuteCommand(ctx, serverName, testCmd, stream)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("sudo test failed: %w", err)
        }</span>

        <span class="cov0" title="0">if strings.Contains(output, "SUDO_FAILED") </span><span class="cov0" title="0">{
                return fmt.Errorf("passwordless sudo not working. Output: %s", output)
        }</span>

        <span class="cov0" title="0">PrepLogs.Debug("Sudo access verified: %s", strings.TrimSpace(output))
        return nil</span>
}

// CreateAppDirectory creates the minimal directory structure for containerized Next.js app
func CreateAppDirectory(ctx context.Context, serverMgr *server.ServerStruct, serverName string) error <span class="cov0" title="0">{
        const appDir = "/opt/nextjs-app" // Standard location for containerized apps

        PrepLogs.Info("Creating application directory on %s at %s", serverName, appDir)

        // Create the base directory with proper permissions
        createCmd := fmt.Sprintf(
                "sudo mkdir -p %s &amp;&amp; sudo chown -R $(whoami): %s &amp;&amp; sudo chmod 755 %s",
                appDir,
                appDir,
                appDir,
        )

        _, err := serverMgr.ExecuteCommand(ctx, serverName, createCmd, os.Stdout)
        failfast.Failfast(err, failfast.Error, fmt.Sprintf("Failed to create application directory: %s", appDir))
        // Verify directory was created
        verifyCmd := fmt.Sprintf("test -d %s &amp;&amp; echo 'exists' || echo 'missing'", appDir)
        output, err := serverMgr.ExecuteCommand(ctx, serverName, verifyCmd, nil)
        if err != nil || !strings.Contains(output, "exists") </span><span class="cov0" title="0">{
                return fmt.Errorf("directory verification failed: %w (output: %s)", err, output)
        }</span>

        <span class="cov0" title="0">PrepLogs.Success("‚úÖ Application directory ready at %s", appDir)
        return nil</span>
}

func verifyInstallation(ctx context.Context, serverMgr *server.ServerStruct, serverName string, stream io.Writer) error <span class="cov0" title="0">{
        PrepLogs.Info("Verifying installations...")

        checks := []struct {
                command string
                tool    string
        }{
                {"docker --version", "Docker"},
                {"caddy version", "Caddy"},
        }

        for _, check := range checks </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0">
                        if stream != nil </span><span class="cov0" title="0">{
                                color.New(color.FgBlue).Fprintf(stream, "üîç Checking %s installation...\n", check.tool)
                                PrepLogs.Debug("Running command: %s", check.command)

                        }</span>

                        <span class="cov0" title="0">output, err := serverMgr.ExecuteCommand(ctx, serverName, check.command, stream)
                        if err != nil </span><span class="cov0" title="0">{
                                PrepLogs.Error("Failed to verify %s installation: %v", check.tool, err)
                                return fmt.Errorf("failed to verify %s installation: %w", check.tool, err)
                        }</span>

                        <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                                PrepLogs.Debug("%s version: %s", check.tool, output)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "archive/tar"
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "github.com/docker/docker/api/types/build"
        "path/filepath"
        "strings"

        "github.com/docker/docker/client"
        "io"
        "nextdeploy/shared"
        "nextdeploy/shared/nextcore"
        "os"
        "time"

        "github.com/spf13/cobra"
)

var (
        PreviewLogger = shared.PackageLogger("preview", "PREVIEW")
)
var previewCmd = &amp;cobra.Command{
        Use:   "preview",
        Short: "preview the application in production mode",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Load metadata
                file, err := os.ReadFile(".nextdeploy/metadata.json")
                if err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error loading metadata: %v", err)
                        fmt.Printf("Error loading metadata: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">var payload nextcore.NextCorePayload
                if err := json.Unmarshal(file, &amp;payload); err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error parsing metadata: %v", err)
                        fmt.Printf("Error parsing metadata: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">ctx := context.Background()
                cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
                if err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error creating Docker client: %v", err)
                        panic(err)</span>
                }

                // Use consistent image naming with git commit hash
                <span class="cov0" title="0">imageName := fmt.Sprintf("%s:%s", strings.ToLower(payload.Config.App.Name), payload.GitCommit)
                PreviewLogger.Debug("Using image name: %s", imageName)
                if payload.GitCommit == "" </span><span class="cov0" title="0">{
                        imageName = fmt.Sprintf("%s:latest", strings.ToLower(payload.Config.App.Name))
                }</span>

                // Step 1: Create tar stream
                <span class="cov0" title="0">tarBuf, err := createTarContext(&amp;payload)
                if err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error creating tar context: %v", err)
                        panic(err)</span>
                }

                // Step 2: Build image
                <span class="cov0" title="0">buildOptions := build.ImageBuildOptions{
                        Tags:       []string{imageName},
                        Remove:     true,
                        Dockerfile: "Dockerfile",
                }

                buildResp, err := cli.ImageBuild(ctx, tarBuf, buildOptions)
                if err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error building image: %v", err)
                        panic(err)</span>
                }
                <span class="cov0" title="0">defer buildResp.Body.Close()

                // Stream build output and check for errors
                scanner := bufio.NewScanner(buildResp.Body)
                for scanner.Scan() </span><span class="cov0" title="0">{
                        line := scanner.Text()
                        fmt.Println(line)

                        // Check for build errors in the output
                        if strings.Contains(line, "ERROR") || strings.Contains(line, "error") </span><span class="cov0" title="0">{
                                PreviewLogger.Error("Build error detected: %s", line)
                                os.Exit(1)
                        }</span>
                }
                // Create runtime
                <span class="cov0" title="0">runtime, err := nextcore.NewNextRuntime(&amp;payload)
                if err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error creating runtime: %v", err)
                        fmt.Printf("Error creating runtime: %v\n", err)
                        os.Exit(1)
                }</span>

                // Create and start container
                <span class="cov0" title="0">containerID, err := runtime.CreateContainer(context.Background())
                PreviewLogger.Debug("Creating container with ID: %s", containerID)
                if err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error creating container: %v", err)
                        fmt.Printf("Error starting container: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Container started successfully: %s\n", containerID)

                // Configure reverse proxy if needed
                if err := runtime.ConfigureReverseProxy(); err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error configuring reverse proxy: %v", err)
                        fmt.Printf("Error configuring reverse proxy: %v\n", err)
                        os.Exit(1)
                }</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(previewCmd)
}</span>
func createTarContext(meta *nextcore.NextCorePayload) (io.Reader, error) <span class="cov0" title="0">{
        pr, pw := io.Pipe()
        tw := tar.NewWriter(pw)

        go func() </span><span class="cov0" title="0">{
                defer pw.Close()
                defer tw.Close()

                // Read Dockerfile from current directory
                dockerfileContent, err := os.ReadFile("Dockerfile")
                if err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error reading Dockerfile: %v", err)
                        pw.CloseWithError(err)
                        return
                }</span>
                <span class="cov0" title="0">PreviewLogger.Debug("Dockerfile content read successfully: %s", string(dockerfileContent))

                // Write Dockerfile to tar
                err = writeToTar(tw, "Dockerfile", dockerfileContent)
                if err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error writing Dockerfile to tar: %v", err)
                        pw.CloseWithError(err)
                        return
                }</span>

                // Copy app source, excluding unnecessary files
                <span class="cov0" title="0">PreviewLogger.Debug("Writing app files to tar from root directory: %s", meta.RootDir)
                err = filepath.Walk(meta.RootDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                PreviewLogger.Error("Error walking path %s: %v", path, err)
                                return err
                        }</span>

                        // Skip directories and unwanted files
                        <span class="cov0" title="0">if info.IsDir() ||
                                strings.Contains(path, "node_modules") ||
                                strings.Contains(path, ".next") ||
                                strings.Contains(path, ".git") </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">relPath := strings.TrimPrefix(path, meta.RootDir+string(filepath.Separator))
                        fileData, err := os.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                PreviewLogger.Error("Error reading file %s: %v", path, err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return writeToTar(tw, relPath, fileData)</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        PreviewLogger.Error("Error writing app files to tar: %v", err)
                        pw.CloseWithError(err)
                        return
                }</span>
        }()

        <span class="cov0" title="0">return pr, nil</span>
}

func writeToTar(tw *tar.Writer, name string, data []byte) error <span class="cov0" title="0">{
        hdr := &amp;tar.Header{
                Name:     name,
                Mode:     0644,
                Size:     int64(len(data)),
                Typeflag: tar.TypeReg,
                ModTime:  time.Now(),
        }
        if err := tw.WriteHeader(hdr); err != nil </span><span class="cov0" title="0">{
                PreviewLogger.Error("Error writing header for %s: %v", name, err)
                return err
        }</span>
        <span class="cov0" title="0">_, err := tw.Write(data)
        return err</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
        "nextdeploy/shared"
)

// Package-level variables for command configuration and logging
var (
        // provisionLogger provides a dedicated logger instance for provisioning operations
        // with a descriptive emoji for better visual identification in logs
        provisionLogger = shared.PackageLogger("Provision", "üîß Provision")
)

// provisionResources defines the 'provision' command for setting up cloud infrastructure
var provisionResources = &amp;cobra.Command{
        Use:   "provision",
        Short: "Provision cloud resources for Next.js deployment",
        Long: `
The 'provision' command automates the setup of required cloud infrastructure for deploying 
Next.js applications. It handles the creation and configuration of:

Core Components:
- Container Registry repositories for Docker image storage
- Identity and Access Management (IAM) roles with least-privilege policies
- Dedicated deployment users with appropriate permissions
- Infrastructure as Code (IaC) templates for consistent environments

This command ensures your cloud environment is properly configured 
before application deployment, following infrastructure best practices.
This command should be built in cloud agnostic way. By providing user with as many cloud options as 
possible. User should be able to pass their prefered cloud as flag.
`,
        // PreRunE performs validation and data collection before execution
        PreRunE: collectResourcesData,

        // RunE contains the main provisioning logic
        RunE: executeProvisioning,
}

// init registers the provision command and its flags with the root command
func init() <span class="cov0" title="0">{
        // Add cloud provider flag with AWS as default
        provisionResources.Flags().StringP(
                "cloud-provider",
                "c",
                "aws",
                "Target cloud platform (aws|gcp|azure) for resource provisioning",
        )

        // Register the command with the root command
        rootCmd.AddCommand(provisionResources)
}</span>

// executeProvisioning implements the core provisioning workflow
func executeProvisioning(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        provisionLogger.Info("Initializing infrastructure provisioning...")

        // TODO: Implement actual provisioning logic here
        // 1. Validate cloud provider selection
        // 2. Initialize cloud provider client
        // 3. Execute resource creation workflow
        // 4. Handle rollback on failures

        return nil
}</span>

// collectResourcesData performs pre-execution validation and data gathering
func collectResourcesData(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        provisionLogger.Info("Preparing provisioning configuration...")

        // TODO: Implement configuration collection
        // 1. Parse and validate flags
        // 2. Load any configuration files
        // 3. Verify required permissions
        // 4. Check for existing resources

        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
NextDeploy - A clean and powerful CLI for Next.js deployments
*/
package cmd

import (
        "fmt"
        "os"
        "strings"

        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

// Semantic color functions
var (
        title     = color.New(color.FgHiBlue, color.Bold).SprintFunc()
        success   = color.New(color.FgHiGreen).SprintFunc()
        warning   = color.New(color.FgHiYellow, color.Bold).SprintFunc()
        errorMsg  = color.New(color.FgHiRed, color.Bold).SprintFunc()
        command   = color.New(color.FgCyan).SprintFunc()
        highlight = color.New(color.Bold).SprintFunc()
)

// rootCmd is the main command
var rootCmd = &amp;cobra.Command{
        Use:   "nextdeploy",
        Short: "CLI for automating Next.js deployments on any VPS with a custom daemon.",
        Long: fmt.Sprintf(`%s %s

%s
Deploy your Next.js app to *any* VPS ‚Äî with Docker, SSL, logs, and zero downtime.

%s
%s Build Docker images with ease
%s Push and deploy to remote servers in seconds
%s Configure automatic SSL + monitoring
%s Ship production-ready builds with full control

%s %s
`,
                title("üöÄ NextDeploy"), warning("v1.0.0"),
                highlight("Simple. Fast. Infrastructure-Agnostic."),
                highlight("Features:"),
                success("‚úì"),
                success("‚úì"),
                success("‚úì"),
                success("‚úì"),
                warning("Tip:"), command("nextdeploy --help"),
        ),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                fmt.Printf("\n%s %s\n\n",
                        success("‚ú® Welcome to"), highlight("NextDeploy CLI"),
                )

                if len(args) == 0 </span><span class="cov0" title="0">{
                        fmt.Println(highlight("Quick Start:"))
                        fmt.Printf("  %s - Initialize a new project\n", command("nextdeploy init"))
                        fmt.Printf("  %s - Build the image for the app\n", command("nextdeploy build"))
                        fmt.Printf("  %s - Deploy your app on the VPS\n\n", command("nextdeploy ship"))

                        fmt.Printf("%s %s\n\n",
                                warning("Docs ‚Üí"), command("https://nextdeploy.one/docs"),
                        )
                }</span>
        },
}

func Execute() <span class="cov0" title="0">{
        fmt.Println()

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("\n%s %s\n\n",
                        errorMsg("‚ùå Error:"), err,
                )
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println(strings.Repeat("‚îÄ", 60))
        fmt.Printf("%s %s\n",
                command("Need help?"),
                warning("Visit https://nextdeploy.one/docs"),
        )
        fmt.Println(strings.Repeat("‚îÄ", 60))
        fmt.Println()</span>
}

func init() <span class="cov0" title="0">{
        rootCmd.SetHelpTemplate(fmt.Sprintf(`%s
%s

{{if or .Runnable .HasSubCommands}}{{.UsageString}}{{end}}`,
                title("‚ú® NextDeploy CLI Toolkit"),
                warning("Usage: {{.UseLine}}"),
        ))

        rootCmd.SetUsageTemplate(`{{.UseLine}}

  {{.Short}}

{{if .HasAvailableFlags}}Options:
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}

{{if .HasAvailableSubCommands}}Commands:
{{range .Commands}}{{if .IsAvailableCommand}}  {{rpad .Name .NamePadding }} {{.Short}}
{{end}}{{end}}{{end}}

Run '{{.CommandPath}} [command] --help' for more information about a command.
`)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">//
//
// HERE : In this command we have s small idea of error handling and logging where
//       we pass go errors to a generic failfast function that handles the error
//       I have confned it  to this command mostly because i want it reviewed and made better by other devs
//       NOTE: Please check it out and let me know if you have any suggestions or improvements or you think it is a bad
//             idea to use this pattern in the project or in any go project

// TODO: fix logic to get env file and run with latest image just locally
package cmd

import (
        "fmt"
        "github.com/spf13/cobra"
        "nextdeploy/shared/failfast"
        "nextdeploy/shared/git"
        "nextdeploy/shared"
        "nextdeploy/shared/nextdeploy"
        "nextdeploy/shared/secrets"
        "os"
        "os/exec"
        "path/filepath"
)

type Config struct {
        Image string `yaml:"image"`
}

var (
        runLogger = shared.PackageLogger("RunImage::", "üöÄ Run Image::")
)

var runimageCmd = &amp;cobra.Command{
        Use:   "runimage",
        Short: "Run Docker image with configuration from YAML",
        Long: `Reads image name from YAML config, gets tag from git commit or flag,
and runs the Docker container with environment variables from Doppler.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                runImage()
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(runimageCmd)
}</span>

func runImage() <span class="cov0" title="0">{
        // Read config file
        config, err := nextdeploy.Load("nextdeploy.yml")
        failfast.Failfast(err, failfast.Error, "Failed to load configuration file")

        imageTag, err := git.GetCommitHash()
        failfast.Failfast(err, failfast.Error, "Failed to get git commit hash")
        sm, err := secrets.NewSecretManager()
        failfast.Failfast(err, failfast.Error, "Failed to initialize SecretManager")
        runLogger.Debug("SecretManager initialized successfully")
        if sm.IsDopplerEnabled() </span><span class="cov0" title="0">{
                runLogger.Info("Doppler is enabled, downloading secrets...")
                failfast.Failfast(err, failfast.Error, "Failed to download Doppler secrets")
        }</span> else<span class="cov0" title="0"> {
                runLogger.Warn("Doppler is not enabled, skipping secrets download.")
        }</span>
        // Load secrets

        // Run Docker container
        <span class="cov0" title="0">fullImage := fmt.Sprintf("%s:%s", config.Docker.Image, imageTag)
        runLogger.Debug("Full Docker image to run: %s", fullImage)
        err = runDockerContainer(fullImage)
        failfast.Failfast(err, failfast.Error, "Failed to run Docker container")

        fmt.Println("Docker container started successfully")</span>
}

func runDockerContainer(image string) error <span class="cov0" title="0">{
        absPath, err := filepath.Abs(".env")
        runLogger.Debug("Absolute path for .env file: %s", absPath)
        failfast.Failfast(err, failfast.Error, "Failed to get absolute path for .env file")

        cmd := exec.Command("docker", "run", "-p", "3000:3000", "--env-file", absPath, image)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err = cmd.Run()
        failfast.Failfast(err, failfast.Error, "Failed to run Docker container")
        runLogger.Success("Docker container started with image: %s", image)

        return nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "nextdeploy/shared"
        "nextdeploy/shared/secrets"
        "os"
)
import (
        "fmt"

        "github.com/spf13/cobra"
)

var (
        Elogs = shared.PackageLogger("EncryptFiles::", "üîê Encrypt Files::")
)
var (
        encryptfiles = &amp;cobra.Command{
                Use:   "secrets",
                Short: "Encrypt files for secure storage",
                Long: `
       Encrypt files using AES encryption for secure storage. 
                         This command allows you to specify the files to encrypt and the output location.
                `,
                PreRun: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        // make sure context of the files exists
                        filesContextExist() // This function should check if the context for files exists
                }</span>,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        encryptFiles()
                        fmt.Println("Files encrypted successfully!")
                }</span>,
        }
)

func encryptFiles() <span class="cov0" title="0">{
        // Initialize the secret manager
        sm, err := secrets.NewSecretManager()
        if err != nil </span><span class="cov0" title="0">{
                Elogs.Error("Failed to initialize SecretManager: %v", err)
                os.Exit(1)
        }</span>

        // Check if Doppler is enabled
        <span class="cov0" title="0">if sm.IsDopplerEnabled() </span><span class="cov0" title="0">{
                Elogs.Info("Doppler is enabled, no need for this whole process...")
        }</span>
        // first check if the key exist
        <span class="cov0" title="0">if sm.IsKeyExist() </span><span class="cov0" title="0">{
                Elogs.Info("Encryption key already exists, using existing key for encryption.")
        }</span> else<span class="cov0" title="0"> {
                Elogs.Info("No existing encryption key found, generating a new key.")
                key, err := sm.GeneratePlatformKey()
                if err != nil </span><span class="cov0" title="0">{
                        Elogs.Error("Failed to generate encryption key:%v", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">Elogs.Info("Encryption key generated successfully: %s", key)</span>
        }
        // Get the key now since it exists
        <span class="cov0" title="0">home, _ := os.UserHomeDir()
        appname := sm.GetAppName()
        keyPath := home + "/.nextdeploy/" + appname + "/master.key"
        key, err := os.ReadFile(keyPath)
        if err != nil </span><span class="cov0" title="0">{
                Elogs.Error("Failed to read encryption key from %s: %v", keyPath, err)
                os.Exit(1)
        }</span>
        // Encrypt the encrypt
        <span class="cov0" title="0">if err := sm.EncryptFile("nextdeploy.yml", key); err != nil </span><span class="cov0" title="0">{
                Elogs.Error("Failed to encrypt files: %v", err)
                os.Exit(1)
        }</span>
        // Encrypt the .env file
        <span class="cov0" title="0">if err := sm.EncryptFile(".env", key); err != nil </span><span class="cov0" title="0">{
                Elogs.Error("Failed to encrpt env files:%s", err)
                os.Exit(1)
        }</span>

        // write files to gitignore

        <span class="cov0" title="0">Elogs.Info("Files encrypted successfully.")</span>

}

func filesContextExist() <span class="cov0" title="0">{
        // Placeholder for checking if the files context exists
        // This function should implement the logic to verify the existence of the files context
        Elogs.Info("Checking if files context exists...")
        // For now, we assume it always exists
        // check for nextdeploy.yml file exists
        if _, err := os.Stat("nextdeploy.yml"); os.IsNotExist(err) </span><span class="cov0" title="0">{
                Elogs.Error("nextdeploy.yml file does not exist. Please run 'nextdeploy init' first.")
                os.Exit(1)
        }</span> else<span class="cov0" title="0"> {
                Elogs.Info("Files context exists, proceeding with encryption.")
        }</span>
        // check env files exist
        <span class="cov0" title="0">if _, err := os.Stat(".env"); os.IsNotExist(err) </span><span class="cov0" title="0">{
                Elogs.Error(".env file does not exist. Please create it before running this command.")
                os.Exit(1)
        }</span> else<span class="cov0" title="0"> {
                Elogs.Info(".env file exists, proceeding with encryption.")
        }</span>
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(encryptfiles)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "context"
        "fmt"
        "io"
        "nextdeploy/cli/internal/server"
        "nextdeploy/cli/internal/ship"
        "nextdeploy/shared"
        "os"
        "os/signal"

        "github.com/spf13/cobra"
)

var (
        ShipLogs    = shared.PackageLogger("ship::", "üö¢::")
        dryRun      bool
        credentials bool
        newapp      bool
        bluegreen   bool
        serve       bool
)

var shipCmd = &amp;cobra.Command{
        Use:   "ship",
        Short: "Deploy a containerized application to target VPS",
        Long: `The ship command handles the complete deployment lifecycle:
- Verifies server connectivity
- Transfers necessary files
- Pulls the specified Docker image
- Deploys containers with proper configuration
- Verifies deployment success`,
        Run: Ship,
}

func init() <span class="cov0" title="0">{
        shipCmd.Flags().BoolVarP(&amp;serve, "serve", "s", false, "Perform new caddy setup")
        shipCmd.Flags().BoolVarP(&amp;credentials, "credentials", "c", false, "Use credentials for deployment")
        shipCmd.Flags().BoolVarP(&amp;dryRun, "dry-run", "d", false, "Simulate deployment without making changes")
        shipCmd.Flags().BoolVarP(&amp;newapp, "new", "n", false, "Indicate this is a new application deployment")
        shipCmd.Flags().BoolVarP(&amp;bluegreen, "bluegreen", "b", false, "Use blue-green deployment strategy")

        rootCmd.AddCommand(shipCmd)
}</span>

func Ship(cmd *cobra.Command, args []string) <span class="cov0" title="0">{

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        c := make(chan os.Signal, 1)
        signal.Notify(c, os.Interrupt)

        go func() </span><span class="cov0" title="0">{
                &lt;-c
                cancel()
                ShipLogs.Debug("Received interrupt signal, cleaning up...")
                os.Exit(1)
        }</span>()
        <span class="cov0" title="0">ShipLogs.Debug("Starting deployment process...")

        serverMgr, err := server.New(
                server.WithConfig(),
                server.WithSSH(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := serverMgr.CloseSSHConnection(); err != nil </span><span class="cov0" title="0">{
                        ShipLogs.Error("Error closing connections: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">servers := serverMgr.ListServers()
        if len(servers) == 0 </span><span class="cov0" title="0">{
                ShipLogs.Debug("No servers configured for deployment")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">var stream = io.Discard

        if err := runDeployment(ctx, serverMgr, servers, stream); err != nil </span><span class="cov0" title="0">{
                ShipLogs.Error("Deployment failed: %v", err)
                return
        }</span>

        <span class="cov0" title="0">ShipLogs.Success("\nüéâ Deployment completed successfully! üéâ")</span>
}

func runDeployment(ctx context.Context, serverMgr *server.ServerStruct, servers []string, stream io.Writer) error <span class="cov0" title="0">{
        ShipLogs.Info("=== PHASE 1: Pre-deployment checks ===")
        if err := ship.VerifyServers(ctx, serverMgr, servers, stream); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pre-deployment checks failed: %w", err)
        }</span>

        <span class="cov0" title="0">ShipLogs.Info("=== PHASE 2: File transfers ===")
        if err := ship.TransferRequiredFiles(ctx, serverMgr, stream, servers[0]); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("file transfer failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !dryRun </span><span class="cov0" title="0">{
                ShipLogs.Info("=== PHASE 3: Container deployment ===")
                if err := ship.DeployContainers(ctx, serverMgr, servers[0], credentials, stream); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("container deployment failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">ShipLogs.Info("=== PHASE 4: Post-deployment verification ===")
        if err := ship.VerifyDeployment(ctx, serverMgr, servers[0], stream); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("post-deployment verification failed: %w", err)
        }</span>
        //TODO: Re-enable Caddy setup using daemon
        // if serve {
        //         ShipLogs.Info(" ==== PHASE 4: Refresh caddy  ====")
        //         if err := ship.SetupCaddy(ctx, serverMgr, servers[0], fresh, stream); err != nil {
        //                 return fmt.Errorf("caddy setup failed: %w", err)
        //         }
        // }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package build

import (
        "fmt"
        "nextdeploy/shared/git"
        "nextdeploy/shared"
        "nextdeploy/shared/nextdeploy"
        "strings"
        "time"
)

// ImageNameBuilder handles the construction of Docker image names with proper formatting
type ImageNameBuilder struct {
        baseName     string
        registry     string
        tag          string
        nameStrategy string
        useTimestamp bool
        branchName   string
}

var buildlogger = shared.PackageLogger("BUILD", "üß± BUILD")

// NewImageNameBuilder creates a new image name builder with default values
func NewImageNameBuilder(baseName, registry string) *ImageNameBuilder <span class="cov0" title="0">{
        // print out the base name and registry
        buildlogger.Info("Creating ImageNameBuilder with base name: %s, registry: %s", baseName, registry)
        return &amp;ImageNameBuilder{
                baseName:     baseName,
                registry:     registry,
                nameStrategy: "commit-hash",
                useTimestamp: true,
        }
}</span>

// WithTag sets the explicit tag for the image
func (b *ImageNameBuilder) WithTag(tag string) *ImageNameBuilder <span class="cov0" title="0">{
        b.tag = tag
        return b
}</span>

// WithNameStrategy sets the naming strategy
func (b *ImageNameBuilder) WithNameStrategy(strategy string) *ImageNameBuilder <span class="cov0" title="0">{
        b.nameStrategy = strategy
        return b
}</span>

// WithTimestamp controls whether to append timestamp
func (b *ImageNameBuilder) WithTimestamp(use bool) *ImageNameBuilder <span class="cov0" title="0">{
        b.useTimestamp = use
        return b
}</span>

// WithBranch sets the branch name for branch-based strategies
func (b *ImageNameBuilder) WithBranch(branch string) *ImageNameBuilder <span class="cov0" title="0">{
        b.branchName = branch
        return b
}</span>

// Build constructs the final image name according to the configured strategy
func (b *ImageNameBuilder) Build() (string, error) <span class="cov0" title="0">{
        // Validate base name
        if strings.TrimSpace(b.baseName) == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("image base name cannot be empty")
        }</span>

        // Get or generate tag
        <span class="cov0" title="0">tag, err := b.generateTag()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate tag: %w", err)
        }</span>

        // Construct full image name
        <span class="cov0" title="0">imageName := b.baseName
        if b.registry != "" &amp;&amp; !strings.Contains(imageName, "/") </span><span class="cov0" title="0">{
                imageName = strings.TrimSuffix(b.registry, "/") + "/" + imageName
        }</span>

        <span class="cov0" title="0">return imageName + ":" + tag, nil</span>
}

// generateTag creates the appropriate tag based on the naming strategy
func (b *ImageNameBuilder) generateTag() (string, error) <span class="cov0" title="0">{
        // Use explicit tag if provided
        if b.tag != "" </span><span class="cov0" title="0">{
                return b.tag, nil
        }</span>

        // Generate tag based on strategy
        <span class="cov0" title="0">switch b.nameStrategy </span>{
        case "commit-hash":<span class="cov0" title="0">
                return b.generateCommitHashTag()</span>
        case "branch-commit":<span class="cov0" title="0">
                return b.generateBranchCommitTag()</span>
        case "simple":<span class="cov0" title="0">
                return "latest", nil</span>
        case "semver":<span class="cov0" title="0">
                return "", fmt.Errorf("semver strategy requires explicit --tag")</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unknown naming strategy: %s", b.nameStrategy)</span>
        }
}

// generateCommitHashTag creates a tag with commit hash (and optional timestamp)
func (b *ImageNameBuilder) generateCommitHashTag() (string, error) <span class="cov0" title="0">{
        hash, err := git.GetCommitHash()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get git commit hash: %w", err)
        }</span>

        <span class="cov0" title="0">if !b.useTimestamp </span><span class="cov0" title="0">{
                return hash, nil
        }</span>

        <span class="cov0" title="0">timestamp := time.Now().Format("20060102-150405")
        return fmt.Sprintf("%s-%s", hash, timestamp), nil</span>
}

// generateBranchCommitTag creates a tag with branch name and commit hash
func (b *ImageNameBuilder) generateBranchCommitTag() (string, error) <span class="cov0" title="0">{
        branch := b.branchName
        if branch == "" </span><span class="cov0" title="0">{
                var err error
                branch, err = git.GetCurrentBranch()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to get git branch: %w", err)
                }</span>
        }

        // Sanitize branch name
        <span class="cov0" title="0">branch = strings.ToLower(branch)
        branch = strings.ReplaceAll(branch, "/", "-")
        branch = strings.ReplaceAll(branch, " ", "-")

        hash, err := git.GetCommitHash()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get git commit hash: %w", err)
        }</span>

        <span class="cov0" title="0">tag := fmt.Sprintf("%s-%s", branch, hash)

        if b.useTimestamp </span><span class="cov0" title="0">{
                timestamp := time.Now().Format("20060102-150405")
                tag = fmt.Sprintf("%s-%s", tag, timestamp)
        }</span>

        <span class="cov0" title="0">return tag, nil</span>
}

// constructImageName constructs the image name using the ImageNameBuilder
func ConstructImageName(tag string) string <span class="cov0" title="0">{
        config, err := nextdeploy.Load("nextdeploy.yml")
        if err != nil </span><span class="cov0" title="0">{
                buildlogger.Error("Failed to load nextdeploy.yml: %v", err)
                return ""
        }</span>
        // the image  name before image name build is
        <span class="cov0" title="0">buildlogger.Info("Image name before image name build: %s", config.Docker.Image)
        //builder := NewImageNameBuilder(config.Docker.Image, config.Docker.Registry)
        // if tag != "" {
        //         builder.WithTag(tag)
        // }

        /* imageName, err := builder.Build() */
        //println("Image Name:", imageName)
        // buildlogger.Info("Constructed image name: %s", imageName)
        // if err != nil {
        //         buildlogger.Error("Failed to build image name: %v", err)
        //         return ""
        // }

        return config.Docker.Image + ":" + tag</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package initialcommand

import (
        "bufio"
        "fmt"
        "nextdeploy/shared"
        "nextdeploy/shared/config"
        "nextdeploy/shared/docker"
        "os"

        "github.com/spf13/cobra"
)

func RunInitCommand(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        dm, err := docker.NewDockerClient(shared.SharedLogger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create Docker client: %w", err)
        }</span>
        <span class="cov0" title="0">reader := bufio.NewReader(os.Stdin)
        log := shared.PackageLogger("Initialization", "Initialization")

        //        cmd.Println("üöÄ NextDeploy Initialization")
        log.Info("üöÄ NextDeploy Initialization")
        log.Info("----------------------------------------")
        if err := config.HandleConfigSetup(cmd, reader); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration setup failed: %w", err)
        }</span>

        <span class="cov0" title="0">if err := docker.HandleDockerfileSetup(cmd, dm, reader); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("docker setup failed: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info("\nüéâ Setup complete! Next steps:")
        if exists, _ := dm.DockerfileExists("."); exists </span><span class="cov0" title="0">{
                log.Info("- Review the generated Dockerfile")
        }</span>
        <span class="cov0" title="0">log.Info("- Review your nextdeploy.yml configuration")
        log.Info("- Run 'nextdeploy build' to build the Docker image")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package prompt

import (
        "bufio"
        "fmt"
        "os"
        "strings"
)

type Prompter interface {
        YesNo(msg string, defaultYes bool) (bool, error)
        Select(label string, options []string) (string, error)
        ConfirmOverwrite(path string) (bool, error)
}

type cliPrompter struct {
        nonInteractive bool
}

func NewCLIPrompter(nonInteractive bool) Prompter <span class="cov0" title="0">{
        return &amp;cliPrompter{nonInteractive}
}</span>

func (p *cliPrompter) YesNo(msg string, defaultYes bool) (bool, error) <span class="cov0" title="0">{
        if p.nonInteractive </span><span class="cov0" title="0">{
                return defaultYes, nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("%s [y/n]: ", msg)
        reader := bufio.NewReader(os.Stdin)
        input, _ := reader.ReadString('\n')
        return strings.HasPrefix(strings.ToLower(input), "y"), nil</span>
}

func (p *cliPrompter) Select(label string, options []string) (string, error) <span class="cov0" title="0">{
        // Placeholder for selection logic
        return options[0], nil
}</span>

func (p *cliPrompter) ConfirmOverwrite(path string) (bool, error) <span class="cov0" title="0">{
        return p.YesNo(fmt.Sprintf("Overwrite %s?", path), false)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package server

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "net"
        "nextdeploy/shared/config"
        "nextdeploy/shared"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/pkg/sftp"
        "golang.org/x/crypto/ssh"
        "golang.org/x/crypto/ssh/knownhosts"
        "nextdeploy/shared/envstore"
        "nextdeploy/shared/git"
        "nextdeploy/shared/registry"
)

var (
        serverlogger = shared.PackageLogger("Server", "üÖ±)SERVERLOGGER")
)

// ServerStruct manages multiple SSH connections and provides operations
type ServerStruct struct {
        config     *config.NextDeployConfig
        sshClients map[string]*SSHClient
        mu         sync.RWMutex // protects sshClients map
}

// SSHClient wraps SSH client and related configurations
type SSHClient struct {
        Client     *ssh.Client
        Config     *ssh.ClientConfig
        SFTPClient *sftp.Client
        LastUsed   time.Time
        mu         sync.Mutex // protects individual client operations
}

// ServerOption defines the functional option type
type ServerOption func(*ServerStruct) error

// New creates a new ServerStruct with provided options
func New(opts ...ServerOption) (*ServerStruct, error) <span class="cov0" title="0">{
        s := &amp;ServerStruct{
                sshClients: make(map[string]*SSHClient),
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(s); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to apply option: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return s, nil</span>
}

// WithConfig loads and applies the configuration
func WithConfig() ServerOption <span class="cov0" title="0">{
        return func(s *ServerStruct) error </span><span class="cov0" title="0">{
                cfg, err := config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load configuration: %w", err)
                }</span>
                <span class="cov0" title="0">s.config = cfg
                serverlogger.Info("Configuration loaded successfully")
                return nil</span>
        }
}
func WithDaemon() ServerOption <span class="cov0" title="0">{
        return func(s *ServerStruct) error </span><span class="cov0" title="0">{
                serverlogger.Debug("Writing NextDeploy Agent connection here")
                return nil
        }</span>
}

// WithSSH initializes SSH connections for all configured servers
func WithSSH() ServerOption <span class="cov0" title="0">{
        return func(s *ServerStruct) error </span><span class="cov0" title="0">{
                if s.config == nil || len(s.config.Servers) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("the server configuration is not loaded or no servers configured")
                }</span>

                <span class="cov0" title="0">s.mu.Lock()
                defer s.mu.Unlock()

                var wg sync.WaitGroup
                errChan := make(chan error, len(s.config.Servers))
                serverlogger.Info("The config.Servers value at with withssh function is :%v", s.config.Servers)

                for _, serverCfg := range s.config.Servers </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func(cfg config.ServerConfig) </span><span class="cov0" title="0">{
                                defer wg.Done()
                                client, err := connectSSH(cfg)
                                if err != nil </span><span class="cov0" title="0">{
                                        errChan &lt;- fmt.Errorf("server %s: %w", cfg.Name, err)
                                        return
                                }</span>
                                <span class="cov0" title="0">s.sshClients[cfg.Name] = client
                                serverlogger.Info("Successfully connected to server %s (%s)", cfg.Name, cfg.Host)</span>
                        }(serverCfg)
                }

                <span class="cov0" title="0">wg.Wait()
                close(errChan)

                var errs []error
                for err := range errChan </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                        serverlogger.Debug("errs look like this %s:", errs)
                        return fmt.Errorf("failed to connect to some servers: %v", errs)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func (s *ServerStruct) GetDeploymentServer() (string, error) <span class="cov0" title="0">{
        if s.config == nil || s.config.Deployment.Server.Host == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("deployment server configuration is not set")
        }</span>
        // find the matchin in servers list
        <span class="cov0" title="0">for _, server := range s.config.Servers </span><span class="cov0" title="0">{
                if server.Name == s.config.Deployment.Server.Host </span><span class="cov0" title="0">{
                        _, err := connectSSH(server)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to connect to deployment server %s: %w", server.Name, err)
                        }</span>
                        <span class="cov0" title="0">return server.Name, nil</span>
                }
        }
        <span class="cov0" title="0">return "", fmt.Errorf("deployment server %s not found in configuration", s.config.Deployment.Server.Host)</span>
}
func AddHostToKnownHosts(ip string, knownHostsPath string) error <span class="cov0" title="0">{
        // Validate IP/hostname
        if net.ParseIP(ip) == nil &amp;&amp; !isValidHostname(ip) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid IP address or hostname: %s", ip)
        }</span>

        // Set default known_hosts path if not provided
        <span class="cov0" title="0">if knownHostsPath == "" </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get home directory: %v", err)
                }</span>
                <span class="cov0" title="0">knownHostsPath = filepath.Join(home, ".ssh", "known_hosts")</span>
        }

        // Create .ssh directory if it doesn't exist
        <span class="cov0" title="0">sshDir := filepath.Dir(knownHostsPath)
        if _, err := os.Stat(sshDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.Mkdir(sshDir, 0700); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create .ssh directory: %v", err)
                }</span>
        }

        // Get the host key using ssh-keyscan
        <span class="cov0" title="0">cmd := exec.Command("ssh-keyscan", ip)
        var out bytes.Buffer
        cmd.Stdout = &amp;out
        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ssh-keyscan failed: %v", err)
        }</span>

        <span class="cov0" title="0">hostKey := strings.TrimSpace(out.String())
        if hostKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no host key returned for %s", ip)
        }</span>

        // Append to known_hosts file
        <span class="cov0" title="0">f, err := os.OpenFile(knownHostsPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open known_hosts file: %v", err)
        }</span>
        <span class="cov0" title="0">defer f.Close()

        if _, err := f.WriteString(hostKey + "\n"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to known_hosts file: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper function to validate hostnames
func isValidHostname(hostname string) bool <span class="cov0" title="0">{
        if len(hostname) &gt; 253 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, part := range strings.Split(hostname, ".") </span><span class="cov0" title="0">{
                if len(part) &gt; 63 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// connectSSH establishes an SSH connection and initializes SFTP client
func connectSSH(cfg config.ServerConfig) (*SSHClient, error) <span class="cov0" title="0">{
        if cfg.Port == 0 </span><span class="cov0" title="0">{
                cfg.Port = 22
        }</span>
        <span class="cov0" title="0">ip := cfg.Host
        err := AddHostToKnownHosts(ip, "")
        if err != nil </span><span class="cov0" title="0">{
                serverlogger.Error("Failed to add host %s to known_hosts: %v", ip, err)
                return nil, fmt.Errorf("failed to add host %s to known_hosts: %w", ip, err)
        }</span>
        <span class="cov0" title="0">authMethods, err := getAuthMethods(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">hostKeyCallback, err := getHostKeyCallback()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sshConfig := &amp;ssh.ClientConfig{
                User:            cfg.Username,
                Auth:            authMethods,
                HostKeyCallback: hostKeyCallback,
                Timeout:         15 * time.Second,
                Config: ssh.Config{
                        KeyExchanges: []string{"curve25519-sha256@libssh.org"},
                        Ciphers:      []string{"chacha20-poly1305@openssh.com"},
                },
        }

        if len(authMethods) == 0 </span><span class="cov0" title="0">{
                sshConfig.Auth = []ssh.AuthMethod{authMethods[0]}
        }</span>

        <span class="cov0" title="0">addr := fmt.Sprintf("%s:%d", cfg.Host, cfg.Port)
        client, err := ssh.Dial("tcp", addr, sshConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to dial: %w", err)
        }</span>

        <span class="cov0" title="0">sftpClient, err := sftp.NewClient(client)
        if err != nil </span><span class="cov0" title="0">{
                client.Close()
                return nil, fmt.Errorf("failed to create SFTP client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SSHClient{
                Client:     client,
                Config:     sshConfig,
                SFTPClient: sftpClient,
                LastUsed:   time.Now(),
        }, nil</span>
}

func getAuthMethods(cfg config.ServerConfig) ([]ssh.AuthMethod, error) <span class="cov0" title="0">{
        var authMethods []ssh.AuthMethod

        if cfg.KeyPath == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no SSH key path provided for server %s", cfg.Name)
        }</span>

        // Handle path expansion
        <span class="cov0" title="0">expandedPath := cfg.KeyPath
        if strings.HasPrefix(expandedPath, "~") </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get user home directory: %w", err)
                }</span>
                <span class="cov0" title="0">expandedPath = filepath.Join(home, expandedPath[1:])</span>
        }
        <span class="cov0" title="0">expandedPath = os.ExpandEnv(expandedPath)

        serverlogger.Debug("Key path resolution: %s -&gt; %s", cfg.KeyPath, expandedPath)

        key, err := os.ReadFile(expandedPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read SSH key file %s (resolved to %s): %w",
                        cfg.KeyPath, expandedPath, err)
        }</span>

        <span class="cov0" title="0">signer, err := ssh.ParsePrivateKey(key)
        if err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(*ssh.PassphraseMissingError); ok &amp;&amp; cfg.KeyPassphrase != "" </span><span class="cov0" title="0">{
                        signer, err = ssh.ParsePrivateKeyWithPassphrase(key, []byte(cfg.KeyPassphrase))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to parse SSH private key with passphrase: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("failed to parse SSH private key: %w", err)
                }</span>
        }
        <span class="cov0" title="0">authMethods = append(authMethods, ssh.PublicKeys(signer))

        if cfg.Password != "" </span><span class="cov0" title="0">{
                authMethods = append(authMethods, ssh.Password(cfg.Password))
        }</span>

        <span class="cov0" title="0">if len(authMethods) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no authentication methods provided for server %s", cfg.Name)
        }</span>

        <span class="cov0" title="0">return authMethods, nil</span>
}
func getHostKeyCallback() (ssh.HostKeyCallback, error) <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user home directory: %w", err)
        }</span>

        <span class="cov0" title="0">knownHostsPath := filepath.Join(home, ".ssh", "known_hosts")
        hostKeyCallback, err := knownhosts.New(knownHostsPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create known hosts callback: %w", err)
        }</span>

        <span class="cov0" title="0">return hostKeyCallback, nil</span>
}

func (s *ServerStruct) BasicCaddySetup(ctx context.Context, serverName string, stream io.Writer) error <span class="cov0" title="0">{

        return nil

}</span>

// ExecuteCommand runs a command on the specified server with context support
// ExecuteCommand runs a command on the specified server with context support and streaming
func (s *ServerStruct) ExecuteCommand(ctx context.Context, serverName, command string, stream io.Writer) (string, error) <span class="cov0" title="0">{
        client, err := s.getSSHClient(serverName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">client.mu.Lock()
        defer client.mu.Unlock()

        session, err := client.Client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create session: %w", err)
        }</span>
        <span class="cov0" title="0">defer session.Close()

        // Set up output pipes
        stdoutPipe, err := session.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get stdout pipe: %w", err)
        }</span>

        <span class="cov0" title="0">stderrPipe, err := session.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get stderr pipe: %w", err)
        }</span>

        // Create a multi-writer to both capture output and stream it
        <span class="cov0" title="0">output := &amp;bytes.Buffer{}
        var writers []io.Writer

        if stream != nil </span><span class="cov0" title="0">{
                writers = append(writers, stream)
        }</span>
        <span class="cov0" title="0">writers = append(writers, output)

        multiWriter := io.MultiWriter(writers...)

        // Start command
        err = session.Start(command)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to start command: %w", err)
        }</span>

        // Stream output in goroutines
        <span class="cov0" title="0">var wg sync.WaitGroup
        wg.Add(2)

        go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                io.Copy(multiWriter, stdoutPipe)
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer wg.Done()
                io.Copy(multiWriter, stderrPipe)
        }</span>()

        // Set up context cancellation
        <span class="cov0" title="0">done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        session.Signal(ssh.SIGKILL)</span>
                case &lt;-done:<span class="cov0" title="0"></span>
                }
        }()

        // Wait for command completion
        <span class="cov0" title="0">err = session.Wait()
        close(done)
        wg.Wait()

        client.LastUsed = time.Now()

        if err != nil </span><span class="cov0" title="0">{
                return output.String(), fmt.Errorf("command failed: %w", err)
        }</span>

        <span class="cov0" title="0">serverlogger.Debug("Executed command on %s: %s", serverName, command)
        return output.String(), nil</span>
}

// UploadFile uploads a file to the remote server using SFTP
func (s *ServerStruct) UploadFile(ctx context.Context, serverName, localPath, remotePath string) error <span class="cov0" title="0">{
        client, err := s.getSSHClient(serverName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client.mu.Lock()
        defer client.mu.Unlock()

        localFile, err := os.Open(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        remoteFile, err := client.SFTPClient.Create(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create remote file: %w", err)
        }</span>
        <span class="cov0" title="0">defer remoteFile.Close()

        _, err = io.Copy(remoteFile, localFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">client.LastUsed = time.Now()
        serverlogger.Info("Uploaded %s to %s:%s", localPath, serverName, remotePath)
        return nil</span>
}

// DownloadFile downloads a file from the remote server using SFTP
func (s *ServerStruct) DownloadFile(ctx context.Context, serverName, remotePath, localPath string) error <span class="cov0" title="0">{
        client, err := s.getSSHClient(serverName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client.mu.Lock()
        defer client.mu.Unlock()

        remoteFile, err := client.SFTPClient.Open(remotePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open remote file: %w", err)
        }</span>
        <span class="cov0" title="0">defer remoteFile.Close()

        localFile, err := os.Create(localPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create local file: %w", err)
        }</span>
        <span class="cov0" title="0">defer localFile.Close()

        _, err = io.Copy(localFile, remoteFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>

        <span class="cov0" title="0">client.LastUsed = time.Now()
        serverlogger.Info("Downloaded %s:%s to %s", serverName, remotePath, localPath)
        return nil</span>
}

// PingServer checks if the server is reachable
func (s *ServerStruct) PingServer(serverName string) error <span class="cov0" title="0">{
        client, err := s.getSSHClient(serverName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">client.mu.Lock()
        defer client.mu.Unlock()

        session, err := client.Client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create session: %w", err)
        }</span>
        <span class="cov0" title="0">defer session.Close()

        _, err = session.CombinedOutput("echo ping")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ping failed: %w", err)
        }</span>

        <span class="cov0" title="0">client.LastUsed = time.Now()
        return nil</span>
}

// CloseSSHConnections closes all active SSH connections
func (s *ServerStruct) CloseSSHConnection() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        var errs []error
        for name, client := range s.sshClients </span><span class="cov0" title="0">{
                client.mu.Lock()
                if client.SFTPClient != nil </span><span class="cov0" title="0">{
                        if err := client.SFTPClient.Close(); err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, fmt.Errorf("error closing SFTP client for %s: %w", name, err))
                        }</span>
                }
                <span class="cov0" title="0">if err := client.Client.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("error closing SSH client for %s: %w", name, err))
                }</span>
                <span class="cov0" title="0">client.mu.Unlock()
                delete(s.sshClients, name)</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("errors while closing connections: %v", errs)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// getSSHClient safely retrieves an SSH client from the map
func (s *ServerStruct) getSSHClient(serverName string) (*SSHClient, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        client, ok := s.sshClients[serverName]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("server %s not found", serverName)
        }</span>
        <span class="cov0" title="0">return client, nil</span>
}

// Reconnect re-establishes connection to a server
func (s *ServerStruct) Reconnect(serverName string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.config == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration not loaded")
        }</span>

        <span class="cov0" title="0">var serverCfg *config.ServerConfig
        for _, cfg := range s.config.Servers </span><span class="cov0" title="0">{
                if cfg.Name == serverName </span><span class="cov0" title="0">{
                        serverCfg = &amp;cfg
                        break</span>
                }
        }

        <span class="cov0" title="0">if serverCfg == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server configuration not found for %s", serverName)
        }</span>

        // Close existing connection if it exists
        <span class="cov0" title="0">if oldClient, ok := s.sshClients[serverName]; ok </span><span class="cov0" title="0">{
                oldClient.mu.Lock()
                if oldClient.SFTPClient != nil </span><span class="cov0" title="0">{
                        oldClient.SFTPClient.Close()
                }</span>
                <span class="cov0" title="0">oldClient.Client.Close()
                oldClient.mu.Unlock()</span>
        }

        <span class="cov0" title="0">client, err := connectSSH(*serverCfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reconnect to %s: %w", serverName, err)
        }</span>

        <span class="cov0" title="0">s.sshClients[serverName] = client
        serverlogger.Info("Reconnected to server %s", serverName)
        return nil</span>
}

// ListServers returns a list of configured server names
func (s *ServerStruct) ListServers() []string <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var servers []string
        for name := range s.sshClients </span><span class="cov0" title="0">{
                servers = append(servers, name)
        }</span>
        <span class="cov0" title="0">return servers</span>
}

// GetServerStatus returns connection status of a server
func (s *ServerStruct) GetServerStatus(serverName string, stream io.Writer) (string, error) <span class="cov0" title="0">{
        client, err := s.getSSHClient(serverName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">client.mu.Lock()
        defer client.mu.Unlock()

        session, err := client.Client.NewSession()
        if err != nil </span><span class="cov0" title="0">{
                return "disconnected", nil
        }</span>
        <span class="cov0" title="0">session.Close()

        uptime, err := s.ExecuteCommand(context.Background(), serverName, "uptime", stream)
        if err != nil </span><span class="cov0" title="0">{
                return "connected but command failed", nil
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("connected (uptime: %s)", uptime), nil</span>
}

// PrepareServer installs required tools on the target server
// PrepareServer installs required tools on the target server with streaming output
// func (s *ServerStruct) PrepareServer(ctx context.Context, serverName string, stream io.Writer) error {
//         client, err := s.getSSHClient(serverName)
//         if err != nil {
//                 return fmt.Errorf("failed to get SSH client: %w", err)
//         }
//
//         client.mu.Lock()
//         defer client.mu.Unlock()
//
//         // Check if preparation is already done
//         if _, err := s.ExecuteCommand(ctx, serverName, "which docker &amp;&amp; which caddy &amp;&amp; which go", stream); err == nil {
//                 if stream != nil {
//                         fmt.Fprintf(stream, "Server already has required tools installed\n")
//                 }
//                 serverlogger.Info("Server already has required tools installed")
//                 return nil
//         }
//
//         if stream != nil {
//                 fmt.Fprintf(stream, "Preparing server %s by installing required tools...\n", serverName)
//         }
//         serverlogger.Info("Preparing server %s by installing required tools...", serverName)
//
//         // Determine package manager (apt/yum/dnf)
//         pkgManagerCmd := "command -v apt-get &gt;/dev/null &amp;&amp; echo apt || echo yum"
//         pkgManager, err := s.ExecuteCommand(ctx, serverName, pkgManagerCmd, stream)
//         if err != nil {
//                 return fmt.Errorf("failed to detect package manager: %w", err)
//         }
//
//         // Install base dependencies
//         baseDepsCmd := ""
//         switch strings.TrimSpace(pkgManager) {
//         case "apt":
//                 baseDepsCmd = `sudo apt-get update &amp;&amp;
//             sudo apt-get install -y curl git make gcc build-essential
//             ca-certificates software-properties-common apt-transport-https`
//         case "yum":
//                 baseDepsCmd = `sudo yum install -y curl git make gcc glibc-static
//             ca-certificates yum-utils device-mapper-persistent-data lvm2`
//         default:
//                 return fmt.Errorf("unsupported package manager: %s", pkgManager)
//         }
//
//         if _, err := s.ExecuteCommand(ctx, serverName, baseDepsCmd, stream); err != nil {
//                 return fmt.Errorf("failed to install base dependencies: %w", err)
//         }
//
//         // Install Docker
//         dockerInstallCmd := `curl -fsSL https://get.docker.com | sudo sh &amp;&amp;
//         sudo usermod -aG docker $USER &amp;&amp;
//         sudo systemctl enable docker &amp;&amp;
//         sudo systemctl start docker`
//
//         if _, err := s.ExecuteCommand(ctx, serverName, dockerInstallCmd, stream); err != nil {
//                 return fmt.Errorf("failed to install Docker: %w", err)
//         }
//
//         // Install Caddy
//         caddyInstallCmd := `sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https &amp;&amp;
//         curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg &amp;&amp;
//         curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list &amp;&amp;
//         sudo apt update &amp;&amp;
//         sudo apt install -y caddy`
//
//         if strings.TrimSpace(pkgManager) == "yum" {
//                 caddyInstallCmd = `sudo yum install -y yum-plugin-copr &amp;&amp;
//             sudo yum copr enable -y @caddy/caddy &amp;&amp;
//             sudo yum install -y caddy`
//         }
//
//         if _, err := s.ExecuteCommand(ctx, serverName, caddyInstallCmd, stream); err != nil {
//                 return fmt.Errorf("failed to install Caddy: %w", err)
//         }
//
//         // Install Go
//         goInstallCmd := `curl -OL https://golang.org/dl/go1.21.0.linux-amd64.tar.gz &amp;&amp;
//         sudo rm -rf /usr/local/go &amp;&amp;
//         sudo tar -C /usr/local -xzf go1.21.0.linux-amd64.tar.gz &amp;&amp;
//         echo 'export PATH=$PATH:/usr/local/go/bin' &gt;&gt; ~/.bashrc &amp;&amp;
//         source ~/.bashrc &amp;&amp;
//         rm go1.21.0.linux-amd64.tar.gz`
//
//         if _, err := s.ExecuteCommand(ctx, serverName, goInstallCmd, stream); err != nil {
//                 return fmt.Errorf("failed to install Go: %w", err)
//         }
//
//         // Verify installations
//         verifyCmd := `docker --version &amp;&amp; caddy version &amp;&amp; go version`
//         if _, err := s.ExecuteCommand(ctx, serverName, verifyCmd, stream); err != nil {
//                 return fmt.Errorf("verification failed: %w", err)
//         }
//
//         if stream != nil {
//                 fmt.Fprintf(stream, "Server preparation completed successfully\n")
//         }
//         serverlogger.Info("Server preparation completed successfully")
//         return nil
// }

func (s *ServerStruct) PrepareEcrCredentials(stream io.Writer) error <span class="cov0" title="0">{
        serverlogger.Info("Preparing ECR credentials")

        // Load environment variables
        store, err := envstore.New(
                envstore.WithEnvFile[string](".env"),
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create env store: %w", err)
        }</span>

        // Retrieve AWS credentials securely
        <span class="cov0" title="0">accessKey, err := store.GetEnv("AWS_ACCESS_KEY_ID")
        if err != nil </span><span class="cov0" title="0">{
                serverlogger.Error("Failed to get AWS_ACCESS_KEY_ID: %v", err)
                return fmt.Errorf("AWS_ACCESS_KEY_ID not found: %w", err)
        }</span>

        <span class="cov0" title="0">secretKey, err := store.GetEnv("AWS_SECRET_ACCESS_KEY")
        if err != nil </span><span class="cov0" title="0">{
                serverlogger.Error("Failed to get AWS_SECRET_ACCESS_KEY: %v", err)
                return fmt.Errorf("AWS_SECRET_ACCESS_KEY not found: %w", err)
        }</span>

        // Generate AWS credentials file content
        <span class="cov0" title="0">credentialsContent := fmt.Sprintf(`[default]
aws_access_key_id = %s
aws_secret_access_key = %s
`, accessKey, secretKey)

        // Write credentials securely to ~/.aws/credentials
        command := fmt.Sprintf(`
                mkdir -p ~/.aws &amp;&amp; \
                cat &gt; ~/.aws/credentials &lt;&lt;'EOF'
%sEOF
                chmod 600 ~/.aws/credentials
        `, credentialsContent)

        output, err := s.ExecuteCommand(
                context.Background(),
                "production", // Replace with actual server name
                command,
                stream, // Add stream parameter here
        )
        if err != nil </span><span class="cov0" title="0">{
                serverlogger.Error("Failed to write AWS credentials: %v (Output: %s)", err, output)
                return fmt.Errorf("failed to write credentials: %w", err)
        }</span>

        // Get repo details
        <span class="cov0" title="0">cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                serverlogger.Error("Failed to load configuration: %v", err)
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        <span class="cov0" title="0">image := cfg.Docker.Image
        if image == "" </span><span class="cov0" title="0">{
                serverlogger.Error("Docker image not specified in configuration")
                return fmt.Errorf("docker image not specified in configuration")
        }</span>

        <span class="cov0" title="0">accountID, region, reponame, err := registry.ExtractECRDetails(image)
        // log out repo details
        serverlogger.Debug("Extracted ECR details - Account ID: %s, Region: %s, Repository Name: %s", accountID, region, reponame)
        if err != nil </span><span class="cov0" title="0">{
                serverlogger.Error("Failed to extract ECR details from image %s: %v", image, err)
                return fmt.Errorf("failed to extract ECR details from image %s: %w", image, err)
        }</span>
        <span class="cov0" title="0">tag, err := git.GetCommitHash()
        if err != nil </span><span class="cov0" title="0">{
                serverlogger.Error("Failed to get commit hash: %v", err)
                return fmt.Errorf("failed to get commit hash: %w", err)
        }</span>
        <span class="cov0" title="0">if tag == "" </span><span class="cov0" title="0">{
                serverlogger.Error("No commit hash found, using 'latest' tag")
                tag = "latest"
        }</span>
        <span class="cov0" title="0">imagename := fmt.Sprintf("%s:%s", reponame, tag)
        serverlogger.Info("Using image: %s", imagename)

        ecrRegistry := fmt.Sprintf("%s.dkr.ecr.%s.amazonaws.com", accountID, region)
        pullCommand := fmt.Sprintf(`aws ecr get-login-password --region %s | docker login --username AWS --password-stdin %s`, region, ecrRegistry)
        if stream != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(stream, "üîë Executing ECR login command...\n")
        }</span>

        <span class="cov0" title="0">serverlogger.Debug("Pull command for ECR: %s", pullCommand)
        output, err = s.ExecuteCommand(
                context.Background(),
                "production", // Replace with actual server name
                pullCommand,
                stream,
        )
        if err != nil </span><span class="cov0" title="0">{
                serverlogger.Error("Failed to login to ECR: %v (Output: %s)", err, output)
                return fmt.Errorf("failed to login to ECR: %w", err)
        }</span>

        <span class="cov0" title="0">if stream != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(stream, "‚úÖ Successfully logged in to ECR\n")
        }</span>

        <span class="cov0" title="0">serverlogger.Info("Successfully prepared ECR credentials")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package ship

import (
        "context"
        "fmt"
        "io"
        "nextdeploy/cli/internal/server"
        "nextdeploy/shared"
        "nextdeploy/shared/registry"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"
)

const (
        bluePort  = "3001" // Blue container port
        greenPort = "3002" // Green container port
)

var (
        ShipLogs    = shared.PackageLogger("ship", "üö¢")
        forceDeploy bool
)

func VerifyServers(ctx context.Context, serverMgr *server.ServerStruct, servers []string, stream io.Writer) error <span class="cov0" title="0">{
        ShipLogs.Info("Verifying server connectivity and requirements...")

        var wg sync.WaitGroup
        errorChan := make(chan error, len(servers))

        for _, name := range servers </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(serverName string) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        serverCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
                        defer cancel()

                        ShipLogs.Info("  Checking server: %s\n", serverName)

                        if err := retryOperation(serverCtx, 3, 2*time.Second, func() error </span><span class="cov0" title="0">{
                                return serverMgr.PingServer(serverName)
                        }</span>); err != nil <span class="cov0" title="0">{
                                errorChan &lt;- fmt.Errorf("server %s is unreachable: %w", serverName, err)
                                return
                        }</span>

                        <span class="cov0" title="0">if _, err := serverMgr.ExecuteCommand(serverCtx, serverName, "docker --version", stream); err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- fmt.Errorf("Docker not available on %s: %w", serverName, err)
                                return
                        }</span>

                        <span class="cov0" title="0">output, err := serverMgr.ExecuteCommand(serverCtx, serverName, "df -h /", stream)
                        if err != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- fmt.Errorf("failed to check disk space on %s: %w", serverName, err)
                                return
                        }</span>
                        <span class="cov0" title="0">ShipLogs.Debug("[%s] Disk space:\n%s\n", serverName, output)</span>
                }(name)
        }

        <span class="cov0" title="0">wg.Wait()
        close(errorChan)

        var errors []error
        for err := range errorChan </span><span class="cov0" title="0">{
                errors = append(errors, err)
        }</span>

        <span class="cov0" title="0">if len(errors) &gt; 0 &amp;&amp; !forceDeploy </span><span class="cov0" title="0">{
                return fmt.Errorf("server verification failed: %v", errors)
        }</span> else<span class="cov0" title="0"> if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                ShipLogs.Info("Proceeding with deployment despite verification issues (force flag set)")
        }</span>

        <span class="cov0" title="0">ShipLogs.Success("‚úì All server checks completed")
        return nil</span>
}

func TransferRequiredFiles(ctx context.Context, serverMgr *server.ServerStruct, stream io.Writer, serverName string) error <span class="cov0" title="0">{
        ShipLogs.Info("Transferring required files to %s...", serverName)

        // Define files to transfer
        files := map[string]string{
                "nextdeploy.yml.enc": "nextdeploy.yml.enc",
                ".env.enc":           ".env.enc",
        }

        // Use a directory in the user's home folder
        homeDir, err := serverMgr.ExecuteCommand(ctx, serverName, "echo $HOME", stream)
        ShipLogs.Debug("User home directory on %s: %s\n", serverName, homeDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get user home directory: %w", err)
        }</span>
        <span class="cov0" title="0">homeDir = strings.TrimSpace(homeDir)
        baseDir := filepath.Join(homeDir, "app")

        var wg sync.WaitGroup
        errorChan := make(chan error, len(files)+2) // +2 for .nextdeploy and .next directories

        // Create base directory with proper permissions
        ShipLogs.Debug("Creating base directory: %s", baseDir)
        if _, err := serverMgr.ExecuteCommand(ctx, serverName,
                fmt.Sprintf("mkdir -p %s &amp;&amp; chmod 755 %s", baseDir, baseDir), stream); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create base directory %s: %w", baseDir, err)
        }</span>

        // Transfer individual files
        <span class="cov0" title="0">for localPath, remotePath := range files </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(local, remote string) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        fileCtx, cancel := context.WithTimeout(ctx, 2*time.Minute)
                        defer cancel()

                        // Verify local file exists first
                        if _, err := os.Stat(local); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                errorChan &lt;- fmt.Errorf("local file %s does not exist", local)
                                return
                        }</span>

                        <span class="cov0" title="0">ShipLogs.Debug("Transferring %s to %s:%s", local, serverName, remote)

                        // Create full remote path
                        fullRemotePath := filepath.Join(baseDir, remote)

                        // Ensure remote directory exists
                        remoteDir := filepath.Dir(fullRemotePath)
                        if remoteDir != baseDir </span><span class="cov0" title="0">{ // Skip if we're already in base dir
                                ShipLogs.Debug("Ensuring remote directory %s exists", remoteDir)
                                if _, err := serverMgr.ExecuteCommand(fileCtx, serverName,
                                        fmt.Sprintf("mkdir -p %s &amp;&amp; chmod 755 %s", remoteDir, remoteDir), stream); err != nil </span><span class="cov0" title="0">{
                                        errorChan &lt;- fmt.Errorf("failed to create remote directory %s: %w", remoteDir, err)
                                        return
                                }</span>
                        }

                        // Retry with exponential backoff
                        <span class="cov0" title="0">if err := retryOperation(fileCtx, 3, 5*time.Second, func() error </span><span class="cov0" title="0">{
                                return serverMgr.UploadFile(fileCtx, serverName, local, fullRemotePath)
                        }</span>); err != nil <span class="cov0" title="0">{
                                errorChan &lt;- fmt.Errorf("failed to upload %s: %w", local, err)
                                return
                        }</span>

                        <span class="cov0" title="0">ShipLogs.Info("Successfully transferred %s to %s", local, fullRemotePath)</span>
                }(localPath, remotePath)
        }

        // Transfer .nextdeploy directory
        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()

                fileCtx, cancel := context.WithTimeout(ctx, 5*time.Minute) // Longer timeout for directory transfer
                defer cancel()

                localNextDeployDir := ".nextdeploy"
                if _, err := os.Stat(localNextDeployDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        ShipLogs.Debug(".nextdeploy directory does not exist locally, skipping")
                        return
                }</span>

                <span class="cov0" title="0">remoteNextDeployDir := filepath.Join(baseDir, ".nextdeploy")
                ShipLogs.Info("Transferring %s directory to %s:%s", localNextDeployDir, serverName, remoteNextDeployDir)

                // Create remote directory
                if _, err := serverMgr.ExecuteCommand(fileCtx, serverName,
                        fmt.Sprintf("mkdir -p %s &amp;&amp; chmod 755 %s", remoteNextDeployDir, remoteNextDeployDir), stream); err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- fmt.Errorf("failed to create remote directory %s: %w", remoteNextDeployDir, err)
                        return
                }</span>

                // Upload all files in .nextdeploy directory
                <span class="cov0" title="0">err := filepath.Walk(localNextDeployDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                                return nil // Skip directories, we'll create them as needed
                        }</span>

                        <span class="cov0" title="0">relPath, err := filepath.Rel(localNextDeployDir, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">remoteFilePath := filepath.Join(remoteNextDeployDir, relPath)
                        remoteFileDir := filepath.Dir(remoteFilePath)

                        // Create subdirectory if needed
                        if remoteFileDir != remoteNextDeployDir </span><span class="cov0" title="0">{
                                if _, err := serverMgr.ExecuteCommand(fileCtx, serverName,
                                        fmt.Sprintf("mkdir -p %s &amp;&amp; chmod 755 %s", remoteFileDir, remoteFileDir), stream); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create remote directory %s: %w", remoteFileDir, err)
                                }</span>
                        }

                        // Upload file
                        <span class="cov0" title="0">if err := serverMgr.UploadFile(fileCtx, serverName, path, remoteFilePath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to upload %s: %w", path, err)
                        }</span>

                        // Set executable permissions if it's a script
                        <span class="cov0" title="0">if strings.HasSuffix(remoteFilePath, ".sh") </span><span class="cov0" title="0">{
                                if _, err := serverMgr.ExecuteCommand(fileCtx, serverName,
                                        fmt.Sprintf("chmod +x %s", remoteFilePath), stream); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to set executable permissions on %s: %w", remoteFilePath, err)
                                }</span>
                        }

                        <span class="cov0" title="0">ShipLogs.Debug("Transferred %s to %s", path, remoteFilePath)
                        return nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- fmt.Errorf("failed to upload .nextdeploy directory: %w", err)
                        return
                }</span>

                <span class="cov0" title="0">ShipLogs.Success("‚úì Successfully transferred .nextdeploy directory to %s", remoteNextDeployDir)</span>
        }()

        // Transfer keys directory
        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wg.Done()

                fileCtx, cancel := context.WithTimeout(ctx, 10*time.Minute) // Even longer timeout for .next directory
                defer cancel()

                homeDir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- fmt.Errorf("failed to get local user home directory: %w", err)
                        return
                }</span>
                <span class="cov0" title="0">localNextDir := filepath.Join(homeDir, ".nextdeploy")
                if _, err := os.Stat(localNextDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        ShipLogs.Debug(".next directory does not exist locally, skipping")
                        return
                }</span>

                <span class="cov0" title="0">remoteNextDir := filepath.Join(baseDir, ".nextdeploykeys")
                ShipLogs.Info("Transferring %s directory to %s:%s", localNextDir, serverName, remoteNextDir)

                // Create remote directory
                if _, err := serverMgr.ExecuteCommand(fileCtx, serverName,
                        fmt.Sprintf("mkdir -p %s &amp;&amp; chmod 755 %s", remoteNextDir, remoteNextDir), stream); err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- fmt.Errorf("failed to create remote directory %s: %w", remoteNextDir, err)
                        return
                }</span>

                // Upload all files in .next directory
                <span class="cov0" title="0">err = filepath.Walk(localNextDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                                return nil // Skip directories, we'll create them as needed
                        }</span>

                        <span class="cov0" title="0">relPath, err := filepath.Rel(localNextDir, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">remoteFilePath := filepath.Join(remoteNextDir, relPath)
                        remoteFileDir := filepath.Dir(remoteFilePath)

                        // Create subdirectory if needed
                        if remoteFileDir != remoteNextDir </span><span class="cov0" title="0">{
                                if _, err := serverMgr.ExecuteCommand(fileCtx, serverName,
                                        fmt.Sprintf("mkdir -p %s &amp;&amp; chmod 755 %s", remoteFileDir, remoteFileDir), stream); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create remote directory %s: %w", remoteFileDir, err)
                                }</span>
                        }

                        // Upload file
                        <span class="cov0" title="0">if err := serverMgr.UploadFile(fileCtx, serverName, path, remoteFilePath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to upload %s: %w", path, err)
                        }</span>

                        <span class="cov0" title="0">ShipLogs.Debug("Transferred %s to %s", path, remoteFilePath)
                        return nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- fmt.Errorf("failed to upload .nextdeploykeys directory: %w", err)
                        return
                }</span>

                <span class="cov0" title="0">ShipLogs.Success("‚úì Successfully transferred .nextdeploykeys directory to %s", remoteNextDir)</span>
        }()

        <span class="cov0" title="0">wg.Wait()
        close(errorChan)

        for err := range errorChan </span><span class="cov0" title="0">{
                if !forceDeploy </span><span class="cov0" title="0">{
                        return fmt.Errorf("file transfer failed: %w", err)
                }</span>
                <span class="cov0" title="0">ShipLogs.Warn("File transfer error (proceeding anyway): %v", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func DeployContainers(ctx context.Context, serverMgr *server.ServerStruct, serverName string, credentials bool, stream io.Writer) error <span class="cov0" title="0">{
        ShipLogs.Info("Deploying containers on %s...\n", serverName)

        // get git commits tags to swap containers  if not first time
        latestImage := registry.GetLatestImageName()
        ShipLogs.Debug("Latest image to deploy: %s", latestImage)
        // get current running container details
        // swap with latest container
        return nil
}</span>

func ExecuteSimpleCommand(ctx context.Context, serverMgr *server.ServerStruct, serverName string, command string, stream io.Writer) error <span class="cov0" title="0">{
        ShipLogs.Info("Executing command on %s: %s", serverName, command)

        cmdCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
        defer cancel()

        output, err := serverMgr.ExecuteCommand(cmdCtx, serverName, command, stream)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute command: %w", err)
        }</span>

        <span class="cov0" title="0">ShipLogs.Debug("Command output: %s", output)
        ShipLogs.Success("‚úì Command executed successfully")
        return nil</span>
}

func VerifyDeployment(ctx context.Context, serverMgr *server.ServerStruct, serverName string, stream io.Writer) error <span class="cov0" title="0">{
        ShipLogs.Info("Verifying deployment on %s...\n", serverName)

        ShipLogs.Success("‚úì Application health check passed")
        return nil
}</span>

func retryOperation(ctx context.Context, maxAttempts int, initialDelay time.Duration, fn func() error) error <span class="cov0" title="0">{
        var lastErr error

        for attempt := 1; attempt &lt;= maxAttempts; attempt++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        if lastErr != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("context canceled after %d attempts, last error: %w", attempt-1, lastErr)
                        }</span>
                        <span class="cov0" title="0">return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">err := fn()
                if err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">lastErr = err
                if attempt &lt; maxAttempts </span><span class="cov0" title="0">{
                        delay := time.Duration(attempt) * initialDelay
                        ShipLogs.Debug("    Attempt %d/%d failed, retrying in %v: %v\n",
                                attempt, maxAttempts, delay, err)

                        select </span>{
                        case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return fmt.Errorf("context canceled while waiting for retry: %w", lastErr)</span>
                        }
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("after %d attempts, last error: %w", maxAttempts, lastErr)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// NextDeploy CLI is a command-line interface for interacting with and managing
// Next.js app deployments across self-hosted infrastructure.
//
// It allows developers to initialize deployments, push code, monitor logs,
// and configure services using a simple declarative `nextdeploy.yml` file.
//
// Typical usage:
//   nextdeploy init        # Scaffold a Dockerfile and config
//   nextdeploy ship    # Build and deploy app to server
//
// Author: Yussuf Hersi &lt;dev@hersi.dev&gt;
// License: MIT
// Source: https://github.com/aynaash/nextdeploy
//
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Planned Features:
// - SSH key management with passphrase support
// - GitHub Webhook integration
// - Environment-specific overrides in `nextdeploy.yml`
// - Encrypted secrets store integration (e.g. Doppler, Vault)
// - Telemetry (opt-in)

package main

import (
        "nextdeploy/cli/cmd"
)

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "fmt"
        "log"
        "math"
        "net/http"
        "nextdeploy/shared/config"
        "os/exec"
        "strings"
        "time"
)

func SetupBlueGreenDeployment() error <span class="cov0" title="0">{
        // Decrypt files first
        DecryptFiles()
        cfg, err := ReadConfigInServer("/home/app/.nextdeploy.yml")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config: %w", err)
        }</span>

        // Determine current deployment color
        <span class="cov0" title="0">currentColor, err := detectCurrentDeploymentColor(cfg.App.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to detect current deployment: %w", err)
        }</span>

        <span class="cov0" title="0">newColor := getNextColor(currentColor)
        log.Printf("Current color: %s, New color: %s", currentColor, newColor)

        // Deploy new container
        if err := deployNewContainer(cfg, newColor); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deploy new container: %w", err)
        }</span>

        // Verify new container health
        <span class="cov0" title="0">if err := verifyContainerHealth(newColor, getPortForColor(newColor)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("new container failed health check: %w", err)
        }</span>

        // Update load balancer configuration
        <span class="cov0" title="0">if err := updateLoadBalancerConfig(cfg, newColor); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update load balancer: %w", err)
        }</span>

        // Clean up old deployment
        <span class="cov0" title="0">if currentColor != "" </span><span class="cov0" title="0">{
                if err := cleanupOldDeployment(cfg.App.Name, currentColor); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to clean up old deployment: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper functions for better modularity and testing
func detectCurrentDeploymentColor(appName string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("docker", "ps", "--format", "{{.Names}}", "--filter", fmt.Sprintf("name=%s", appName))
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to list containers: %w", err)
        }</span>

        <span class="cov0" title="0">containers := strings.Split(strings.TrimSpace(string(output)), "\n")
        for _, container := range containers </span><span class="cov0" title="0">{
                if strings.Contains(container, "blue") </span><span class="cov0" title="0">{
                        return "blue", nil
                }</span> else<span class="cov0" title="0"> if strings.Contains(container, "green") </span><span class="cov0" title="0">{
                        return "green", nil
                }</span>
        }
        <span class="cov0" title="0">return "", nil</span> // No current deployment
}

func getNextColor(currentColor string) string <span class="cov0" title="0">{
        if currentColor == "blue" </span><span class="cov0" title="0">{
                return "green"
        }</span>
        <span class="cov0" title="0">return "blue"</span>
}

func getPortForColor(color string) string <span class="cov0" title="0">{
        if color == "blue" </span><span class="cov0" title="0">{
                return "8080"
        }</span>
        <span class="cov0" title="0">return "8081"</span>
}

func getImageForColor(baseImage, color string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", baseImage, color)
}</span>

func deployNewContainer(cfg *config.NextDeployConfig, color string) error <span class="cov0" title="0">{
        containerName := fmt.Sprintf("%s-%s", cfg.App.Name, color)
        port := getPortForColor(color)
        image := getImageForColor(cfg.Docker.Image, color)

        cmd := exec.Command("docker", "run",
                "-d",
                "--name", containerName,
                "-p", fmt.Sprintf("%s:3000", port),
                "--health-cmd", "curl -f http://localhost:3000/health || exit 1",
                "--health-interval", "5s",
                "--health-timeout", "3s",
                "--health-retries", "3",
                image,
        )

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start container %s: %w", containerName, err)
        }</span>

        <span class="cov0" title="0">log.Printf("New container %s started on port %s", containerName, port)
        return nil</span>
}

func verifyContainerHealth(color, port string) error <span class="cov0" title="0">{
        healthURL := fmt.Sprintf("http://localhost:%s/health", port)

        // Retry with exponential backoff
        retries := 5
        for i := 0; i &lt; retries; i++ </span><span class="cov0" title="0">{
                resp, err := http.Get(healthURL)
                if err == nil &amp;&amp; resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        log.Printf("Container %s health check passed", color)
                        return nil
                }</span>

                <span class="cov0" title="0">if resp != nil </span><span class="cov0" title="0">{
                        resp.Body.Close()
                }</span>

                <span class="cov0" title="0">time.Sleep(time.Duration(math.Pow(2, float64(i))) * time.Second)</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("container %s failed health check after %d retries", color, retries)</span>
}

func updateLoadBalancerConfig(cfg *config.NextDeployConfig, newColor string) error <span class="cov0" title="0">{
        // Update Caddyfile or other load balancer configuration
        // This should be more sophisticated in production
        cmd := exec.Command("caddy", "reload", "--config", "/etc/caddy/Caddyfile")
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reload load balancer: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func cleanupOldDeployment(appName, oldColor string) error <span class="cov0" title="0">{
        containerName := fmt.Sprintf("%s-%s", appName, oldColor)

        // Stop container
        stopCmd := exec.Command("docker", "stop", containerName)
        if err := stopCmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop container %s: %w", containerName, err)
        }</span>

        // Remove container
        <span class="cov0" title="0">rmCmd := exec.Command("docker", "rm", containerName)
        if err := rmCmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove container %s: %w", containerName, err)
        }</span>

        <span class="cov0" title="0">log.Printf("Cleaned up old container: %s", containerName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
)

func SetupCaddyReverseProxy() error <span class="cov0" title="0">{
        caddyfilePath := "/etc/caddy/Caddyfile"
        caddyConfigFilePath := "~/app/.nextdeploy/caddy/Caddyfile"
        if _, err := os.Stat(caddyConfigFilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Printf("Caddy config file does not exist at path: %s\n", caddyConfigFilePath)
                return nil
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(caddyfilePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Printf("Caddyfile does not exist at path: %s\n", caddyfilePath)
                return nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to check Caddyfile: %v\n", err)
                return err
        }</span>
        // read config from caddyConfigFilePath and write to caddyfilePath
        <span class="cov0" title="0">data, err := os.ReadFile(caddyConfigFilePath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to read Caddy config file: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">err = os.WriteFile(caddyfilePath, data, 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to write Caddyfile: %v\n", err)
                return err
        }</span>
        // reload caddy with the new config

        <span class="cov0" title="0">cmd := exec.Command("caddy", "reload", "--config", caddyfilePath)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to reload Caddy configuration: %v\nOutput: %s\n", err, string(output))
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Caddy configuration reloaded successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package main

import (
        "fmt"
)

func (d *NextDeployDaemon) executeCommand(cmd Command) Response <span class="cov0" title="0">{
        switch cmd.Type </span>{
        case "swapcontainers":<span class="cov0" title="0">
                return d.swapContainers(cmd.Args)</span>
        case "listcontainers":<span class="cov0" title="0">
                return d.listContainers(cmd.Args)</span>
        case "deploy":<span class="cov0" title="0">
                return d.deployContainer(cmd.Args)</span>
        case "status":<span class="cov0" title="0">
                return d.getStatus()</span>
        case "restart":<span class="cov0" title="0">
                return d.restartContainer(cmd.Args)</span>
        case "logs":<span class="cov0" title="0">
                return d.getContainerLogs(cmd.Args)</span>
        case "stop":<span class="cov0" title="0">
                return d.stopContainer(cmd.Args)</span>
        case "start":<span class="cov0" title="0">
                return d.startContainer(cmd.Args)</span>
        case "remove":<span class="cov0" title="0">
                return d.removeContainer(cmd.Args)</span>
        case "pull":<span class="cov0" title="0">
                return d.pullImage(cmd.Args)</span>
        case "inspect":<span class="cov0" title="0">
                return d.inspectContainer(cmd.Args)</span>
        case "health":<span class="cov0" title="0">
                return d.healthCheck(cmd.Args)</span>
        case "rollback":<span class="cov0" title="0">
                return d.rollbackContainer(cmd.Args)</span>
        default:<span class="cov0" title="0">
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Unknown command: %s", cmd.Type),
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package main

import (
        "fmt"
        "gopkg.in/yaml.v3"
        "nextdeploy/shared/config"
        "os"
)

func ReadConfigInServer(path string) (*config.NextDeployConfig, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Config file not found: %w", err)
        }</span>
        <span class="cov0" title="0">var cfg config.NextDeployConfig
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Invalid config format: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package main

import (
        "fmt"
        "nextdeploy/shared/secrets"
        "os"
)

func DecryptFiles() <span class="cov0" title="0">{
        sm, err := secrets.NewSecretManager()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to initialize SecretManager:", err)
                return
        }</span>

        // Check if Doppler is enabled
        <span class="cov0" title="0">if sm.IsDopplerEnabled() </span><span class="cov0" title="0">{
                fmt.Println("Doppler is enabled, no need for this whole process...")
                return
        }</span>
        // Check if the key exists
        <span class="cov0" title="0">master, err := os.ReadFile("~/app/.nextdeploykeys/master.key")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to read encryption key:", err)
                return
        }</span>
        // Decrypt the nextdeploy.yml file
        <span class="cov0" title="0">nextdeployyml, err := sm.DecryptFile("nextdeploy.yml.enc", master)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to decrypt nextdeploy.yml:", err)
                return
        }</span>
        <span class="cov0" title="0">fmt.Println("Decrypted nextdeploy.yml content:\n", string(nextdeployyml))
        // Decrypt the .env file
        envfile, err := sm.DecryptFile(".env.enc", master)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to decrypt .env file:", err)
                return
        }</span>
        <span class="cov0" title="0">fmt.Println("Decrypted .env content:\n", string(envfile))
        // save the decrypted files
        err = os.WriteFile("nextdeploy.yml", []byte(nextdeployyml), 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to write decrypted nextdeploy.yml:", err)
                return
        }</span>
        <span class="cov0" title="0">err = os.WriteFile(".env", []byte(envfile), 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to write decrypted .env file:", err)
                return
        }</span>
        // Print success message
        <span class="cov0" title="0">fmt.Println("Files decrypted successfully!")
        fmt.Println("Using encryption key:", string(master))</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "os"
)

// BuildLock represents the structure of the build.lock file
type BuildLock struct {
        GitCommit    string `json:"git_commit"`
        GitDirty     bool   `json:"git_dirty"`
        GeneratedAt  string `json:"generated_at"`
        MetadataFile string `json:"metadata_file"`
}

// ReadBuildLock reads and parses the build.lock file
func ReadBuildLock(filePath string) (*BuildLock, error) <span class="cov0" title="0">{
        // Read the file content
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read build.lock file: %w", err)
        }</span>

        // Parse the JSON content
        <span class="cov0" title="0">var buildLock BuildLock
        err = json.Unmarshal(data, &amp;buildLock)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse build.lock JSON: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;buildLock, nil</span>
}

// GetGitCommit reads the build.lock file and returns the git commit hash
func GetGitCommit(filePath string) (string, error) <span class="cov0" title="0">{
        buildLock, err := ReadBuildLock(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return buildLock.GitCommit, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package main

import (
        "fmt"
        "log"
        "os"
        "path/filepath"
)

// Logger configuration
type LoggerConfig struct {
        LogDir      string
        LogFileName string
        MaxFileSize int64 // in bytes
        MaxBackups  int
}

// DefaultLogger creates a logger with default configuration
func DefaultLogger() *log.Logger <span class="cov0" title="0">{
        config := LoggerConfig{
                LogDir:      "/var/log/my-daemon",
                LogFileName: "daemon.log",
                MaxFileSize: 10 * 1024 * 1024, // 10MB
                MaxBackups:  5,
        }

        return SetupLogger(config)
}</span>

// SetupLogger creates and configures a logger
func SetupLogger(config LoggerConfig) *log.Logger <span class="cov0" title="0">{
        // Create log directory if it doesn't exist
        if err := os.MkdirAll(config.LogDir, 0755); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create log directory: %v", err)
        }</span>

        <span class="cov0" title="0">logPath := filepath.Join(config.LogDir, config.LogFileName)

        // Open log file (append mode, create if not exists)
        file, err := os.OpenFile(logPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to open log file: %v", err)
        }</span>

        // Create logger with timestamp and file/line information
        <span class="cov0" title="0">logger := log.New(file, "", log.LstdFlags|log.Lshortfile)

        return logger</span>
}

// RotateLog checks if log rotation is needed and performs it
func RotateLog(config LoggerConfig) error <span class="cov0" title="0">{
        logPath := filepath.Join(config.LogDir, config.LogFileName)

        // Check if file exists and its size
        info, err := os.Stat(logPath)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // No file to rotate
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat log file: %v", err)
        }</span>

        // Check if rotation is needed
        <span class="cov0" title="0">if info.Size() &lt; config.MaxFileSize </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Rotate logs
        <span class="cov0" title="0">for i := config.MaxBackups - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                oldLog := fmt.Sprintf("%s.%d", logPath, i)
                newLog := fmt.Sprintf("%s.%d", logPath, i+1)

                if _, err := os.Stat(oldLog); err == nil </span><span class="cov0" title="0">{
                        if i == config.MaxBackups-1 </span><span class="cov0" title="0">{
                                // Remove the oldest backup
                                os.Remove(oldLog)
                        }</span> else<span class="cov0" title="0"> {
                                os.Rename(oldLog, newLog)
                        }</span>
                }
        }

        // Rename current log to .0
        <span class="cov0" title="0">if err := os.Rename(logPath, logPath+".0"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rotate log: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LogMessage logs a message with rotation check
func LogMessage(logger *log.Logger, config LoggerConfig, level, message string) <span class="cov0" title="0">{
        // Check and perform log rotation if needed
        if err := RotateLog(config); err != nil </span><span class="cov0" title="0">{
                logger.Printf("ERROR: Log rotation failed: %v", err)
        }</span>

        // Log the message with timestamp and level
        <span class="cov0" title="0">logger.Printf("[%s] %s", level, message)</span>
}

// Simple logging functions
func LogInfo(logger *log.Logger, config LoggerConfig, message string) <span class="cov0" title="0">{
        LogMessage(logger, config, "INFO", message)
}</span>

func LogError(logger *log.Logger, config LoggerConfig, message string) <span class="cov0" title="0">{
        LogMessage(logger, config, "ERROR", message)
}</span>

func LogWarning(logger *log.Logger, config LoggerConfig, message string) <span class="cov0" title="0">{
        LogMessage(logger, config, "WARNING", message)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net"
        "os"
        "os/exec"
        "os/signal"
        "path/filepath"
        "strings"
        "syscall"
        "time"
)

var (
        logger      *log.Logger
        logFile     *os.File
        logFilePath string
        logConfig   LoggerConfig
)

func init() <span class="cov0" title="0">{
        fmt.Println("Initializing NextDeploy Daemon...")

        // default config
        logConfig = LoggerConfig{
                LogDir:      "/var/log/nextdeployd",
                LogFileName: "nextdeployd.log",
                MaxFileSize: 10 * 1024 * 1024, // 10 MB
                MaxBackups:  5,
        }
        // create log directory if not exists
        if err := os.MkdirAll(logConfig.LogDir, 0755); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create log directory: %v\n", err)
                os.Exit(1)
        }</span>
}

// init for file handling

func init() <span class="cov0" title="0">{
        logFilePath = filepath.Join(logConfig.LogDir, logConfig.LogFileName)
        // open log file(append mode, create if not exists)
        var err error
        logFile, err = os.OpenFile(logFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to open log file: %v\n", err)
                os.Exit(1)
        }</span>
        // create multi-writer for both file and std out
        <span class="cov0" title="0">multiWriter := io.MultiWriter(os.Stdout, logFile)

        // initialize logger with timestamp and file/line info
        logger = log.New(multiWriter, "NEXTDEPLOY: ", log.LstdFlags|log.Lshortfile)

        logger.Println("Logger initialized")</span>
}

// Command types that the daemon can handle
func NewNextDeployDaemon(configPath string) (*NextDeployDaemon, error) <span class="cov0" title="0">{
        config := &amp;DaemonConfig{
                SocketPath:      "/var/run/nextdeployd.sock",
                SocketMode:      "0660",
                DockerSocket:    "/var/run/docker.sock",
                ContainerPrefix: "nextdeploy-",
                LogLevel:        "info",
                LogDir:          "/var/log/nextdeployd", // Default
                LogMaxSize:      10,                     // Default 10MB
                LogMaxBackups:   5,                      // Default 5 backups

        }

        // Load config if exists
        if configPath != "" </span><span class="cov0" title="0">{
                if err := loadConfig(configPath, config); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Could not load config file: %v", err)
                }</span>
        }

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        return &amp;NextDeployDaemon{
                ctx:        ctx,
                cancel:     cancel,
                socketPath: config.SocketPath,
                config:     config,
        }, nil</span>
}

func (d *NextDeployDaemon) Start() error <span class="cov0" title="0">{
        // Check if we can access Docker
        if err := d.checkDockerAccess(); err != nil </span><span class="cov0" title="0">{
                LogError(logger, logConfig, "Docker access check failed")
                return fmt.Errorf("docker access check failed: %w", err)
        }</span>

        // Remove existing socket file if it exists
        <span class="cov0" title="0">os.Remove(d.socketPath)

        // Create Unix domain socket
        listener, err := net.Listen("unix", d.socketPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create socket: %w", err)
        }</span>
        <span class="cov0" title="0">d.listener = listener

        // Set socket permissions (only local access)
        if err := d.setSocketPermissions(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set socket permissions: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("NextDeploy daemon started, listening on %s", d.socketPath)
        log.Printf("Docker socket: %s", d.config.DockerSocket)

        // Start accepting connections
        go d.acceptConnections()

        // Handle signals
        sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP)

        for </span><span class="cov0" title="0">{
                select </span>{
                case sig := &lt;-sigCh:<span class="cov0" title="0">
                        switch sig </span>{
                        case syscall.SIGHUP:<span class="cov0" title="0">
                                log.Println("Received SIGHUP, reloading config...")</span>
                                // Reload config logic here
                        case syscall.SIGINT, syscall.SIGTERM:<span class="cov0" title="0">
                                log.Printf("Received signal: %v", sig)
                                d.Shutdown()
                                return nil</span>
                        }
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return nil</span>
                }
        }
}

func (d *NextDeployDaemon) checkDockerAccess() error <span class="cov0" title="0">{
        cmd := exec.Command("docker", "version")
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("docker not accessible: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (d *NextDeployDaemon) setSocketPermissions() error <span class="cov0" title="0">{
        // Set restrictive permissions - only root and specified users/groups
        if err := os.Chmod(d.socketPath, 0660); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the socket directory and ensure it's secure
        <span class="cov0" title="0">socketDir := filepath.Dir(d.socketPath)
        if err := os.Chmod(socketDir, 0755); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Could not set directory permissions: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Socket permissions set to 0660 on %s", d.socketPath)
        return nil</span>
}

func (d *NextDeployDaemon) acceptConnections() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                conn, err := d.listener.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-d.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                log.Printf("Error accepting connection: %v", err)
                                continue</span>
                        }
                }

                <span class="cov0" title="0">go d.handleConnection(conn)</span>
        }
}

func (d *NextDeployDaemon) handleConnection(conn net.Conn) <span class="cov0" title="0">{
        defer conn.Close()

        // Set connection timeout
        conn.SetDeadline(time.Now().Add(30 * time.Second))

        decoder := json.NewDecoder(conn)
        encoder := json.NewEncoder(conn)

        var cmd Command
        if err := decoder.Decode(&amp;cmd); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error decoding command: %v", err)
                return
        }</span>

        <span class="cov0" title="0">log.Printf("Received command: %s with args: %v", cmd.Type, cmd.Args)

        // Validate command
        if err := d.validateCommand(cmd); err != nil </span><span class="cov0" title="0">{
                response := Response{
                        Success: false,
                        Message: fmt.Sprintf("Command validation failed: %v", err),
                }
                encoder.Encode(response)
                return
        }</span>

        <span class="cov0" title="0">response := d.executeCommand(cmd)

        if err := encoder.Encode(response); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending response: %v", err)
        }</span>
}

func (d *NextDeployDaemon) validateCommand(cmd Command) error <span class="cov0" title="0">{
        // Basic command validation
        allowedCommands := []string{
                "swapcontainers", "listcontainers", "deploy", "status",
                "restart", "logs", "stop", "start", "remove", "pull",
                "inspect", "health", "rollback",
        }

        for _, allowed := range allowedCommands </span><span class="cov0" title="0">{
                if cmd.Type == allowed </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("command not allowed: %s", cmd.Type)</span>
}

// Docker command implementations
func (d *NextDeployDaemon) swapContainers(args map[string]interface{}) Response <span class="cov0" title="0">{
        fromContainer, ok1 := args["from"].(string)
        toContainer, ok2 := args["to"].(string)

        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: "swapcontainers requires 'from' and 'to' arguments",
                }
        }</span>

        <span class="cov0" title="0">log.Printf("Swapping containers: %s &lt;-&gt; %s", fromContainer, toContainer)

        // Get container details first
        fromInfo, err := d.getContainerInfo(fromContainer)
        if err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to get info for container %s: %v", fromContainer, err),
                }
        }</span>

        <span class="cov0" title="0">toInfo, err := d.getContainerInfo(toContainer)
        if err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to get info for container %s: %v", toContainer, err),
                }
        }</span>

        // Stop both containers
        <span class="cov0" title="0">if err := d.dockerCommand("stop", fromContainer); err != nil </span><span class="cov0" title="0">{
                return Response{Success: false, Message: fmt.Sprintf("Failed to stop %s: %v", fromContainer, err)}
        }</span>

        <span class="cov0" title="0">if err := d.dockerCommand("stop", toContainer); err != nil </span><span class="cov0" title="0">{
                return Response{Success: false, Message: fmt.Sprintf("Failed to stop %s: %v", toContainer, err)}
        }</span>

        // Rename containers (swap names)
        <span class="cov0" title="0">tempName := fromContainer + "-temp-" + fmt.Sprintf("%d", time.Now().Unix())

        if err := d.dockerCommand("rename", fromContainer, tempName); err != nil </span><span class="cov0" title="0">{
                return Response{Success: false, Message: fmt.Sprintf("Failed to rename %s: %v", fromContainer, err)}
        }</span>

        <span class="cov0" title="0">if err := d.dockerCommand("rename", toContainer, fromContainer); err != nil </span><span class="cov0" title="0">{
                return Response{Success: false, Message: fmt.Sprintf("Failed to rename %s: %v", toContainer, err)}
        }</span>

        <span class="cov0" title="0">if err := d.dockerCommand("rename", tempName, toContainer); err != nil </span><span class="cov0" title="0">{
                return Response{Success: false, Message: fmt.Sprintf("Failed to rename %s: %v", tempName, err)}
        }</span>

        // Start containers if they were running
        <span class="cov0" title="0">if fromInfo.Status == "running" </span><span class="cov0" title="0">{
                d.dockerCommand("start", toContainer)
        }</span>
        <span class="cov0" title="0">if toInfo.Status == "running" </span><span class="cov0" title="0">{
                d.dockerCommand("start", fromContainer)
        }</span>

        <span class="cov0" title="0">return Response{
                Success: true,
                Message: fmt.Sprintf("Successfully swapped containers %s and %s", fromContainer, toContainer),
        }</span>
}

func (d *NextDeployDaemon) listContainers(args map[string]interface{}) Response <span class="cov0" title="0">{
        showAll := false
        if all, ok := args["all"].(bool); ok </span><span class="cov0" title="0">{
                showAll = all
        }</span>

        <span class="cov0" title="0">var cmd *exec.Cmd
        if showAll </span><span class="cov0" title="0">{
                cmd = exec.Command("docker", "ps", "-a", "--format", "table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}\t{{.CreatedAt}}")
        }</span> else<span class="cov0" title="0"> {
                cmd = exec.Command("docker", "ps", "--format", "table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}\t{{.CreatedAt}}")
        }</span>

        <span class="cov0" title="0">output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to list containers: %v", err),
                }
        }</span>

        // Parse container info
        <span class="cov0" title="0">containers := d.parseContainerList(string(output))

        return Response{
                Success: true,
                Message: fmt.Sprintf("Found %d containers", len(containers)),
                Data:    containers,
        }</span>
}

func (d *NextDeployDaemon) deployContainer(args map[string]interface{}) Response <span class="cov0" title="0">{
        image, ok1 := args["image"].(string)
        if !ok1 </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: "deploy requires 'image' argument",
                }
        }</span>

        <span class="cov0" title="0">containerName, ok2 := args["name"].(string)
        if !ok2 </span><span class="cov0" title="0">{
                containerName = d.config.ContainerPrefix + strings.ReplaceAll(image, ":", "-")
        }</span>

        // Build docker run command
        <span class="cov0" title="0">dockerArgs := []string{"run", "-d", "--name", containerName}

        // Add ports if specified
        if ports, ok := args["ports"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, port := range ports </span><span class="cov0" title="0">{
                        if portStr, ok := port.(string); ok </span><span class="cov0" title="0">{
                                dockerArgs = append(dockerArgs, "-p", portStr)
                        }</span>
                }
        }

        // Add environment variables if specified
        <span class="cov0" title="0">if envVars, ok := args["env"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, env := range envVars </span><span class="cov0" title="0">{
                        if envStr, ok := env.(string); ok </span><span class="cov0" title="0">{
                                dockerArgs = append(dockerArgs, "-e", envStr)
                        }</span>
                }
        }

        // Add volumes if specified
        <span class="cov0" title="0">if volumes, ok := args["volumes"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, volume := range volumes </span><span class="cov0" title="0">{
                        if volStr, ok := volume.(string); ok </span><span class="cov0" title="0">{
                                dockerArgs = append(dockerArgs, "-v", volStr)
                        }</span>
                }
        }

        // Add restart policy
        <span class="cov0" title="0">restartPolicy := "unless-stopped"
        if restart, ok := args["restart"].(string); ok </span><span class="cov0" title="0">{
                restartPolicy = restart
        }</span>
        <span class="cov0" title="0">dockerArgs = append(dockerArgs, "--restart", restartPolicy)

        // Add the image
        dockerArgs = append(dockerArgs, image)

        // Add command if specified
        if command, ok := args["command"].(string); ok </span><span class="cov0" title="0">{
                dockerArgs = append(dockerArgs, strings.Fields(command)...)
        }</span>

        <span class="cov0" title="0">log.Printf("Deploying container with: docker %v", dockerArgs)

        cmd := exec.Command("docker", dockerArgs...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to deploy container: %v", err),
                }
        }</span>

        <span class="cov0" title="0">containerID := strings.TrimSpace(string(output))

        return Response{
                Success: true,
                Message: fmt.Sprintf("Successfully deployed container %s", containerName),
                Data: map[string]string{
                        "container_id":   containerID,
                        "container_name": containerName,
                        "image":          image,
                },
        }</span>
}

func (d *NextDeployDaemon) getStatus() Response <span class="cov0" title="0">{
        // Get Docker system info
        cmd := exec.Command("docker", "system", "df")
        output, _ := cmd.Output()

        // Get container counts
        runningCmd := exec.Command("docker", "ps", "-q")
        runningOutput, _ := runningCmd.Output()
        runningCount := len(strings.Split(strings.TrimSpace(string(runningOutput)), "\n"))
        if string(runningOutput) == "" </span><span class="cov0" title="0">{
                runningCount = 0
        }</span>

        <span class="cov0" title="0">allCmd := exec.Command("docker", "ps", "-aq")
        allOutput, _ := allCmd.Output()
        totalCount := len(strings.Split(strings.TrimSpace(string(allOutput)), "\n"))
        if string(allOutput) == "" </span><span class="cov0" title="0">{
                totalCount = 0
        }</span>

        <span class="cov0" title="0">status := map[string]interface{}{
                "daemon_status":      "healthy",
                "docker_accessible":  true,
                "containers_running": runningCount,
                "containers_total":   totalCount,
                "socket_path":        d.socketPath,
                "docker_system_info": strings.TrimSpace(string(output)),
        }

        return Response{
                Success: true,
                Message: "Daemon status retrieved",
                Data:    status,
        }</span>
}

func (d *NextDeployDaemon) restartContainer(args map[string]interface{}) Response <span class="cov0" title="0">{
        container, ok := args["container"].(string)
        if !ok </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: "restart requires 'container' argument",
                }
        }</span>

        <span class="cov0" title="0">if err := d.dockerCommand("restart", container); err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to restart container %s: %v", container, err),
                }
        }</span>

        <span class="cov0" title="0">return Response{
                Success: true,
                Message: fmt.Sprintf("Successfully restarted container: %s", container),
        }</span>
}

func (d *NextDeployDaemon) getContainerLogs(args map[string]interface{}) Response <span class="cov0" title="0">{
        container, ok1 := args["container"].(string)
        if !ok1 </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: "logs requires 'container' argument",
                }
        }</span>

        <span class="cov0" title="0">lines := "100" // default
        if linesArg, ok := args["lines"]; ok </span><span class="cov0" title="0">{
                lines = fmt.Sprintf("%v", linesArg)
        }</span>

        <span class="cov0" title="0">follow := false
        if followArg, ok := args["follow"].(bool); ok </span><span class="cov0" title="0">{
                follow = followArg
        }</span>

        <span class="cov0" title="0">dockerArgs := []string{"logs", "--tail", lines}
        if follow </span><span class="cov0" title="0">{
                dockerArgs = append(dockerArgs, "-f")
        }</span>
        <span class="cov0" title="0">dockerArgs = append(dockerArgs, container)

        cmd := exec.Command("docker", dockerArgs...)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to get logs for %s: %v", container, err),
                }
        }</span>

        <span class="cov0" title="0">logLines := strings.Split(strings.TrimSpace(string(output)), "\n")

        return Response{
                Success: true,
                Message: fmt.Sprintf("Retrieved %d log lines for %s", len(logLines), container),
                Data:    logLines,
        }</span>
}

func (d *NextDeployDaemon) stopContainer(args map[string]interface{}) Response <span class="cov0" title="0">{
        container, ok := args["container"].(string)
        if !ok </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: "stop requires 'container' argument",
                }
        }</span>

        <span class="cov0" title="0">if err := d.dockerCommand("stop", container); err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to stop container %s: %v", container, err),
                }
        }</span>

        <span class="cov0" title="0">return Response{
                Success: true,
                Message: fmt.Sprintf("Successfully stopped container: %s", container),
        }</span>
}

func (d *NextDeployDaemon) startContainer(args map[string]interface{}) Response <span class="cov0" title="0">{
        container, ok := args["container"].(string)
        if !ok </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: "start requires 'container' argument",
                }
        }</span>

        <span class="cov0" title="0">if err := d.dockerCommand("start", container); err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to start container %s: %v", container, err),
                }
        }</span>

        <span class="cov0" title="0">return Response{
                Success: true,
                Message: fmt.Sprintf("Successfully started container: %s", container),
        }</span>
}

func (d *NextDeployDaemon) removeContainer(args map[string]interface{}) Response <span class="cov0" title="0">{
        container, ok := args["container"].(string)
        if !ok </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: "remove requires 'container' argument",
                }
        }</span>

        <span class="cov0" title="0">force := false
        if forceArg, ok := args["force"].(bool); ok </span><span class="cov0" title="0">{
                force = forceArg
        }</span>

        <span class="cov0" title="0">dockerArgs := []string{"rm"}
        if force </span><span class="cov0" title="0">{
                dockerArgs = append(dockerArgs, "-f")
        }</span>
        <span class="cov0" title="0">dockerArgs = append(dockerArgs, container)

        cmd := exec.Command("docker", dockerArgs...)
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to remove container %s: %v", container, err),
                }
        }</span>

        <span class="cov0" title="0">return Response{
                Success: true,
                Message: fmt.Sprintf("Successfully removed container: %s", container),
        }</span>
}

func (d *NextDeployDaemon) pullImage(args map[string]interface{}) Response <span class="cov0" title="0">{
        image, ok := args["image"].(string)
        if !ok </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: "pull requires 'image' argument",
                }
        }</span>

        <span class="cov0" title="0">log.Printf("Pulling image: %s", image)

        // Handle authentication for registries if needed
        registry := GetRegistryType()
        if registry == "digitalocean" </span><span class="cov0" title="0">{
                err := HandleDigitalOceanRegistryAuth()
                if err != nil </span><span class="cov0" title="0">{
                        LogError(logger, logConfig, fmt.Sprintf("Registry auth failed: %v", err))
                        os.Exit(1)
                }</span>
        }
        // TODO: Add auth handling for other registries (ECR, GHCR, DockerHub) here
        <span class="cov0" title="0">return Response{
                Success: true,
                Message: fmt.Sprintf("Successfully pulled image: %s", image),
        }</span>
}

func (d *NextDeployDaemon) inspectContainer(args map[string]interface{}) Response <span class="cov0" title="0">{
        container, ok := args["container"].(string)
        if !ok </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: "inspect requires 'container' argument",
                }
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("docker", "inspect", container)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to inspect container %s: %v", container, err),
                }
        }</span>

        <span class="cov0" title="0">var inspectData interface{}
        if err := json.Unmarshal(output, &amp;inspectData); err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to parse inspect output: %v", err),
                }
        }</span>

        <span class="cov0" title="0">return Response{
                Success: true,
                Message: fmt.Sprintf("Container %s inspection data", container),
                Data:    inspectData,
        }</span>
}

func (d *NextDeployDaemon) healthCheck(args map[string]interface{}) Response <span class="cov0" title="0">{
        container, ok := args["container"].(string)
        if !ok </span><span class="cov0" title="0">{
                // System health check
                return d.getStatus()
        }</span>

        // Container health check
        <span class="cov0" title="0">cmd := exec.Command("docker", "inspect", "--format", "{{.State.Health.Status}}", container)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to check health for %s: %v", container, err),
                }
        }</span>

        <span class="cov0" title="0">healthStatus := strings.TrimSpace(string(output))
        healthy := healthStatus == "healthy" || healthStatus == "none"

        return Response{
                Success: healthy,
                Message: fmt.Sprintf("Container %s health status: %s", container, healthStatus),
                Data: map[string]interface{}{
                        "container":     container,
                        "health_status": healthStatus,
                        "healthy":       healthy,
                },
        }</span>
}

func (d *NextDeployDaemon) rollbackContainer(args map[string]interface{}) Response <span class="cov0" title="0">{
        container, ok1 := args["container"].(string)
        if !ok1 </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: "rollback requires 'container' argument",
                }
        }</span>

        // Look for previous version container
        <span class="cov0" title="0">previousContainer := container + "-previous"

        // Check if previous version exists
        cmd := exec.Command("docker", "ps", "-a", "--filter", "name="+previousContainer, "--format", "{{.Names}}")
        output, err := cmd.Output()
        if err != nil || strings.TrimSpace(string(output)) == "" </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("No previous version found for container %s", container),
                }
        }</span>

        // Stop current container
        <span class="cov0" title="0">d.dockerCommand("stop", container)

        // Rename current to backup
        backupName := container + "-backup-" + fmt.Sprintf("%d", time.Now().Unix())
        d.dockerCommand("rename", container, backupName)

        // Rename previous to current
        d.dockerCommand("rename", previousContainer, container)

        // Start the rolled back container
        if err := d.dockerCommand("start", container); err != nil </span><span class="cov0" title="0">{
                return Response{
                        Success: false,
                        Message: fmt.Sprintf("Failed to start rolled back container: %v", err),
                }
        }</span>

        <span class="cov0" title="0">return Response{
                Success: true,
                Message: fmt.Sprintf("Successfully rolled back container %s", container),
                Data: map[string]string{
                        "container":      container,
                        "backup_created": backupName,
                },
        }</span>
}

// Helper functions
func (d *NextDeployDaemon) dockerCommand(args ...string) error <span class="cov0" title="0">{
        cmd := exec.Command("docker", args...)
        return cmd.Run()
}</span>

func (d *NextDeployDaemon) getContainerInfo(containerName string) (*ContainerInfo, error) <span class="cov0" title="0">{
        cmd := exec.Command("docker", "inspect", "--format", "{{.State.Status}}", containerName)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ContainerInfo{
                Name:   containerName,
                Status: strings.TrimSpace(string(output)),
        }, nil</span>
}

func (d *NextDeployDaemon) parseContainerList(output string) []map[string]string <span class="cov0" title="0">{
        lines := strings.Split(strings.TrimSpace(output), "\n")
        var containers []map[string]string

        if len(lines) &lt;= 1 </span><span class="cov0" title="0">{ // Only header or empty
                return containers
        }</span>

        <span class="cov0" title="0">for _, line := range lines[1:] </span><span class="cov0" title="0">{ // Skip header
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fields := strings.Fields(line)
                if len(fields) &gt;= 6 </span><span class="cov0" title="0">{
                        containers = append(containers, map[string]string{
                                "id":      fields[0],
                                "name":    fields[1],
                                "image":   fields[2],
                                "status":  fields[3],
                                "ports":   fields[4],
                                "created": strings.Join(fields[5:], " "),
                        })
                }</span>
        }

        <span class="cov0" title="0">return containers</span>
}

func (d *NextDeployDaemon) Shutdown() <span class="cov0" title="0">{
        log.Println("Shutting down daemon...")
        d.cancel()

        if d.listener != nil </span><span class="cov0" title="0">{
                d.listener.Close()
        }</span>

        // Clean up socket file
        <span class="cov0" title="0">os.Remove(d.socketPath)
        log.Println("Daemon stopped")</span>
}

// Configuration loading
func loadConfig(configPath string, config *DaemonConfig) error <span class="cov0" title="0">{
        file, err := os.Open(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        decoder := json.NewDecoder(file)
        return decoder.Decode(config)</span>
}

// Client functions for sending commands
func sendCommand(socketPath string, cmd Command) (*Response, error) <span class="cov0" title="0">{
        conn, err := net.Dial("unix", socketPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to daemon: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // Set timeout
        conn.SetDeadline(time.Now().Add(30 * time.Second))

        encoder := json.NewEncoder(conn)
        decoder := json.NewDecoder(conn)

        // Send command
        if err := encoder.Encode(cmd); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send command: %w", err)
        }</span>

        // Receive response
        <span class="cov0" title="0">var response Response
        if err := decoder.Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to receive response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// Command-line interface
func main() <span class="cov0" title="0">{
        config := LoggerConfig{
                LogDir:      "/var/log/nextdeployd",
                LogFileName: "nextdeployd.log",
                MaxFileSize: 10 * 1024 * 1024, // 10 MB
                MaxBackups:  5,
        }
        logger := SetupLogger(config)
        LogInfo(logger, config, "Starting NextDeploy daemon...")
        socketPath := "/var/run/nextdeployd.sock"
        configPath := "/etc/nextdeployd/config.json"

        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("NextDeploy Daemon - Docker Container Management")
                fmt.Println("\nUsage:")
                fmt.Println("  Start daemon: nextdeployd daemon [--config=/path/to/config.json]")
                fmt.Println("\nContainer Commands:")
                fmt.Println("  nextdeployd listcontainers [--all=true]")
                fmt.Println("  nextdeployd deploy --image=nginx:latest --name=web-server --ports=80:8080")
                fmt.Println("  nextdeployd start --container=web-server")
                fmt.Println("  nextdeployd stop --container=web-server")
                fmt.Println("  nextdeployd restart --container=web-server")
                fmt.Println("  nextdeployd remove --container=web-server [--force=true]")
                fmt.Println("  nextdeployd logs --container=web-server [--lines=50]")
                fmt.Println("  nextdeployd inspect --container=web-server")
                fmt.Println("\nDeployment Commands:")
                fmt.Println("  nextdeployd swapcontainers --from=app-v1 --to=app-v2")
                fmt.Println("  nextdeployd rollback --container=web-server")
                fmt.Println("  nextdeployd pull --image=nginx:latest")
                fmt.Println("\nHealth &amp; Status:")
                fmt.Println("  nextdeployd status")
                fmt.Println("  nextdeployd health [--container=web-server]")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">command := os.Args[1]

        if command == "daemon" </span><span class="cov0" title="0">{
                // Check for config flag
                for _, arg := range os.Args[2:] </span><span class="cov0" title="0">{
                        if strings.HasPrefix(arg, "--config=") </span><span class="cov0" title="0">{
                                configPath = strings.TrimPrefix(arg, "--config=")
                                break</span>
                        }
                }

                // Run as daemon
                <span class="cov0" title="0">daemon, err := NewNextDeployDaemon(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to create daemon: %v", err)
                }</span>

                <span class="cov0" title="0">if err := daemon.Start(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Daemon failed: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Client mode - send command to running daemon
        <span class="cov0" title="0">var cmd Command
        args := make(map[string]interface{})

        // Parse command-line arguments
        for i := 2; i &lt; len(os.Args); i++ </span><span class="cov0" title="0">{
                arg := os.Args[i]
                if strings.HasPrefix(arg, "--") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(arg[2:], "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                // Try to parse as bool or number, otherwise keep as string
                                value := parts[1]
                                if value == "true" </span><span class="cov0" title="0">{
                                        args[parts[0]] = true
                                }</span> else<span class="cov0" title="0"> if value == "false" </span><span class="cov0" title="0">{
                                        args[parts[0]] = false
                                }</span> else<span class="cov0" title="0"> {
                                        args[parts[0]] = value
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">cmd.Type = command
        cmd.Args = args

        // Send command to daemon
        response, err := sendCommand(socketPath, cmd)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error: %v\n", err)

                // Check if daemon is running
                if strings.Contains(err.Error(), "connect") || strings.Contains(err.Error(), "no such file") </span><span class="cov0" title="0">{
                        fmt.Println("Hint: Is the daemon running? Start it with: nextdeployd daemon")
                        fmt.Printf("Socket path: %s\n", socketPath)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        // Display response
        <span class="cov0" title="0">if response.Success </span><span class="cov0" title="0">{
                fmt.Printf("‚úÖ %s\n", response.Message)
                if response.Data != nil </span><span class="cov0" title="0">{
                        switch data := response.Data.(type) </span>{
                        case []interface{}:<span class="cov0" title="0">
                                for _, item := range data </span><span class="cov0" title="0">{
                                        if itemMap, ok := item.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                // Format container list nicely
                                                for key, value := range itemMap </span><span class="cov0" title="0">{
                                                        fmt.Printf("  %s: %v\n", key, value)
                                                }</span>
                                                <span class="cov0" title="0">fmt.Println()</span>
                                        } else<span class="cov0" title="0"> {
                                                fmt.Printf("  %v\n", item)
                                        }</span>
                                }
                        case map[string]interface{}:<span class="cov0" title="0">
                                for key, value := range data </span><span class="cov0" title="0">{
                                        fmt.Printf("  %s: %v\n", key, value)
                                }</span>
                        case []map[string]string:<span class="cov0" title="0">
                                // Handle container list format
                                if len(data) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("\n%-12s %-20s %-30s %-15s %-20s\n", "ID", "NAME", "IMAGE", "STATUS", "PORTS")
                                        fmt.Println(strings.Repeat("-", 100))
                                        for _, container := range data </span><span class="cov0" title="0">{
                                                fmt.Printf("%-12s %-20s %-30s %-15s %-20s\n",
                                                        truncate(container["id"], 12),
                                                        truncate(container["name"], 20),
                                                        truncate(container["image"], 30),
                                                        container["status"],
                                                        truncate(container["ports"], 20))
                                        }</span>
                                }
                        case string:<span class="cov0" title="0">
                                fmt.Printf("  %s\n", data)</span>
                        default:<span class="cov0" title="0">
                                if jsonData, err := json.MarshalIndent(data, "  ", "  "); err == nil </span><span class="cov0" title="0">{
                                        fmt.Printf("  %s\n", string(jsonData))
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("  %v\n", data)
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                fmt.Printf("‚ùå %s\n", response.Message)
                os.Exit(1)
        }</span>
}

func truncate(s string, maxLen int) string <span class="cov0" title="0">{
        if len(s) &lt;= maxLen </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxLen-3] + "..."</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package main

import (
        "fmt"
        "nextdeploy/shared/envstore"
        "os"
        "os/exec"
        "strings"
)

func HandleDigitalOceanRegistryAuth() error <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get user home directory: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">envPath := home + "app/.env"
        _, err = os.Stat(envPath)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Printf(".env file does not exist at path: %s\n", envPath)
                return nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to check .env file: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">store, err := envstore.New(envstore.WithEnvFile[string](envPath))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to load .env file: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">token, _ := store.GetEnv("DIGITALOCEAN_TOKEN")
        // create the ~/.docker/config.json and save the token there
        file, err := os.OpenFile(os.Getenv("HOME")+"/.docker/config.json", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to open or create Docker config file: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        dockerConfig := fmt.Sprintf(`{
                        "auths": {
                                "registry.digitalocean.com": {
                                        "auth": "%s"
                                }
                        }
        }`, token)
        // write the token to the file
        _, err = file.WriteString(dockerConfig)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to write to Docker config file: %v\n", err)
        }</span>

        <span class="cov0" title="0">if token == "" </span><span class="cov0" title="0">{
                fmt.Println("DigitalOcean token is not set in .env file")
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("DigitalOcean token: %s\n", token)

        // read config file
        nextdeployPath := "~/app/nextdeploy.yml"
        cfg, err := ReadConfigInServer(nextdeployPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to read nextdeploy.yml file: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("NextDeploy config: %+v\n", cfg)
        // read the nextdeploy lock file
        filePath := "~/app/.nextdeploy/buil.lock"
        _, err = os.Stat(filePath)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to check build lock file: %v\n", err)
        }</span>
        <span class="cov0" title="0">commit, err := GetGitCommit(filePath) // parse the lock file content to get the image name and tag
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get git commit from build lock file: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("Git commit from build lock file: %s\n", commit)
        fullImage := fmt.Sprintf("%s:%s", cfg.Docker.Image, commit)

        fmt.Printf("Full Docker image to pull: %s\n", fullImage)
        // pull the image from digitalocean registry
        err = pullDockerImage(fullImage)
        return nil</span>

}

func GetRegistryType() string <span class="cov0" title="0">{
        nextdeployPath := "~/app/nextdeploy.yml"
        cfg, err := ReadConfigInServer(nextdeployPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to read nextdeploy.yml file: %v\n", err)
                return ""
        }</span>
        <span class="cov0" title="0">registry := cfg.Docker.Registry
        digitalocean := strings.Contains(registry, "digitalocean")
        if digitalocean </span><span class="cov0" title="0">{
                return "digitalocean"
        }</span>
        <span class="cov0" title="0">dockerhub := strings.Contains(registry, "docker.io")
        if dockerhub </span><span class="cov0" title="0">{
                return "dockerhub"
        }</span>
        <span class="cov0" title="0">ecr := strings.Contains(registry, "amazonaws")
        if ecr </span><span class="cov0" title="0">{
                return "ecr"
        }</span>
        <span class="cov0" title="0">ghr := strings.Contains(registry, "github")
        if ghr </span><span class="cov0" title="0">{
                return "ghcr"
        }</span>
        <span class="cov0" title="0">return ""</span>
}
func pullDockerImage(image string) error <span class="cov0" title="0">{
        cmd := exec.Command("docker", "pull", image)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to pull Docker image: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("Docker image pulled successfully: %s\n", image)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package shared

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "time"
)

// GenerateCommandID creates a unique ID for command tracking
func GenerateCommandID() string <span class="cov0" title="0">{
        b := make([]byte, 16) // 128-bit ID
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                // Fallback to timestamp-based ID if crypto fails
                return fmt.Sprintf("%x", time.Now().UnixNano())
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(b)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package caddy

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "time"
)

// CaddyManager provides simplified Caddy server configuration management
type CaddyManager struct {
        adminAPI string       // Caddy admin API endpoint (e.g., "http://localhost:2019")
        client   *http.Client // HTTP client for API requests
}

// New creates a new CaddyManager instance
func New(adminAPI string) *CaddyManager <span class="cov0" title="0">{
        return &amp;CaddyManager{
                adminAPI: strings.TrimSuffix(adminAPI, "/"),
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
        }
}</span>

// Config represents a Caddy configuration (can be either JSON or Caddyfile format)
type Config struct {
        Content string // The configuration content
        Format  string // "json" or "caddyfile"
}

// GetConfig retrieves the current Caddy configuration
func (cm *CaddyManager) GetConfig(ctx context.Context) (*Config, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", cm.adminAPI+"/config/", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := cm.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get config: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Config{
                Content: string(body),
                Format:  "json", // Caddy admin API always returns JSON
        }, nil</span>
}

// LoadConfig loads a configuration from a file
func (cm *CaddyManager) LoadConfig(ctx context.Context, filePath string) (*Config, error) <span class="cov0" title="0">{
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">format := "caddyfile"
        if strings.HasSuffix(filePath, ".json") </span><span class="cov0" title="0">{
                format = "json"
        }</span>

        <span class="cov0" title="0">return &amp;Config{
                Content: string(content),
                Format:  format,
        }, nil</span>
}

// SaveConfig saves the configuration to a file
func (cm *CaddyManager) SaveConfig(ctx context.Context, config *Config, filePath string) error <span class="cov0" title="0">{
        return os.WriteFile(filePath, []byte(config.Content), 0644)
}</span>

// ApplyConfig applies a new configuration to Caddy
func (cm *CaddyManager) ApplyConfig(ctx context.Context, config *Config) error <span class="cov0" title="0">{
        var (
                url  string
                body io.Reader
        )

        switch config.Format </span>{
        case "json":<span class="cov0" title="0">
                url = cm.adminAPI + "/config/"
                body = strings.NewReader(config.Content)</span>
        case "caddyfile":<span class="cov0" title="0">
                url = cm.adminAPI + "/load"
                body = strings.NewReader(config.Content)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported config format: %s", config.Format)</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", url, body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">if config.Format == "caddyfile" </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "text/caddyfile")
        }</span> else<span class="cov0" title="0"> {
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov0" title="0">resp, err := cm.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply config: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                errorBody, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to apply config (status %d): %s", resp.StatusCode, string(errorBody))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateConfig validates a configuration without applying it
func (cm *CaddyManager) ValidateConfig(ctx context.Context, config *Config) error <span class="cov0" title="0">{
        if config.Format != "caddyfile" </span><span class="cov0" title="0">{
                return fmt.Errorf("validation is only supported for caddyfile format")
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", cm.adminAPI+"/validate", strings.NewReader(config.Content))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "text/caddyfile")

        resp, err := cm.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate config: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                errorBody, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("config validation failed (status %d): %s", resp.StatusCode, string(errorBody))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfigAsCaddyfile retrieves the current config in Caddyfile format
func (cm *CaddyManager) GetConfigAsCaddyfile(ctx context.Context) (string, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "GET", cm.adminAPI+"/config/caddyfile", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := cm.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get caddyfile: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov0" title="0">return string(body), nil</span>
}

// PatchConfig applies a partial configuration update
func (cm *CaddyManager) PatchConfig(ctx context.Context, path string, config interface{}) error <span class="cov0" title="0">{
        jsonData, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "PATCH", cm.adminAPI+path, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := cm.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to patch config: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                errorBody, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to patch config (status %d): %s", resp.StatusCode, string(errorBody))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

//        func updatecaddyconfig(ctx context.context, servermgr *server.serverstruct, servername, domain, port string, stream io.writer) error {
//                const maxretries = 3
//                const retrydelay = 500 * time.millisecond
//
//                shiplogs.info("starting caddy config update",
//                        "domain", domain,
//                        "port", port,
//                        "server", servername)
//
//                // 1. verify caddy is running
//                shiplogs.debug("checking caddy availability")
//                if _, err := servermgr.executecommand(ctx, servername, "caddy -v", stream); err != nil {
//                        shiplogs.error("caddy not available", "error", err)
//                        return fmt.errorf("caddy container not found: %w", err)
//                }
//
//                // 2. get current config to modify
//                getconfigcmd := `curl -ss "http://localhost:2019/config/apps/http/servers/srv0"`
//                shiplogs.debug("fetching current caddy config")
//                currentconfig, err := servermgr.executecommand(ctx, servername, getconfigcmd, stream)
//                if err != nil {
//                        shiplogs.error("failed to get current config", "error", err)
//                        return fmt.errorf("failed to get current config: %w", err)
//                }
//
//                // 3. parse and modify config
//                var config struct {
//                        routes []map[string]interface{} `json:"routes"`
//                }
//                if err := json.unmarshal([]byte(currentconfig), &amp;config); err != nil {
//                        shiplogs.error("failed to parse config", "error", err)
//                        return fmt.errorf("failed to parse config: %w", err)
//                }
//
//                // remove existing route if it exists
//                ShipLogs.Debug("Removing existing route if present")
//                filteredRoutes := make([]map[string]interface{}, 0)
//                for _, route := range config.Routes {
//                        if route["match"] != nil {
//                                if matches, ok := route["match"].([]interface{}); ok {
//                                        for _, match := range matches {
//                                                if hostMatch, ok := match.(map[string]interface{}); ok {
//                                                        if hosts, ok := hostMatch["host"].([]interface{}); ok {
//                                                                for _, h := range hosts {
//                                                                        if h == domain {
//                                                                                continue // Skip this route
//                                                                        }
//                                                                }
//                                                        }
//                                                }
//                                        }
//                                }
//                        }
//                        filteredRoutes = append(filteredRoutes, route)
//                }
//
//                // Add new route
//                newRoute := map[string]interface{}{
//                        "match": []map[string]interface{}{
//                                {
//                                        "host": []string{domain},
//                                },
//                        },
//                        "handle": []map[string]interface{}{
//                                {
//                                        "handler": "reverse_proxy",
//                                        "upstreams": []map[string]interface{}{
//                                                {
//                                                        "dial": fmt.Sprintf("localhost:%s", port),
//                                                },
//                                        },
//                                },
//                        },
//                }
//                config.Routes = append(filteredRoutes, newRoute)
//
//                updatedConfig, err := json.Marshal(config)
//                if err != nil {
//                        ShipLogs.Error("Failed to marshal updated config", "error", err)
//                        return fmt.Errorf("failed to marshal config: %w", err)
//                }
//
//                // 4. Apply updated config
//                updateCmd := fmt.Sprintf(
//                        `curl -sS -X POST "http://localhost:2019/load" \
//                -H "Content-Type: application/json" \
//                -d '%s'`,
//                        strings.ReplaceAll(string(updatedConfig), "'", "'\\''"))
//
//                ShipLogs.Debug("Applying updated config", "config", string(updatedConfig))
//                if _, err := serverMgr.ExecuteCommand(ctx, serverName, updateCmd, stream); err != nil {
//                        ShipLogs.Error("Failed to update config", "error", err)
//                        return fmt.Errorf("failed to update config: %w", err)
//                }
//
//                // 5. Verify update
//                verifyCmd := `curl -sS "http://localhost:2019/config/apps/http/servers/srv0"`
//                for i := 0; i &lt; maxRetries; i++ {
//                        ShipLogs.Debug("Verifying config update", "attempt", i+1)
//                        verifyOutput, err := serverMgr.ExecuteCommand(ctx, serverName, verifyCmd, stream)
//                        if err == nil &amp;&amp; strings.Contains(verifyOutput, domain) {
//                                ShipLogs.Info("Caddy config updated successfully")
//                                return nil
//                        }
//                        time.Sleep(retryDelay)
//                }
//
//                ShipLogs.Error("Failed to verify config update")
//                return fmt.Errorf("failed to verify config update after %d attempts", maxRetries)
//        }
//        func UpdateCaddyConfig(ctx context.Context, serverMgr *server.ServerStruct, serverName, domain, port string, stream io.Writer) error {
//         const maxRetries = 3
//         const retryDelay = 500 * time.Millisecond
//
//         ShipLogs.Info("Starting Caddy config update (simulated)",
//                 "domain", domain,
//                 "port", port,
//                 "server", serverName)
//
//         // 1. Simulate Caddy availability check
//         ShipLogs.Debug("Simulating Caddy availability check")
//         if _, err := simulateCommand("caddy -v"); err != nil {
//                 ShipLogs.Error("Caddy not available (simulated)", "error", err)
//                 return fmt.Errorf("caddy container not found (simulated): %w", err)
//         }
//
//         // 2. Simulate getting current config
//         ShipLogs.Debug("Simulating fetching current Caddy config")
//         currentConfig := simulateCurrentConfig()
//
//         // 3. Parse and modify config (simulated)
//         var config struct {
//                 Routes []map[string]interface{} `json:"routes"`
//         }
//         if err := json.Unmarshal([]byte(currentConfig), &amp;config); err != nil {
//                 ShipLogs.Error("Failed to parse config (simulated)", "error", err)
//                 return fmt.Errorf("failed to parse config (simulated): %w", err)
//         }
//
//         // Simulate removing existing route
//         ShipLogs.Debug("Simulating removing existing route if present")
//         filteredRoutes := simulateRouteRemoval(config.Routes, domain)
//
//         // Simulate adding new route
//         newRoute := map[string]interface{}{
//                 "match": []map[string]interface{}{
//                         {
//                                 "host": []string{domain},
//                         },
//                 },
//                 "handle": []map[string]interface{}{
//                         {
//                                 "handler": "reverse_proxy",
//                                 "upstreams": []map[string]interface{}{
//                                         {
//                                                 "dial": fmt.Sprintf("localhost:%s", port),
//                                         },
//                                 },
//                         },
//                 },
//         }
//         config.Routes = append(filteredRoutes, newRoute)
//
//         updatedConfig, err := json.Marshal(config)
//         if err != nil {
//                 ShipLogs.Error("Failed to marshal updated config (simulated)", "error", err)
//                 return fmt.Errorf("failed to marshal config (simulated): %w", err)
//         }
//
//         // 4. Simulate applying updated config
//         ShipLogs.Debug("Simulating applying updated config", "config", string(updatedConfig))
//         if err := simulateConfigUpdate(string(updatedConfig)); err != nil {
//                 ShipLogs.Error("Failed to update config (simulated)", "error", err)
//                 return fmt.Errorf("failed to update config (simulated): %w", err)
//         }
//
//         // 5. Simulate verification
//         for i := 0; i &lt; maxRetries; i++ {
//                 ShipLogs.Debug("Simulating config update verification", "attempt", i+1)
//                 if simulateVerifyConfig(domain) {
//                         ShipLogs.Info("Caddy config updated successfully (simulated)")
//                         return nil
//                 }
//                 time.Sleep(retryDelay)
//         }
//
//         ShipLogs.Error("Failed to verify config update (simulated)")
//         return fmt.Errorf("failed to verify config update after %d attempts (simulated)", maxRetries)
// }
//
//
</pre>
		
		<pre class="file" id="file26" style="display: none">package config

import (
        "fmt"
        "strings"
)

func ShowConfigSummary(cfg *NextDeployConfig) <span class="cov0" title="0">{
        fmt.Println("\n" + strings.Repeat("=", 50))
        fmt.Println("üéâ Configuration Summary")
        fmt.Println(strings.Repeat("=", 50))

        fmt.Printf("\nüì± Application: %s\n", cfg.App.Name)
        fmt.Printf("üåê Port: %d | Env: %s\n", cfg.App.Port, cfg.App.Environment)
        if cfg.App.Domain != "" </span><span class="cov0" title="0">{
                fmt.Printf("üîó Domain: %s\n", cfg.App.Domain)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nüì¶ Repository: %s (%s)\n", cfg.Repository.URL, cfg.Repository.Branch)
        if cfg.Repository.AutoDeploy </span><span class="cov0" title="0">{
                fmt.Println("ü§ñ Auto-deploy: Enabled")
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nüê≥ Docker Image: %s\n", cfg.Docker.Image)
        fmt.Printf("üì¶ Build Context: %s\n", cfg.Docker.Build.Context)

        fmt.Printf("\nüöÄ Deployment Server: %s@%s\n", cfg.Deployment.Server.User, cfg.Deployment.Server.Host)
        fmt.Printf("üì¶ Container: %s (Restart: %s)\n", cfg.Deployment.Container.Name, cfg.Deployment.Container.Restart)

        if cfg.Database != nil </span><span class="cov0" title="0">{
                fmt.Printf("\nüíæ Database: %s@%s:%s\n", cfg.Database.Username, cfg.Database.Host, cfg.Database.Port)
        }</span>

        <span class="cov0" title="0">if cfg.Monitoring != nil </span><span class="cov0" title="0">{
                fmt.Printf("\nüëÄ Monitoring: %s (%s)\n", cfg.Monitoring.Type, cfg.Monitoring.Endpoint)
        }</span>

        <span class="cov0" title="0">fmt.Println("\n" + strings.Repeat("=", 50))</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// NOTE: cross compile safe
package config

import (
        "bufio"
        "nextdeploy/shared"
        "strconv"

        "github.com/spf13/cobra"
)

var (
        skipPrompts bool
)

func FirstNonEmpty(values ...string) string <span class="cov0" title="0">{
        for _, v := range values </span><span class="cov0" title="0">{
                if v != "" </span><span class="cov0" title="0">{
                        return v
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func HandleConfigSetup(cmd *cobra.Command, reader *bufio.Reader) error <span class="cov0" title="0">{
        defaultConfig := true
        plog := shared.PackageLogger("Init", "NextDeploy")

        if defaultConfig </span><span class="cov0" title="0">{
                err := GenerateSampleConfig()
                if err != nil </span><span class="cov0" title="0">{
                        plog.Error("failed to generate sample config: %v", err)
                        return nil
                }</span>
                <span class="cov0" title="0">plog.Success("‚úÖ nextdeploy.yml created")
                return nil</span>
        }

        // Handle interactive flow when not using default config
        <span class="cov0" title="0">if !skipPrompts &amp;&amp; PromptYesNo(reader, "Create customized nextdeploy.yml?") </span><span class="cov0" title="0">{
                cfg, err := InteractiveConfigPrompt(reader)
                //Print out the generated configuration
                if err != nil </span><span class="cov0" title="0">{
                        plog.Error("failed to get configuration: %v", err)
                        return nil
                }</span>

                <span class="cov0" title="0">plog.Debug("Generated configuration: %+v", cfg)

                // Safely handle Database configuration
                if cfg.Database != nil &amp;&amp; cfg.Database.Port != "" </span><span class="cov0" title="0">{
                        port, err := strconv.Atoi(cfg.Database.Port)
                        if err != nil </span><span class="cov0" title="0">{
                                plog.Warn("‚ö†Ô∏è Invalid port number: %s, using default 5432\n", cfg.Database.Port)
                                cfg.Database.Port = "5432"
                        }</span> else<span class="cov0" title="0"> if port &lt; 1 || port &gt; 65535 </span><span class="cov0" title="0">{
                                plog.Warn("‚ö†Ô∏è Port %d out of range, using default 5432\n", port)
                                cfg.Database.Port = "5432"
                        }</span>
                } else<span class="cov0" title="0"> if cfg.Database != nil </span><span class="cov0" title="0">{
                        // Initialize with default port if Database exists but port is empty
                        cfg.Database.Port = "5432"
                }</span>

                <span class="cov0" title="0">if err := WriteConfig("nextdeploy.yml", cfg); err != nil </span><span class="cov0" title="0">{
                        plog.Error("failed to write configuration: %v", err)
                        return nil
                }</span>
                <span class="cov0" title="0">plog.Success("‚úÖ nextdeploy.yml created with your settings")</span>

        } else<span class="cov0" title="0"> {
                // Only generate sample config if user refused to create customized one
                if PromptYesNo(reader, "Generate sample configuration file for reference?") </span><span class="cov0" title="0">{
                        if err := GenerateSampleConfig(); err != nil </span><span class="cov0" title="0">{
                                plog.Error("failed to generate sample config: %v", err)
                                return nil
                        }</span>
                        <span class="cov0" title="0">plog.Success("‚úÖ sample.nextdeploy.yml created")</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package config

import (
        "fmt"
        "gopkg.in/yaml.v3"
        "os"
)

func LoadConfig() (*NextDeployConfig, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(ConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s Config file not found: %w", EmojiWarning, err)
        }</span>

        <span class="cov0" title="0">var cfg NextDeployConfig
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s Invalid config format: %w", EmojiWarning, err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("%s Configuration loaded successfully\n", EmojiSuccess)
        return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "gopkg.in/yaml.v3"
        "os"
)

func Save(cfg *NextDeployConfig, path string) error <span class="cov0" title="0">{
        data, err := json.MarshalIndent(cfg, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}
func Load() (*NextDeployConfig, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(ConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s Config file not found: %w", EmojiWarning, err)
        }</span>

        <span class="cov0" title="0">var cfg NextDeployConfig
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s Invalid config format: %w", EmojiWarning, err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("%s Configuration loaded successfully\n", EmojiSuccess)
        return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package config

import (
        "bufio"
        "fmt"
        "gopkg.in/yaml.v3"
        "os"
        "strings"
)

// PromptForConfig collects user input for the nextdeploy configuration
func PromptForConfig(reader *bufio.Reader) (*NextDeployConfig, error) <span class="cov0" title="0">{
        cfg := &amp;NextDeployConfig{
                Version: "1.0",
                App: AppConfig{
                        Port: 3000,
                },
                Docker: DockerConfig{
                        Build: DockerBuild{
                                Context:    ".",
                                Dockerfile: "Dockerfile",
                                NoCache:    false,
                                Args:       map[string]string{"NODE_ENV": "production"},
                        },
                        Push: true,
                },
                Deployment: Deployment{
                        Container: Container{
                                Restart: "always",
                                Ports:   []string{"80:3000"},
                        },
                },
        }

        // Basic app configuration
        if err := PromptAppConfig(reader, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("app configuration error: %w", err)
        }</span>

        // Repository configuration
        <span class="cov0" title="0">if err := PromptRepositoryConfig(reader, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("repository configuration error: %w", err)
        }</span>

        // Docker configuration
        <span class="cov0" title="0">if err := PromptDockerConfig(reader, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("docker configuration error: %w", err)
        }</span>

        // Deployment configuration
        <span class="cov0" title="0">if err := PromptDeploymentConfig(reader, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("deployment configuration error: %w", err)
        }</span>

        // Optional configurations
        <span class="cov0" title="0">if PromptYesNo(reader, "Configure database?") </span><span class="cov0" title="0">{
                dbConfig, err := PromptDatabaseConfig(reader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("database configuration error: %w", err)
                }</span>
                <span class="cov0" title="0">cfg.Database = &amp;dbConfig</span>
        }

        <span class="cov0" title="0">if PromptYesNo(reader, "Configure monitoring?") </span><span class="cov0" title="0">{
                monConfig, err := PromptMonitoringConfig(reader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("monitoring configuration error: %w", err)
                }</span>
                <span class="cov0" title="0">cfg.Monitoring = &amp;monConfig</span>
        }

        <span class="cov0" title="0">return cfg, nil</span>
}

func PromptAppConfig(reader *bufio.Reader, cfg *NextDeployConfig) error <span class="cov0" title="0">{
        fmt.Print("Enter application name: ")
        name, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cfg.App.Name = name

        fmt.Print("Environment (production/staging): ")
        env, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cfg.App.Environment = env

        fmt.Print("Domain (leave empty if none): ")
        cfg.App.Domain, _ = reader.ReadString('\n')
        cfg.App.Domain = strings.TrimSpace(cfg.App.Domain)

        return nil</span>
}

func PromptRepositoryConfig(reader *bufio.Reader, cfg *NextDeployConfig) error <span class="cov0" title="0">{
        fmt.Print("Git repository URL (e.g., git@github.com:user/repo.git): ")
        url, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cfg.Repository.URL = url

        fmt.Print("Git branch (default: main): ")
        branch, _ := reader.ReadString('\n')
        branch = strings.TrimSpace(branch)
        if branch == "" </span><span class="cov0" title="0">{
                branch = "main"
        }</span>
        <span class="cov0" title="0">cfg.Repository.Branch = branch

        cfg.Repository.AutoDeploy = PromptYesNo(reader, "Enable auto-deploy?")

        if cfg.Repository.AutoDeploy </span><span class="cov0" title="0">{
                fmt.Print("Webhook secret (leave empty to generate): ")
                secret, _ := reader.ReadString('\n')
                cfg.Repository.WebhookSecret = strings.TrimSpace(secret)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func PromptDockerConfig(reader *bufio.Reader, cfg *NextDeployConfig) error <span class="cov0" title="0">{
        fmt.Print("Docker image name (e.g., username/app): ")
        image, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cfg.Docker.Image = image

        fmt.Print("Docker registry (leave empty for default): ")
        registry, _ := reader.ReadString('\n')
        cfg.Docker.Registry = strings.TrimSpace(registry)

        cfg.Docker.Build.NoCache = PromptYesNo(reader, "Build without cache?")

        return nil</span>
}

func PromptDeploymentConfig(reader *bufio.Reader, cfg *NextDeployConfig) error <span class="cov0" title="0">{
        fmt.Print("Deployment server host (IP or domain): ")
        host, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cfg.Deployment.Server.Host = host

        fmt.Print("Server SSH user: ")
        user, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cfg.Deployment.Server.User = user

        fmt.Print("SSH key path (~/.ssh/key): ")
        keyPath, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cfg.Deployment.Server.SSHKey = keyPath

        cfg.Deployment.Server.UseSudo = PromptYesNo(reader, "Require sudo for deployment?")

        fmt.Print("Container name: ")
        name, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">cfg.Deployment.Container.Name = name

        return nil</span>
}

func PromptDatabaseConfig(reader *bufio.Reader) (Database, error) <span class="cov0" title="0">{
        var db Database

        fmt.Print("Database type (mysql/postgres): ")
        dbType, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return db, err
        }</span>
        <span class="cov0" title="0">db.Type = dbType

        fmt.Print("Database host (leave empty for localhost): ")
        host, _ := reader.ReadString('\n')
        host = strings.TrimSpace(host)
        if host == "" </span><span class="cov0" title="0">{
                host = "localhost"
        }</span>
        <span class="cov0" title="0">db.Host = host

        fmt.Print("Database port: ")
        port, err := ReadRequiredInput(reader)
        fmt.Println(port)
        if err != nil </span><span class="cov0" title="0">{
                return db, err
        }</span>
        // Convert port to int (error handling omitted for brevity)
        // db.Port = portInt

        <span class="cov0" title="0">fmt.Print("Database username: ")
        username, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return db, err
        }</span>
        <span class="cov0" title="0">db.Username = username

        fmt.Print("Database password: ")
        password, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return db, err
        }</span>
        <span class="cov0" title="0">db.Password = password

        fmt.Print("Database name: ")
        name, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return db, err
        }</span>
        <span class="cov0" title="0">db.Name = name

        return db, nil</span>
}

func PromptMonitoringConfig(reader *bufio.Reader) (Monitoring, error) <span class="cov0" title="0">{
        var mon Monitoring

        mon.Enabled = true

        fmt.Print("Monitoring type (prometheus/grafana): ")
        monType, err := ReadRequiredInput(reader)
        if err != nil </span><span class="cov0" title="0">{
                return mon, err
        }</span>
        <span class="cov0" title="0">mon.Type = monType

        fmt.Print("Monitoring endpoint (leave empty for default): ")
        endpoint, _ := reader.ReadString('\n')
        endpoint = strings.TrimSpace(endpoint)
        if endpoint == "" </span><span class="cov0" title="0">{
                if mon.Type == "prometheus" </span><span class="cov0" title="0">{
                        endpoint = "http://localhost:9090"
                }</span> else<span class="cov0" title="0"> {
                        endpoint = "http://localhost:3000"
                }</span>
        }
        <span class="cov0" title="0">mon.Endpoint = endpoint

        return mon, nil</span>
}

func PromptYesNo(reader *bufio.Reader, question string) bool <span class="cov0" title="0">{
        fmt.Printf("%s (y/n): ", question)
        resp, _ := reader.ReadString('\n')
        resp = strings.TrimSpace(strings.ToLower(resp))
        return resp == "y" || resp == "yes"
}</span>

func ReadRequiredInput(reader *bufio.Reader) (string, error) <span class="cov0" title="0">{
        input, _ := reader.ReadString('\n')
        input = strings.TrimSpace(input)
        if input == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("this field is required")
        }</span>
        <span class="cov0" title="0">return input, nil</span>
}

// WriteConfig writes the configuration to a YAML file
func WriteConfig(filename string, cfg *NextDeployConfig) error <span class="cov0" title="0">{
        // Implementation using yaml.Marshal would go here
        data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>
        <span class="cov0" title="0">if err := os.WriteFile(filename, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Configuration saved to %s\n", filename)
        return nil</span>
}

func PromptForConfigs(reader *bufio.Reader) (*NextDeployConfig, error) <span class="cov0" title="0">{
        cfg := &amp;NextDeployConfig{
                Version: "1.0",
                App: AppConfig{
                        Port: 3000,
                },
                Docker: DockerConfig{
                        Build: DockerBuild{
                                Context:    ".",
                                Dockerfile: "Dockerfile",
                                NoCache:    false,
                                Args:       map[string]string{"NODE_ENV": "production"},
                        },
                        Push: true,
                },
                Deployment: Deployment{
                        Container: Container{
                                Restart: "always",
                                Ports:   []string{"80:3000"},
                        },
                },
        }

        // Basic app configuration
        if err := PromptAppConfig(reader, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("app configuration error: %w", err)
        }</span>

        // Repository configuration
        <span class="cov0" title="0">if err := PromptRepositoryConfig(reader, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("repository configuration error: %w", err)
        }</span>

        // Docker configuration
        <span class="cov0" title="0">if err := PromptDockerConfig(reader, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("docker configuration error: %w", err)
        }</span>

        // Deployment configuration
        <span class="cov0" title="0">if err := PromptDeploymentConfig(reader, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("deployment configuration error: %w", err)
        }</span>

        // Optional configurations
        <span class="cov0" title="0">if PromptYesNo(reader, "Configure database?") </span><span class="cov0" title="0">{
                dbConfig, err := PromptDatabaseConfig(reader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("database configuration error: %w", err)
                }</span>
                <span class="cov0" title="0">cfg.Database = &amp;dbConfig</span>
        }

        <span class="cov0" title="0">if PromptYesNo(reader, "Configure monitoring?") </span><span class="cov0" title="0">{
                monConfig, err := PromptMonitoringConfig(reader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("monitoring configuration error: %w", err)
                }</span>
                <span class="cov0" title="0">cfg.Monitoring = &amp;monConfig</span>
        }

        <span class="cov0" title="0">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package config

import (
        "bufio"
        "fmt"
        "nextdeploy/shared"
        "strconv"
        "strings"
)

var (
        dlog   = shared.PackageLogger("docker", "üßæ DOCKER")
        applog = shared.PackageLogger("app", "‚û§ APP")
        clog   = shared.PackageLogger("config", "üîß CONFIG")
)

func InteractiveConfigPrompt(reader *bufio.Reader) (*NextDeployConfig, error) <span class="cov0" title="0">{
        cfg := &amp;NextDeployConfig{
                Version: "1.0",
        }

        dlog.Info("\n‚ú® Welcome to NextDeploy Configuration Wizard ‚ú®")
        dlog.Info("This interactive guide will help you set up all the components needed to deploy your application.")
        dlog.Info("We'll walk through each section step by step with explanations along the way.")
        dlog.Info("You can press Enter to accept default values where available.\n")

        // App Configuration
        dlog.Info("\nüì± Application Settings")
        fmt.Println("----------------------")
        dlog.Info("These settings define your application's basic properties and runtime environment.")
        cfg.App = promptAppConfig(reader)

        // Repository Configuration
        dlog.Info("\nüì¶ Repository Settings")
        fmt.Println("----------------------")
        dlog.Info("Configure your source code repository for automatic deployments.")
        cfg.Repository = promptRepositoryConfig(reader)

        // Docker Configuration
        dlog.Info("\nüê≥ Docker Settings")
        fmt.Println("----------------------")
        dlog.Info("Define how your application should be containerized and built.")
        cfg.Docker = promptDockerConfig(reader)

        // Deployment Configuration
        dlog.Info("\nüöÄ Deployment Settings")
        fmt.Println("----------------------")
        dlog.Info("Specify where and how your application should be deployed.")
        cfg.Deployment = promptDeploymentConfig(reader)

        // Database Configuration
        if promptYesNo(reader, "Does your application use a database? (We'll configure PostgreSQL/MySQL/MongoDB connection)", false) </span><span class="cov0" title="0">{
                dlog.Info("\nüíæ Database Settings")
                fmt.Println("----------------------")
                dlog.Info("Configure connection details for your database server.")
                dbConfig := promptDatabaseConfig(reader)
                cfg.Database = &amp;dbConfig
        }</span>

        // Monitoring Configuration
        <span class="cov0" title="0">if promptYesNo(reader, "Would you like to set up monitoring for your application? (CPU, memory, health checks)", false) </span><span class="cov0" title="0">{
                dlog.Info("\nüëÄ Monitoring Settings")
                fmt.Println("----------------------")
                dlog.Info("Set up monitoring and alerting for your deployed application.")
                monitoringConfig := promptMonitoringConfig(reader)
                cfg.Monitoring = &amp;monitoringConfig
        }</span>

        <span class="cov0" title="0">fmt.Println("\n‚úÖ Configuration Complete!")
        ShowConfigSummary(cfg)

        if !promptYesNo(reader, "Does this configuration look correct? Would you like to save it?", true) </span><span class="cov0" title="0">{
                dlog.Info("Restarting configuration...")
                return InteractiveConfigPrompt(reader)
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

func promptAppConfig(reader *bufio.Reader) AppConfig <span class="cov0" title="0">{
        fmt.Printf("\n%s What's your application name? (e.g., 'my-web-app')\n", EmojiInput)
        dlog.Info("This will be used for container naming, logging, and service identification.")
        name := readRequiredInput(reader, "application name")

        fmt.Printf("\n%s Which port does your app run on internally? (default: 3000)\n", EmojiInput)
        dlog.Info("This is the port your application listens on inside the container.")
        portStr := readInputWithDefault(reader, "3000")
        port, _ := strconv.Atoi(portStr)

        fmt.Printf("\n%s What environment is this configuration for? (dev/stage/prod, default: prod)\n", EmojiInput)
        fmt.Println("This affects environment variables, logging levels, and deployment behavior.")
        env := readInputWithDefault(reader, "prod")

        fmt.Printf("\n%s Your production domain (e.g., 'nextdeploy.one', leave empty if none yet)\n", EmojiInput)
        fmt.Println("This will be used for SSL certificate generation and deployment routing.")
        domain, _ := reader.ReadString('\n')
        domain = strings.TrimSpace(domain)

        // email for ssl -setup
        fmt.Printf("\n%s Enter your email for SSL certificate setup (e.g., 'next@next.com')\n", EmojiInput)
        fmt.Println("This email is used for Let's Encrypt SSL certificate registration.")

        // Secrets configuration
        secrets := &amp;SecretsConfig{
                Provider: "doppler",
                Project:  "The name of your project",
                Config:   "prod",
                token:    "your-doppler-token",
        }

        return AppConfig{
                Name:        strings.TrimSpace(name),
                Port:        port,
                Environment: strings.ToLower(strings.TrimSpace(env)),
                Domain:      strings.TrimSpace(domain),
                Secrets:     secrets,
        }
}</span>

func promptRepositoryConfig(reader *bufio.Reader) Repository <span class="cov0" title="0">{
        fmt.Printf("\n%s Git repository URL (SSH or HTTPS):\n", EmojiInput)
        fmt.Println("Example SSH: git@github.com:yourname/your-repo.git")
        fmt.Println("Example HTTPS: https://github.com/yourname/your-repo.git")
        url := readRequiredInput(reader, "repository URL")

        fmt.Printf("\n%s Which branch should we deploy from? (default: main)\n", EmojiInput)
        branch := readInputWithDefault(reader, "main")

        autoDeploy := promptYesNo(reader, "\nWould you like to enable automatic deployments when code is pushed to this branch?", true)

        var webhookSecret string
        if autoDeploy </span><span class="cov0" title="0">{
                fmt.Printf("\n%s Webhook secret (leave empty to generate a secure one automatically)\n", EmojiImportant)
                fmt.Println("This secret verifies that deployment requests come from your repository.")
                webhookSecret, _ = reader.ReadString('\n')
        }</span>

        <span class="cov0" title="0">return Repository{
                URL:           strings.TrimSpace(url),
                Branch:        strings.TrimSpace(branch),
                AutoDeploy:    autoDeploy,
                WebhookSecret: strings.TrimSpace(webhookSecret),
        }</span>
}

func promptDockerConfig(reader *bufio.Reader) DockerConfig <span class="cov0" title="0">{
        fmt.Printf("\n%s Docker image name (e.g., 'username/my-app' or 'ghcr.io/username/my-app'):\n", EmojiContainer)
        fmt.Println("This will be used to tag and push your container image.")
        image := readRequiredInput(reader, "Docker image name")

        fmt.Printf("\n%s Docker registry (leave empty for Docker Hub, or specify like 'ghcr.io' for GitHub Container Registry)\n", EmojiContainer)
        registry, _ := reader.ReadString('\n')

        // Docker build settings
        fmt.Println("\nüî® Docker Build Settings")
        fmt.Printf("%s Build context path (default: current directory '.')\n", EmojiInput)
        fmt.Println("This is the directory containing your application code and Dockerfile.")
        context := readInputWithDefault(reader, ".")

        fmt.Printf("\n%s Dockerfile path (default: 'Dockerfile' in the build context)\n", EmojiInput)
        dockerfile := readInputWithDefault(reader, "Dockerfile")

        noCache := promptYesNo(reader, "\nShould we disable Docker build cache? (Slows builds but ensures fresh dependencies)", false)
        push := promptYesNo(reader, "Should we push the image to the registry after successful build?", true)

        // Build args
        args := make(map[string]string)
        if promptYesNo(reader, "\nWould you like to add any build arguments? (e.g., NODE_ENV=production)", false) </span><span class="cov0" title="0">{
                fmt.Println("\nEnter build arguments in KEY=VALUE format (one per line, empty to finish):")
                fmt.Println("Example: NODE_ENV=production")
                for </span><span class="cov0" title="0">{
                        fmt.Printf("%s Build argument: ", EmojiInput)
                        arg, _ := reader.ReadString('\n')
                        arg = strings.TrimSpace(arg)
                        if arg == "" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">parts := strings.SplitN(arg, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                args[parts[0]] = parts[1]
                                fmt.Printf("‚úì Added build arg: %s=%s\n", parts[0], parts[1])
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("%s Invalid format. Please use KEY=VALUE\n", EmojiWarning)
                        }</span>
                }
        }

        <span class="cov0" title="0">return DockerConfig{
                Image:    strings.TrimSpace(image),
                Registry: strings.TrimSpace(registry),
                Build: DockerBuild{
                        Context:    context,
                        Dockerfile: dockerfile,
                        NoCache:    noCache,
                        Args:       args,
                },
                Push: push,
        }</span>
}

func promptDeploymentConfig(reader *bufio.Reader) Deployment <span class="cov0" title="0">{
        fmt.Println("\nüñ•Ô∏è  Server Connection Details")
        fmt.Printf("%s Server hostname or IP address:\n", EmojiNetwork)
        fmt.Println("This is where your application will be deployed.")
        host := readRequiredInput(reader, "server host")

        fmt.Printf("\n%s SSH username for deployment:\n", EmojiNetwork)
        fmt.Println("This user should have permissions to deploy containers.")
        user := readRequiredInput(reader, "SSH username")

        fmt.Printf("\n%s Path to SSH private key:\n", EmojiNetwork)
        fmt.Println("Example: ~/.ssh/id_rsa or /home/user/.ssh/deploy_key")
        sshKey := readRequiredInput(reader, "SSH key path")

        useSudo := promptYesNo(reader, "\nDoes the deployment user require sudo for Docker commands?", false)

        fmt.Println("\nüì¶ Container Settings")
        fmt.Printf("%s Container name (default: app name):\n", EmojiContainer)
        name := readInputWithDefault(reader, "")

        fmt.Printf("\n%s Container restart policy (always/unless-stopped/no, default: always):\n", EmojiContainer)
        fmt.Println("'always' ensures your app restarts automatically if it crashes or the server reboots.")
        restart := readInputWithDefault(reader, "always")

        // Port mappings
        var ports []string
        fmt.Println("\nüåê Port Mappings")
        fmt.Println("Map server ports to container ports (e.g., '80:3000' to expose container port 3000 on server port 80)")
        fmt.Println("Enter one mapping per line, leave empty when done:")
        for </span><span class="cov0" title="0">{
                fmt.Printf("%s Port mapping (host:container): ", EmojiNetwork)
                port, _ := reader.ReadString('\n')
                port = strings.TrimSpace(port)
                if port == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if strings.Count(port, ":") != 1 </span><span class="cov0" title="0">{
                        fmt.Printf("%s Invalid format. Use HOST_PORT:CONTAINER_PORT (e.g., 80:3000)\n", EmojiWarning)
                        continue</span>
                }
                <span class="cov0" title="0">ports = append(ports, port)
                fmt.Printf("‚úì Added port mapping: %s\n", port)</span>
        }

        <span class="cov0" title="0">return Deployment{
                Server: Server{
                        Host:    strings.TrimSpace(host),
                        User:    strings.TrimSpace(user),
                        SSHKey:  strings.TrimSpace(sshKey),
                        UseSudo: useSudo,
                },
                Container: Container{
                        Name:    strings.TrimSpace(name),
                        Restart: strings.TrimSpace(restart),
                        Ports:   ports,
                },
        }</span>
}

func promptDatabaseConfig(reader *bufio.Reader) Database <span class="cov0" title="0">{
        fmt.Printf("\n%s Database type (postgres/mysql/mongodb):\n", EmojiDatabase)
        dbType := readRequiredInput(reader, "database type")

        fmt.Printf("\n%s Database server hostname or IP:\n", EmojiDatabase)
        host := readRequiredInput(reader, "database host")

        fmt.Printf("\n%s Database port (default based on type):\n", EmojiDatabase)
        defaultPort := "5432"
        if strings.ToLower(dbType) == "mysql" </span><span class="cov0" title="0">{
                defaultPort = "3306"
        }</span> else<span class="cov0" title="0"> if strings.ToLower(dbType) == "mongodb" </span><span class="cov0" title="0">{
                defaultPort = "27017"
        }</span>
        <span class="cov0" title="0">port := readInputWithDefault(reader, defaultPort)

        fmt.Printf("\n%s Database username:\n", EmojiDatabase)
        username := readRequiredInput(reader, "database username")

        fmt.Printf("\n%s Database password:\n", EmojiDatabase)
        password := readRequiredInput(reader, "database password")

        fmt.Printf("\n%s Database name:\n", EmojiDatabase)
        name := readRequiredInput(reader, "database name")

        return Database{
                Type:     strings.ToLower(strings.TrimSpace(dbType)),
                Host:     strings.TrimSpace(host),
                Port:     strings.TrimSpace(port),
                Username: strings.TrimSpace(username),
                Password: strings.TrimSpace(password),
                Name:     strings.TrimSpace(name),
        }</span>
}

func promptMonitoringConfig(reader *bufio.Reader) Monitoring <span class="cov0" title="0">{
        fmt.Printf("\n%s Monitoring system type (e.g., 'prometheus', 'datadog', 'newrelic'):\n", EmojiInput)
        fmt.Println("This should match the monitoring system you want to integrate with.")
        monType := readRequiredInput(reader, "monitoring type")

        fmt.Printf("\n%s Monitoring endpoint URL (if applicable):\n", EmojiInput)
        fmt.Println("For some systems, this might be an API endpoint or agent URL.")
        endpoint, _ := reader.ReadString('\n')

        return Monitoring{
                Enabled:  true,
                Type:     strings.TrimSpace(monType),
                Endpoint: strings.TrimSpace(endpoint),
        }
}</span>

// Helper function for required input
func readRequiredInput(reader *bufio.Reader, fieldName string) string <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                fmt.Printf("&gt; ")
                input, _ := reader.ReadString('\n')
                input = strings.TrimSpace(input)
                if input != "" </span><span class="cov0" title="0">{
                        return input
                }</span>
                <span class="cov0" title="0">fmt.Printf("%s %s is required. Please enter a value.\n", EmojiWarning, fieldName)</span>
        }
}

// Helper function for input with default
func readInputWithDefault(reader *bufio.Reader, defaultValue string) string <span class="cov0" title="0">{
        fmt.Printf("(default: %s) &gt; ", defaultValue)
        input, _ := reader.ReadString('\n')
        input = strings.TrimSpace(input)
        if input == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return input</span>
}

func promptYesNo(reader *bufio.Reader, question string, defaultYes bool) bool <span class="cov0" title="0">{
        options := "(y/N)"
        if defaultYes </span><span class="cov0" title="0">{
                options = "(Y/n)"
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                fmt.Printf("\n%s %s %s: ", EmojiQuestion, question, options)
                answer, _ := reader.ReadString('\n')
                answer = strings.TrimSpace(strings.ToLower(answer))

                if answer == "" </span><span class="cov0" title="0">{
                        return defaultYes
                }</span>
                <span class="cov0" title="0">if answer == "y" || answer == "yes" </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if answer == "n" || answer == "no" </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">fmt.Printf("%s Please answer with 'y' or 'n'\n", EmojiWarning)</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package config

import (
        "os"
        "path/filepath"
)

const sampleConfig = `
version: "1.0" # ‚ö†Ô∏è Do NOT change unless you change field meanings, format, or logic.

# ==================================================
# APP METADATA
# ==================================================
app:
  name: nextdeploy # Used for naming containers, logs, dashboards, etc.
  environment: production # One of: development | staging | production
  domain: https://www.nextdeploy.one # Public URL your app is accessible on
  port: 3000 # Internal port the app server listens on (not exposed directly)

# ==================================================
# GIT SOURCE CONFIGURATION
# ==================================================
repository:
  url: git@github.com:username/example-app.git # Must be accessible from deployer
  branch: main
  auto_deploy: true # Enable webhook-triggered CI/CD
  webhook_secret: your_webhook_secret # Used to verify webhook origin

# ==================================================
# CONTAINER BUILD &amp; REGISTRY CONFIG
# ==================================================
docker:
  build:
    context: . # Usually root of repo
    dockerfile: Dockerfile
    args:
      NODE_ENV: production
    no_cache: false # Force rebuilds (good for CI, bad for caching)
  image: hersiyussuf/nextdeploy
  registry: docker.io
  push: true
  username: hersiyussuf
  password: dckr_pat_H8xP4EPpj4_zKE91zKnInqXh010

# ==================================================
# INFRASTRUCTURE / SERVER TARGETS
# ==================================================
servers:
  - name: production # Unique ID (used for logs, filtering, routing)
    host: 51.20.134.163
    username: ubuntu
    ssh_key: ~/.ssh/nextdeploy-key.pem
    key_path: "/home/elitebook/.ssh/nextdeploy-key.pem"
    use_sudo: false

    container:
      name: nextdeploy
      restart: always
      env_file: .env
      volumes:
        - ./data:/app/data
      ports:
        - "80:3000"
      healthcheck:
        path: /api/health
        interval: 30s
        timeout: 5s
        retries: 3

# ‚úÖ Teaching:
# Move this out of docker because:
# 1. Docker is the build + push concern.
# 2. Servers are runtime infra concerns.
# 3. Daemons like ship, failover, and monitor depend on accurate server declarations.

# ==================================================
# DATABASE CONFIGURATION
# ==================================================
database:
  type: postgres
  host: 192.0.2.124
  port: 5432
  username: dbuser
  password: secret
  name: exampledb
  migrate_on_deploy: true

# Teaching:
# Database should be fully managed externally. Don‚Äôt run DB in the same container ‚Äî you want container failure to be isolated from data integrity.

# ==================================================
# LOGGING CONFIGURATION
# ==================================================
logging:
  enabled: true
  provider: nextdeploy # Could later support: syslog, logtail, datadog, etc.
  stream_logs: true
  log_path: /var/log/containers/nextdeploy.log

# ==================================================
# MONITORING &amp; ALERTING CONFIG
# ==================================================
monitoring:
  enabled: true
  cpu_threshold: 80
  memory_threshold: 75
  disk_threshold: 90
  alert:
    email: ops@example.com
    slack_webhook: https://hooks.slack.com/services/...
    notify_on:
      - crash
      - healthcheck_failed
      - high_cpu
      - high_memory

# Teaching:
# This will integrate with the monitor daemon. Future version: consider window_duration, cooldown_period, alert_frequency.

# ==================================================
# BACKUP CONFIGURATION
# ==================================================
backup:
  enabled: true
  frequency: daily
  retention_days: 7
  storage:
    provider: s3
    bucket: nextdeploy-backups
    region: us-east-1
    access_key: YOUR_ACCESS_KEY
    secret_key: YOUR_SECRET_KEY

# Teaching:g
# You're backing up volume and DB snapshots. Make sure you version them and don‚Äôt overwrite blindly.

# ==================================================
# SSL / HTTPS CONFIG
# ==================================================
domain: nextdeploy.one
email: yussufhersi219@gmail.com
staging: false
wildcard: true
dns_provider: namecheap
force: false
ssl:
  domain: nextdeploy.one
  email: yussufhersi219@gmail.com
  staging: false
  wildcard: true
  dns_provider: namecheap
  force: false
  enabled: true
  provider: letsencrypt
  auto_renew: true
# Teaching:
# When SSL is enabled, certbot or equivalent should be run on the server. Ideally daemonized + log-monitored.

# ==================================================
# POST-DEPLOY WEBHOOKS
# ==================================================
webhook:
  on_success:
    - curl -X POST https://your-api.com/deploy/success
  on_failure:
    - curl -X POST https://your-api.com/deploy/failure

# Teaching:
# Great for chaining environments. Success webhook ‚Üí notify QA or trigger end-to-end test suite.
deployment:
  server:
    host: 51.20.134.163 # Must match one of your servers' host
  container:
    name: nextdeploy
    restart: always
    ports:
      - "80:3000"
`

func GenerateSampleConfig() error <span class="cov0" title="0">{
        // Write the sample config to sample.nextdeploy.yml in the current directory
        path := filepath.Join(".", "nextdeploy.yml")
        return os.WriteFile(path, []byte(sampleConfig), 0644)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package config

import (
        "fmt"
        "os"

        "gopkg.in/yaml.v3"
)

// NextDeployConfig represents the complete deployment configuration
type NextDeployConfig struct {
        Version       string               `yaml:"version"`
        App           AppConfig            `yaml:"app"`
        Repository    Repository           `yaml:"repository"`
        Docker        DockerConfig         `yaml:"docker"`
        Deployment    Deployment           `yaml:"deployment"`
        Database      *Database            `yaml:"database,omitempty"`
        Monitoring    *Monitoring          `yaml:"monitoring,omitempty"`
        Secrets       SecretsConfig        `yaml:"secrets"`
        Logging       Logging              `yaml:"logging,omitempty"`
        Backup        *Backup              `yaml:"backup,omitempty"`
        SSL           *SSL                 `yaml:"ssl,omitempty"`
        Webhooks      []Webhook            `yaml:"webhooks,omitempty"`
        Environment   []EnvVariable        `yaml:"environment,omitempty"`
        Servers       []ServerConfig       `yaml:"servers"`
        SSLConfig     *SSLConfig           `yaml:"ssl_config,omitempty"`
        CloudProvider *CloudProviderStruct `yaml:"cloud_provider,omitempty"`
}

type WebServer struct {
        Type          string `yaml:"type"`
        ConfigPath    string `yaml:"config_path,omitempty"`
        SSL_Enabled   bool   `yaml:"ssl_enabled,omitempty"`
        SSL_Cert_Path string `yaml:"ssl_cert_path,omitempty"`
        SSL_Key_Path  string `yaml:"ssl_key_path,omitempty"`
}
type SSLConfig struct {
        Domain      string `yaml:"domain"`
        Email       string `yaml:"email"`
        Staging     bool   `yaml:"staging"`
        Wildcard    bool   `yaml:"wildcard"`
        DNSProvider string `yaml:"dns_provider"`
        Force       bool   `yaml:"force"`
        SSL         struct {
                Enabled   bool   `yaml:"enabled"`
                Provider  string `yaml:"provider"`
                Email     string `yaml:"email"`
                AutoRenew bool   `yaml:"auto_renew"`
        } `yaml:"ssl"`
}

type CloudProviderStruct struct {
        Name      string `yaml:"name"`
        Region    string `yaml:"region"`
        AccessKey string `yaml:"access_key,omitempty"`
        SecretKey string `yaml:"secret_key,omitempty"`
}
type ServerConfig struct {
        WebServer     *WebServer `yaml:"web_server,omitempty"`
        Name          string     `yaml:"name"`
        Host          string     `yaml:"host"`
        Port          int        `yaml:"port"`
        Username      string     `yaml:"username"`
        Password      string     `yaml:"password"`
        KeyPath       string     `yaml:"key_path"`
        SSHKey        string     `yaml:"ssh_key,omitempty"`
        KeyPassphrase string     `yaml:"key_passphrase,omitempty"`
}

// AppConfig contains application-specific settings
type AppConfig struct {
        Name        string         `yaml:"name"`
        Port        int            `yaml:"port"`
        Environment string         `yaml:"environment"`
        Domain      string         `yaml:"domain,omitempty"`
        Secrets     *SecretsConfig `yaml:"secrets,omitempty"`
}

// Repository contains source control configuration
type Repository struct {
        URL           string `yaml:"url"`
        Branch        string `yaml:"branch"`
        AutoDeploy    bool   `yaml:"autoDeploy"`
        WebhookSecret string `yaml:"webhookSecret,omitempty"`
}

// DockerConfig contains containerization settings
type DockerConfig struct {
        Image          string      `yaml:"image"`
        Registry       string      `yaml:"registry,omitempty"`
        RegistryRegion string      `yaml:"registryregion,omitempty"`
        Build          DockerBuild `yaml:"build"`
        Push           bool        `yaml:"push"`
        Username       string      `yaml:"username,omitempty"`
        Password       string      `yaml:"password,omitempty"`
        AlwaysPull     bool        `yaml:"alwaysPull,omitempty"`
        Strategy       string      `yaml:"strategy,omitempty"`
        AutoPush       bool        `yaml:"autoPush,omitempty"`
        Platform       string      `yaml:"platform,omitempty"`
        NoCache        bool        `yaml:"noCache,omitempty"`
        BuildContext   string      `yaml:"buildContext,omitempty"`
        Target         string      `yaml:"target,omitempty"`
}

// DockerBuild contains Docker build parameters
type DockerBuild struct {
        Context    string            `yaml:"context"`
        Dockerfile string            `yaml:"dockerfile"`
        NoCache    bool              `yaml:"noCache"`
        Args       map[string]string `yaml:"args,omitempty"`
}

// Deployment contains infrastructure deployment settings
type Deployment struct {
        Server    Server    `yaml:"server"`
        Container Container `yaml:"container"`
}

// Server contains target server connection details
type Server struct {
        Host    string `yaml:"host"`
        User    string `yaml:"user"`
        SSHKey  string `yaml:"sshKey,omitempty"`
        UseSudo bool   `yaml:"useSudo"`
}

// Container contains runtime configuration
type Container struct {
        Name        string       `yaml:"name"`
        Restart     string       `yaml:"restart"`
        Ports       []string     `yaml:"ports"`
        HealthCheck *HealthCheck `yaml:"healthCheck,omitempty"`
}

// HealthCheck defines container health monitoring
type HealthCheck struct {
        Test     []string `yaml:"test,omitempty"`
        Interval string   `yaml:"interval,omitempty"`
        Timeout  string   `yaml:"timeout,omitempty"`
        Retries  int      `yaml:"retries,omitempty"`
}

// Database contains persistence layer configuration
type Database struct {
        Type     string `yaml:"type"`
        Host     string `yaml:"host"`
        Port     string `yaml:"port"`
        Username string `yaml:"username"`
        Password string `yaml:"password"`
        Name     string `yaml:"name"`
}

// Monitoring contains observability settings
type Monitoring struct {
        Enabled  bool   `yaml:"enabled"`
        Type     string `yaml:"type"`
        Endpoint string `yaml:"endpoint"`
        Alerts   Alerts `yaml:"alerts,omitempty"`
}

// Alerts defines monitoring notification rules
type Alerts struct {
        CPUThreshold    int    `yaml:"cpuThreshold"`
        MemoryThreshold int    `yaml:"memoryThreshold"`
        Email           string `yaml:"email,omitempty"`
        SlackWebhook    string `yaml:"slackWebhook,omitempty"`
}

// SecretsConfig defines secret management
type SecretsConfig struct {
        Provider string         `yaml:"provider"`
        Doppler  *DopplerConfig `yaml:"doppler,omitempty"`
        Vault    *VaultConfig   `yaml:"vault,omitempty"`
        Files    []SecretFile   `yaml:"files,omitempty"`
        Project  string         `yaml:"project,omitempty"`
        Config   string         `yaml:"config,omitempty"`
        token    string         `yaml:"token,omitempty"`
}

// DopplerConfig contains Doppler-specific settings
type DopplerConfig struct {
        Project string `yaml:"project"`
        Config  string `yaml:"config"`
        Token   string `yaml:"token,omitempty"`
}

// VaultConfig contains HashiCorp Vault settings
type VaultConfig struct {
        Address string `yaml:"address"`
        Token   string `yaml:"token"`
        Path    string `yaml:"path"`
}

// SecretFile defines file-based secrets
type SecretFile struct {
        Path   string `yaml:"path"`
        Secret string `yaml:"secret"`
}

// Logging contains log management configuration
type Logging struct {
        Driver  string            `yaml:"driver"`
        Options map[string]string `yaml:"options,omitempty"`
}

// Backup defines data backup policies
type Backup struct {
        Enabled   bool    `yaml:"enabled"`
        Schedule  string  `yaml:"schedule"`
        Retention int     `yaml:"retentionDays"`
        Storage   Storage `yaml:"storage"`
}

// Storage contains backup storage details
type Storage struct {
        Type      string `yaml:"type"`
        Endpoint  string `yaml:"endpoint,omitempty"`
        Bucket    string `yaml:"bucket"`
        AccessKey string `yaml:"accessKey,omitempty"`
        SecretKey string `yaml:"secretKey,omitempty"`
}

// SSL contains certificate management
type SSL struct {
        Enabled     bool     `yaml:"enabled"`
        Provider    string   `yaml:"provider"`
        Domains     []string `yaml:"domains"`
        Email       string   `yaml:"email"`
        Wildcard    bool     `yaml:"wildcard"`
        DNSProvider string   `yaml:"dns_provider"`
        Staging     bool     `yaml:"staging"`
        Force       bool     `yaml:"force"`
        AutoRenew   bool     `yaml:"auto_renew"`
        Domain      string   `yaml:"domain,omitempty"`
}

// Webhook defines deployment webhooks
type Webhook struct {
        Name   string   `yaml:"name"`
        URL    string   `yaml:"url"`
        Events []string `yaml:"events"`
        Secret string   `yaml:"secret,omitempty"`
}

// EnvVariable contains environment variables
type EnvVariable struct {
        Name   string `yaml:"name"`
        Value  string `yaml:"value"`
        Secret bool   `yaml:"secret,omitempty"`
}

// SaveConfig writes the configuration to a file
func SaveConfig(path string, cfg *NextDeployConfig) error <span class="cov0" title="0">{
        data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(path, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">//go:build !windows
// +build !windows

package shared

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/ecdh"
        "crypto/ecdsa"
        "crypto/ed25519"
        "crypto/rand"
        "crypto/sha256"
        "encoding/asn1"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "math/big"
        "os"
        "runtime"
        "syscall"
        "unsafe"
)

const (
        KeyIDLength       = 32
        NonceSize         = 12
        SignatureSize     = ed25519.SignatureSize // 64 bytes for Ed25519 signature
        PublicKeySize     = 32
        PrivateKeySize    = 32
        SharedKeySize     = 32
        FingerprintLength = 16
)

type ECCSignature struct {
        R *big.Int
        S *big.Int
}

var (
        SharedLogger = PackageLogger("shared", "üîó SHARED")
)

type KeyPair struct {
        ECDHPrivate *ecdh.PrivateKey
        ECDHPublic  *ecdh.PublicKey
        SignPrivate ed25519.PrivateKey
        SignPublic  ed25519.PublicKey
        ECDSAKey    *ecdsa.PrivateKey // Optional ECDSA key for compatibility
        KeyID       string
}

// Generate key pair create a new ecdh (x25519) key pair and a new ed25519 signing key pair.
func SignMessage(msg AgentMessage, privateKey *ecdsa.PrivateKey) (AgentMessage, error) <span class="cov0" title="0">{
        // Create copy without signature
        msgToSign := msg
        msgToSign.Signature = ""

        jsonData, err := json.Marshal(msgToSign)
        if err != nil </span><span class="cov0" title="0">{
                return AgentMessage{}, err
        }</span>

        <span class="cov0" title="0">hash := sha256.Sum256(jsonData)
        r, s, err := ecdsa.Sign(rand.Reader, privateKey, hash[:])
        if err != nil </span><span class="cov0" title="0">{
                return AgentMessage{}, err
        }</span>

        <span class="cov0" title="0">signature, err := asn1.Marshal(ECCSignature{R: r, S: s})
        if err != nil </span><span class="cov0" title="0">{
                return AgentMessage{}, err
        }</span>

        <span class="cov0" title="0">msg.Signature = string(signature)
        return msg, nil</span>
}

func VerifyMessageSignature(msg AgentMessage) bool <span class="cov0" title="0">{
        if msg.Signature == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Get public key from agent store (would need implementation)
        <span class="cov0" title="0">publicKey := getAgentPublicKey(msg.AgentID)
        if publicKey == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Create copy without signature
        <span class="cov0" title="0">msgToVerify := msg
        msgToVerify.Signature = ""

        jsonData, err := json.Marshal(msgToVerify)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">hash := sha256.Sum256(jsonData)

        var sig ECCSignature
        if _, err := asn1.Unmarshal([]byte(msg.Signature), &amp;sig); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return ecdsa.Verify(publicKey, hash[:], sig.R, sig.S)</span>
}

func SecureKeyMemory(key []byte) <span class="cov0" title="0">{
        // Use platform-specific secure memory functions
        if len(key) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // For Linux/Unix:
        <span class="cov0" title="0">if _, _, err := syscall.Syscall(syscall.SYS_MLOCK, uintptr(unsafe.Pointer(&amp;key[0])), uintptr(len(key)), 0); err != 0 </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to lock memory: %v", err)
        }</span>
}

// ZeroKey securely wipes keys from memory
func ZeroKey(key []byte) <span class="cov0" title="0">{
        if len(key) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Use constant-time zeroing
        <span class="cov0" title="0">for i := range key </span><span class="cov0" title="0">{
                key[i] = 0
        }</span>

        // Ensure compiler doesn't optimize this away
        <span class="cov0" title="0">runtime.KeepAlive(key)

        // For Linux/Unix:
        if _, _, err := syscall.Syscall(syscall.SYS_MUNLOCK, uintptr(unsafe.Pointer(&amp;key[0])), uintptr(len(key)), 0); err != 0 </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to unlock memory: %v", err)
        }</span>
}

func GenerateKeyPair() (*KeyPair, error) <span class="cov0" title="0">{
        curve := ecdh.X25519()
        // generate ECDH key pair
        ecdhPrivate, err := curve.GenerateKey(rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Failed to generate ECDH key pair: %v", err)
                return nil, fmt.Errorf("failed to generate ECDH key pair: %w", err)
        }</span>
        <span class="cov0" title="0">ecdhPublic := ecdhPrivate.PublicKey()
        if ecdhPublic == nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Failed to get ECDH public key:%v", err)
                return nil, errors.New("failed to get ECDH public key")
        }</span>
        // generate ramdom key ID
        <span class="cov0" title="0">KeyID := make([]byte, KeyIDLength)
        if _, err := io.ReadFull(rand.Reader, KeyID); err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Failed to generate random KeyID: %v", err)
                return nil, fmt.Errorf("failed to generate random KeyID: %w", err)
        }</span>
        // generate Ed25519 key pair
        <span class="cov0" title="0">signPublic, signPrivate, err := ed25519.GenerateKey(rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Failed to generate Ed25519 key pair: %v", err)
                return nil, fmt.Errorf("failed to generate Ed25519 keyManager pair: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;KeyPair{
                ECDHPrivate: ecdhPrivate,
                ECDHPublic:  ecdhPublic,
                SignPrivate: signPrivate,
                SignPublic:  signPublic,
                KeyID:       hex.EncodeToString(KeyID),
        }, nil</span>

}
func RunCryptoHealthChecks() error <span class="cov0" title="0">{
        // TODO:Test ECDH key exchange
        return nil
}</span>

func getAgentPublicKey(agentID string) *ecdsa.PublicKey <span class="cov0" title="0">{
        // Placeholder function to retrieve the public key of an agent by its ID.
        // In a real implementation, this would query a database or a key store.
        // For now, we return nil to indicate that the public key is not found.
        SharedLogger.Warn("getAgentPublicKey is not implemented, returning nil")
        return nil
}</span>

// DeriveSharedKey derives a shared key from the ECDH private key and the public key of the peer.

func DeriveSharedKey(privateKey *ecdh.PrivateKey, publicKey *ecdh.PublicKey) ([]byte, error) <span class="cov0" title="0">{
        if privateKey == nil || publicKey == nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Private key or public key is nil")
                return nil, errors.New("private key or public key is nil")
        }</span>
        <span class="cov0" title="0">sharedKey, err := privateKey.ECDH(publicKey)
        if err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Failed to derive shared key: %v", err)
                return nil, fmt.Errorf("failed to derive shared key: %w", err)
        }</span>
        // hash the shared key to ensure it is of fixed size
        <span class="cov0" title="0">hashedKey := sha256.Sum256(sharedKey)
        return hashedKey[:SharedKeySize], nil</span>
}

// EncryptData encrypts data using AES-GCM with the provided key and returns the ciphertext and nonce.
// TODO: consolidate with existing encryption methods in the project

func Encrypt(data []byte, key []byte) ([]byte, []byte, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Failed to create AES cipher: %v", err)
                return nil, nil, fmt.Errorf("failed to create AES cipher: %w", err)
        }</span>
        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Failed to create GCM: %v", err)
                return nil, nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>
        <span class="cov0" title="0">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Failed to generate nonce: %v", err)
                return nil, nil, fmt.Errorf("failed to generate nonce: %w", err)
        }</span>
        <span class="cov0" title="0">ciphertext := gcm.Seal(nil, nonce, data, nil)
        return ciphertext, nonce, nil</span>
}

func Decrypt(cipherText []byte, key []byte, nonce []byte) ([]byte, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("failed to create AES cipher: %v", err)
                return nil, fmt.Errorf("failed to create AES cipher: %w", err)
        }</span>
        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("failed to create GCM: %v", err)
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>
        <span class="cov0" title="0">plaintext, err := gcm.Open(nil, nonce, cipherText, nil)
        if err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("failed to decrypt data: %v", err)
                return nil, fmt.Errorf("failed to decrypt data: %w", err)
        }</span>
        <span class="cov0" title="0">return plaintext, nil</span>
}

// SignData signs the data using the Ed25519 private key and returns the signature.
func Sign(data []byte, privateKey ed25519.PrivateKey) ([]byte, error) <span class="cov0" title="0">{
        if len(privateKey) != PrivateKeySize </span><span class="cov0" title="0">{
                SharedLogger.Error("Invalid private key size: expected %d, got %d", PrivateKeySize, len(privateKey))
                return nil, fmt.Errorf("invalid private key size: expected %d, got %d", PrivateKeySize, len(privateKey))
        }</span>
        <span class="cov0" title="0">signature := ed25519.Sign(privateKey, data)
        if len(signature) != SignatureSize </span><span class="cov0" title="0">{
                SharedLogger.Error("Invalid signature size: expected %d, got %d", SignatureSize, len(signature))
                return nil, fmt.Errorf("invalid signature size: expected %d, got %d", SignatureSize, len(signature))
        }</span>
        <span class="cov0" title="0">SharedLogger.Info("Data signed successfully")
        return signature, nil</span>
}

// Verify verifies the signature of the data using the public key.
func Verify(data []byte, signature []byte, publicKey ed25519.PublicKey) (bool, error) <span class="cov0" title="0">{

        if len(publicKey) != ed25519.PrivateKeySize </span><span class="cov0" title="0">{
                SharedLogger.Error("Invalid public key size: expected %d, got %d", ed25519.PrivateKeySize, len(publicKey))
                return false, fmt.Errorf("invalid public key size: expected %d, got %d", ed25519.PrivateKeySize, len(publicKey))
        }</span>
        <span class="cov0" title="0">if len(signature) != SignatureSize </span><span class="cov0" title="0">{
                SharedLogger.Error("Invalid signature size: expected %d, got %d", SignatureSize, len(signature))
                return false, fmt.Errorf("invalid signature size: expected %d, got %d", SignatureSize, len(signature))
        }</span>
        <span class="cov0" title="0">valid := ed25519.Verify(publicKey, data, signature)
        if !valid </span><span class="cov0" title="0">{
                SharedLogger.Error("Signature verification failed")
                return false, errors.New("signature verification failed")
        }</span>
        <span class="cov0" title="0">SharedLogger.Info("Signature verified successfully")
        return true, nil</span>
}

func GenerateFingerprint(publicKey ed25519.PublicKey) (string, error) <span class="cov0" title="0">{
        if len(publicKey) != PublicKeySize </span><span class="cov0" title="0">{
                SharedLogger.Error("Invalid public key size: expected %d, got %d", PublicKeySize, len(publicKey))
                return "", fmt.Errorf("invalid public key size: expected %d, got %d", PublicKeySize, len(publicKey))
        }</span>
        <span class="cov0" title="0">hash := sha256.Sum256(publicKey)
        fingerprint := hex.EncodeToString(hash[:FingerprintLength])
        return fingerprint, nil</span>
}

// Load key from env file
func LoadKeyFromFile(filename string) ([]byte, error) <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Failed to open key file: %v", err)
                return nil, fmt.Errorf("failed to open key file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        key := make([]byte, PrivateKeySize)
        _, err = file.Read(key)
        if err != nil </span><span class="cov0" title="0">{
                SharedLogger.Error("Failed to read key from file: %v", err)
                return nil, fmt.Errorf("failed to read key from file: %w", err)
        }</span>
        <span class="cov0" title="0">if len(key) != PrivateKeySize </span><span class="cov0" title="0">{
                SharedLogger.Error("Invalid key size: expected %d, got %d", PrivateKeySize, len(key))
                return nil, fmt.Errorf("invalid key size: expected %d, got %d", PrivateKeySize, len(key))
        }</span>
        <span class="cov0" title="0">return key, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// NOTE: cross compilation safe
package docker

import (
        "archive/tar"
        "bufio"
        "bytes"
        "context"
        "errors"
        "fmt"
        "github.com/docker/docker/api/types/build"
        "io"
        "nextdeploy/shared"
        "nextdeploy/shared/config"
        "nextdeploy/shared/nextcore"
        "nextdeploy/shared/registry"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "encoding/json"

        "github.com/docker/docker/client"
        "github.com/spf13/cobra"
)

const (
        DockerfileName = "Dockerfile"
        nodeVersion    = "20-alpine"
)

var (
        dlog = shared.PackageLogger("docker", "üê≥ DOCKER")
)

var (
        forceOverwrite   bool
        skipPrompts      bool
        ProvisionEcrUser bool
)

var (
        ErrDockerfileExists   = errors.New("dockerfile already exists")
        ErrDockerNotInstalled = errors.New("docker not installed")
        ErrInvalidImageName   = errors.New("invalid Docker image name")
        ErrDockerfileNotFound = errors.New("dockerfile not found")
        ErrBuildFailed        = errors.New("docker build failed")
        ErrPushFailed         = errors.New("docker push failed")
)

type DockerManager struct {
        cli     *client.Client
        verbose bool
        logger  Logger // Interface for logging
}

type Logger interface {
        Debugf(format string, args ...interface{})
        Infof(format string, args ...interface{})
        Errorf(format string, args ...interface{})
}

type BuildOptions struct {
        ImageName        string
        NoCache          bool
        Pull             bool
        Target           string
        Platform         string            // Added platform support
        ProvisionEcrUser bool              // Flag to provision ECR user
        Fresh            bool              // Flag to indicate fresh build
        AddHost          []string          `json:"add-host"`        // Custom host-to-IP mappings
        Allow            []string          `json:"allow"`           // Extra privileged entitlements
        Annotations      []string          `json:"annotation"`      // Image annotations
        Attestations     []string          `json:"attest"`          // Attestation parameters
        BuildArgs        map[string]string `json:"build-arg"`       // Build-time variables
        BuildContexts    map[string]string `json:"build-context"`   // Additional build contexts
        Builder          string            `json:"builder"`         // Builder instance override
        CacheFrom        []string          `json:"cache-from"`      // External cache sources
        CacheTo          []string          `json:"cache-to"`        // Cache export destinations
        CgroupParent     string            `json:"cgroup-parent"`   // Parent cgroup for RUN
        Dockerfile       string            `json:"file"`            // Dockerfile name/path
        IIDFile          string            `json:"iidfile"`         // Image ID output file
        Labels           map[string]string `json:"label"`           // Image metadata
        Load             bool              `json:"load"`            // Output to docker
        MetadataFile     string            `json:"metadata-file"`   // Build metadata output
        Network          string            `json:"network"`         // Networking mode
        NoCacheFilter    []string          `json:"no-cache-filter"` // Stages to exclude from cache
        Outputs          []string          `json:"output"`          // Output destinations
        Platforms        []string          `json:"platform"`        // Target platforms
        Progress         string            `json:"progress"`        // Progress output type
        Provenance       string            `json:"provenance"`      // Provenance attestation
        Push             bool              `json:"push"`            // Push to registry
        Quiet            bool              `json:"quiet"`           // Suppress output
        SBOM             string            `json:"sbom"`            // SBOM attestation
        Secrets          []string          `json:"secret"`          // Build secrets
        ShmSize          string            `json:"shm-size"`        // /dev/shm size
        SSH              []string          `json:"ssh"`             // SSH agent/keys
        Tags             []string          `json:"tag"`             // Image name/tags
        Ulimits          []string          `json:"ulimit"`          // Ulimit options
}

func NewDockerClient(logger *shared.Logger) (*DockerManager, error) <span class="cov0" title="0">{
        cli, err := client.NewClientWithOpts(
                client.FromEnv,
                client.WithAPIVersionNegotiation(),
        )
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to create Docker client: %v", err)
                return nil, fmt.Errorf("failed to create Docker client: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;DockerManager{
                cli:     cli,
                verbose: true, // Set to true for verbose logging
        }, nil</span>
}

func (dm *DockerManager) CreateTarContext(meta *nextcore.NextCorePayload) (io.Reader, error) <span class="cov0" title="0">{
        pr, pw := io.Pipe()
        tw := tar.NewWriter(pw)

        go func() </span><span class="cov0" title="0">{
                defer pw.Close()
                defer tw.Close()

                // Read Dockerfile from current directory
                dockerfileContent, err := os.ReadFile("Dockerfile")
                if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Error reading Dockerfile: %v", err)
                        pw.CloseWithError(err)
                        return
                }</span>
                <span class="cov0" title="0">dlog.Debug("Dockerfile content read successfully: %s", string(dockerfileContent))

                // Write Dockerfile to tar
                err = writeToTar(tw, "Dockerfile", dockerfileContent)
                if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Error writing Dockerfile to tar: %v", err)
                        pw.CloseWithError(err)
                        return
                }</span>

                // Copy app source, excluding unnecessary files
                <span class="cov0" title="0">dlog.Debug("Writing app files to tar from root directory: %s", meta.RootDir)
                err = filepath.Walk(meta.RootDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                dlog.Error("Error walking path %s: %v", path, err)
                                return err
                        }</span>

                        // Skip directories and unwanted files
                        <span class="cov0" title="0">if info.IsDir() ||
                                strings.Contains(path, "node_modules") ||
                                strings.Contains(path, ".next") ||
                                strings.Contains(path, ".git") </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">relPath := strings.TrimPrefix(path, meta.RootDir+string(filepath.Separator))
                        fileData, err := os.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                dlog.Error("Error reading file %s: %v", path, err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return writeToTar(tw, relPath, fileData)</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Error writing app files to tar: %v", err)
                        pw.CloseWithError(err)
                        return
                }</span>
        }()

        <span class="cov0" title="0">return pr, nil</span>
}

func writeToTar(tw *tar.Writer, name string, data []byte) error <span class="cov0" title="0">{
        hdr := &amp;tar.Header{
                Name:     name,
                Mode:     0644,
                Size:     int64(len(data)),
                Typeflag: tar.TypeReg,
                ModTime:  time.Now(),
        }
        if err := tw.WriteHeader(hdr); err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error writing header for %s: %v", name, err)
                return err
        }</span>
        <span class="cov0" title="0">_, err := tw.Write(data)
        return err</span>
}
func (dm *DockerManager) BuildAndDeploy(ctx context.Context, opts BuildOptions) error <span class="cov0" title="0">{
        meta, err := nextcore.GenerateMetadata()
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error generating metadata: %v", err)
                fmt.Printf("Error generating metadata: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">dlog.Info("Generated metadata: %+v", meta)
        file, err := os.ReadFile(".nextdeploy/metadata.json")
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error loading metadata: %v", err)
                fmt.Printf("Error loading metadata: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">var payload nextcore.NextCorePayload
        if err := json.Unmarshal(file, &amp;payload); err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error parsing metadata: %v", err)
                fmt.Printf("Error parsing metadata: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">ctx = context.Background()
        cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error creating Docker client: %v", err)
                panic(err)</span>
        }

        // Use consistent image naming with git commit hash
        <span class="cov0" title="0">imageName := fmt.Sprintf("%s:%s", strings.ToLower(payload.Config.App.Name), payload.GitCommit)
        dlog.Debug("Using image name: %s", imageName)
        if payload.GitCommit == "" </span><span class="cov0" title="0">{
                imageName = fmt.Sprintf("%s:latest", strings.ToLower(payload.Config.App.Name))
        }</span>

        // Step 1: Create tar stream
        <span class="cov0" title="0">tarBuf, err := createTarContext(&amp;payload)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error creating tar context: %v", err)
                panic(err)</span>
        }

        // Step 2: Build image
        <span class="cov0" title="0">buildOptions := build.ImageBuildOptions{
                Tags:       []string{imageName},
                Remove:     true,
                Dockerfile: "Dockerfile",
        }

        buildResp, err := cli.ImageBuild(ctx, tarBuf, buildOptions)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error building image: %v", err)
                panic(err)</span>
        }
        <span class="cov0" title="0">defer buildResp.Body.Close()

        // Stream build output and check for errors
        scanner := bufio.NewScanner(buildResp.Body)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                fmt.Println(line)

                // Check for build errors in the output
                if strings.Contains(line, "ERROR") || strings.Contains(line, "error") </span><span class="cov0" title="0">{
                        dlog.Error("Build error detected: %s", line)
                        os.Exit(1)
                }</span>
        }
        // Create runtime
        <span class="cov0" title="0">runtime, err := nextcore.NewNextRuntime(&amp;payload)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error creating runtime: %v", err)
                fmt.Printf("Error creating runtime: %v\n", err)
                os.Exit(1)
        }</span>

        // Create and start container
        <span class="cov0" title="0">containerID, err := runtime.CreateContainer(context.Background())
        dlog.Debug("Creating container with ID: %s", containerID)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error creating container: %v", err)
                fmt.Printf("Error starting container: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Container started successfully: %s\n", containerID)

        return nil</span>
}

func createTarContext(meta *nextcore.NextCorePayload) (io.Reader, error) <span class="cov0" title="0">{
        pr, pw := io.Pipe()
        tw := tar.NewWriter(pw)

        go func() </span><span class="cov0" title="0">{
                defer pw.Close()
                defer tw.Close()

                // Read Dockerfile from current directory
                dockerfileContent, err := os.ReadFile("Dockerfile")
                if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Error reading Dockerfile: %v", err)
                        pw.CloseWithError(err)
                        return
                }</span>
                <span class="cov0" title="0">dlog.Debug("Dockerfile content read successfully: %s", string(dockerfileContent))

                // Write Dockerfile to tar
                err = writeToTar(tw, "Dockerfile", dockerfileContent)
                if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Error writing Dockerfile to tar: %v", err)
                        pw.CloseWithError(err)
                        return
                }</span>

                // Copy app source, excluding unnecessary files
                <span class="cov0" title="0">dlog.Debug("Writing app files to tar from root directory: %s", meta.RootDir)
                err = filepath.Walk(meta.RootDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                dlog.Error("Error walking path %s: %v", path, err)
                                return err
                        }</span>

                        // Skip directories and unwanted files
                        <span class="cov0" title="0">if info.IsDir() ||
                                strings.Contains(path, "node_modules") ||
                                strings.Contains(path, ".next") ||
                                strings.Contains(path, ".git") </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">relPath := strings.TrimPrefix(path, meta.RootDir+string(filepath.Separator))
                        fileData, err := os.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                dlog.Error("Error reading file %s: %v", path, err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return writeToTar(tw, relPath, fileData)</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Error writing app files to tar: %v", err)
                        pw.CloseWithError(err)
                        return
                }</span>
        }()

        <span class="cov0" title="0">return pr, nil</span>
}

// Helper method to build Docker image
func (dm *DockerManager) buildDockerImage(ctx context.Context, metadata *nextcore.NextCorePayload, opts BuildOptions) (string, error) <span class="cov0" title="0">{
        // Determine image name with git commit hash
        imageName := fmt.Sprintf("%s:%s", strings.ToLower(metadata.Config.App.Name), metadata.GitCommit)
        if metadata.GitCommit == "" </span><span class="cov0" title="0">{
                imageName = fmt.Sprintf("%s:latest", strings.ToLower(metadata.Config.App.Name))
                dlog.Warn("Git commit is empty, using 'latest' tag for image")
        }</span>
        <span class="cov0" title="0">dlog.Debug("Building image: %s", imageName)

        // Create build context
        buildContext, err := dm.createBuildContext(metadata)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to create build context: %v", err)
                return "", fmt.Errorf("failed to create build context: %w", err)
        }</span>
        <span class="cov0" title="0">defer buildContext.Close()

        // Build options
        buildOptions := build.ImageBuildOptions{
                Tags:       []string{imageName},
                Dockerfile: "Dockerfile",
                BuildArgs:  dm.GetBuildArgs(),
                Remove:     true,
                NoCache:    opts.NoCache,
                PullParent: true,
        }

        cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
        // Build the image
        buildResponse, err := cli.ImageBuild(ctx, buildContext, buildOptions)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to build image: %v", err)
                return "", fmt.Errorf("failed to build image: %w", err)
        }</span>
        <span class="cov0" title="0">defer buildResponse.Body.Close()

        // Stream and parse build output
        if err := dm.streamBuildOutput(buildResponse.Body); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("build failed: %w", err)
        }</span>

        <span class="cov0" title="0">dlog.Success("‚úÖ Successfully built image: %s", imageName)
        return imageName, nil</span>
}

// Helper method to create and start container
func (dm *DockerManager) createAndStartContainer(ctx context.Context, metadata *nextcore.NextCorePayload, imageName string) (string, error) <span class="cov0" title="0">{
        // Create runtime instance
        runtime, err := nextcore.NewNextRuntime(metadata)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error creating runtime: %v", err)
                return "", fmt.Errorf("error creating runtime: %w", err)
        }</span>

        // Create container
        <span class="cov0" title="0">containerID, err := runtime.CreateContainer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Error creating container: %v", err)
                return "", fmt.Errorf("error creating container: %w", err)
        }</span>

        <span class="cov0" title="0">dlog.Debug("Created container with ID: %s", containerID)
        return containerID, nil</span>
}

// Helper method to stream build output
func (dm *DockerManager) streamBuildOutput(reader io.Reader) error <span class="cov0" title="0">{
        scanner := bufio.NewScanner(reader)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()

                var message struct {
                        Stream string `json:"stream"`
                        Error  string `json:"error"`
                        Status string `json:"status"`
                }

                if err := json.Unmarshal([]byte(line), &amp;message); err != nil </span><span class="cov0" title="0">{
                        // If not JSON, log as raw output
                        dlog.Info("Build: %s", strings.TrimSpace(line))
                        continue</span>
                }

                // Handle different message types
                <span class="cov0" title="0">if message.Stream != "" </span><span class="cov0" title="0">{
                        dlog.Info("Build: %s", strings.TrimSpace(message.Stream))
                }</span>
                <span class="cov0" title="0">if message.Status != "" </span><span class="cov0" title="0">{
                        dlog.Debug("Status: %s", message.Status)
                }</span>
                <span class="cov0" title="0">if message.Error != "" </span><span class="cov0" title="0">{
                        dlog.Error("Build error: %s", message.Error)
                        return fmt.Errorf("build error: %s", message.Error)
                }</span>

                // Check for error patterns in raw output as fallback
                <span class="cov0" title="0">if strings.Contains(strings.ToLower(line), "error") </span><span class="cov0" title="0">{
                        dlog.Error("Build error detected: %s", line)
                        return fmt.Errorf("build error detected: %s", line)
                }</span>
        }

        <span class="cov0" title="0">return scanner.Err()</span>
}
func (dm *DockerManager) createBuildContext(metadata *nextcore.NextCorePayload) (io.ReadCloser, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        tw := tar.NewWriter(&amp;buf)
        defer tw.Close()

        dockerfileContent, err := os.ReadFile("Dockerfile")
        dlog.Debug("Generated Dockerfile content:\n%s", dockerfileContent)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to generate Dockerfile content: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := addFileToTar(tw, "Dockerfile", []byte(dockerfileContent), 0644); err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to add Dockerfile to tar: %v", err)
                return nil, err
        }</span>

        // Add application files
        <span class="cov0" title="0">if err := dm.addAppFiles(tw); err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to add application files to tar: %v", err)
                return nil, err
        }</span>

        // Add metadata and assets
        <span class="cov0" title="0">if err := dm.addMetadataAndAssets(tw); err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to add metadata and assets to tar: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">nr, err := nextcore.NewNextRuntime(metadata)

        //generate and add caddy file
        caddyfilecontent := nr.GenerateCaddyfile()
        dlog.Debug("caddy config is :%s", caddyfilecontent)
        if err := addFileToTar(tw, "Caddyfile", []byte(caddyfilecontent), 0644); err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to add Caddyfile to tar: %v", err)
                return nil, fmt.Errorf("failed to add Caddyfile to tar: %w", err)
        }</span>

        <span class="cov0" title="0">return io.NopCloser(&amp;buf), nil</span>
}

func (dm *DockerManager) GenerateDockerCompose(metadata *nextcore.NextCorePayload) error <span class="cov0" title="0">{
        composeTemplate := `version: '3.8'

services:
  nextjs:
    image: %s
    container_name: nextjs
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - PORT=3000
    volumes:
      - ./.nextdeploy/assets:/app/public
    networks:
      - nextcore-network

  caddy:
    image: caddy:2-alpine
    container_name: caddy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./.nextdeploy/caddy/Caddyfile:/etc/caddy/Caddyfile
      - ./.nextdeploy/caddy/data:/data
      - ./.nextdeploy/caddy/config:/config
    networks:
      - nextcore-network

networks:
  nextcore-network:
    driver: bridge
    name: nextcore-network`

        content := fmt.Sprintf(composeTemplate, metadata.Config.App.Name)
        return os.WriteFile("docker-compose.yml", []byte(content), 0644)
}</span>
func (dm DockerManager) addAppFiles(tw *tar.Writer) error <span class="cov0" title="0">{
        // Get current working directory
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current working directory: %w", err)
        }</span>

        // Detect package manager
        <span class="cov0" title="0">packageManager, err := nextcore.DetectPackageManager(cwd)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to detect package manager: %v", err)
                return fmt.Errorf("failed to detect package manager: %w", err)
        }</span>

        // Determine lock files based on package manager
        <span class="cov0" title="0">var packageFiles []string
        switch packageManager </span>{
        case "yarn":<span class="cov0" title="0">
                packageFiles = []string{"package.json", "yarn.lock"}</span>
        case "pnpm":<span class="cov0" title="0">
                packageFiles = []string{"package.json", "pnpm-lock.yaml"}</span>
        default:<span class="cov0" title="0"> // npm
                packageFiles = []string{"package.json", "package-lock.json"}</span>
        }

        // Add package files
        <span class="cov0" title="0">for _, file := range packageFiles </span><span class="cov0" title="0">{
                if err := dm.addFileIfExists(tw, file); err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Failed to add package file %s: %v", file, err)
                        return fmt.Errorf("failed to add package file %s: %w", file, err)
                }</span>
        }

        // Add configuration files
        <span class="cov0" title="0">configFiles := []string{"next.config.js", "next.config.mjs", ".env", ".env.local"}
        for _, file := range configFiles </span><span class="cov0" title="0">{
                if err := dm.addFileIfExists(tw, file); err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Failed to add config file %s: %v", file, err)
                        return fmt.Errorf("failed to add config file %s: %w", file, err)
                }</span>
        }

        // Add source directories
        <span class="cov0" title="0">dirs := []string{"pages", "app", "components", "public", "src"}
        for _, dir := range dirs </span><span class="cov0" title="0">{
                if _, err := os.Stat(dir); err == nil </span><span class="cov0" title="0">{
                        if err := addDirectoryToTar(tw, dir, dir); err != nil </span><span class="cov0" title="0">{
                                dlog.Error("Failed to add directory %s: %v", dir, err)
                                return fmt.Errorf("failed to add directory %s: %w", dir, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func addDirectoryToTar(tw *tar.Writer, srcDir, tarDir string) error <span class="cov0" title="0">{
        // Walk through the directory and add files to tar
        return filepath.Walk(srcDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Error walking path %s: %v", path, err)
                        return fmt.Errorf("error walking path %s: %w", path, err)
                }</span>
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil // Skip directories
                }</span>

                // Read file content
                <span class="cov0" title="0">content, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Failed to read file %s: %v", path, err)
                        return fmt.Errorf("failed to read file %s: %w", path, err)
                }</span>

                // Create tar header
                <span class="cov0" title="0">header := &amp;tar.Header{
                        Name: filepath.Join(tarDir, strings.TrimPrefix(path, srcDir+"/")),
                        Mode: int64(info.Mode()),
                        Size: int64(len(content)),
                }

                if err := tw.WriteHeader(header); err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Failed to write header for %s: %v", path, err)
                        return fmt.Errorf("failed to write header for %s: %w", path, err)
                }</span>

                <span class="cov0" title="0">if _, err := tw.Write(content); err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Error writing content for %s: %v", path, err)
                        return fmt.Errorf("failed to write content for %s: %w", path, err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}
func (dm *DockerManager) addMetadataAndAssets(tw *tar.Writer) error <span class="cov0" title="0">{
        // Add metadata files
        metadataFiles := []string{".nextdeploy/metadata.json", ".nextdeploy/build.lock"}
        for _, file := range metadataFiles </span><span class="cov0" title="0">{
                if content, err := os.ReadFile(file); err == nil </span><span class="cov0" title="0">{
                        if err := addFileToTar(tw, file, content, 0644); err != nil </span><span class="cov0" title="0">{
                                dlog.Error("Failed to add metadata file %s: %v", file, err)
                                return err
                        }</span>
                }
        }

        // Add static assets
        <span class="cov0" title="0">if err := addDirectoryToTar(tw, ".nextdeploy/assets", ".nextdeploy/assets"); err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to add static assets: %v", err)
                return fmt.Errorf("failed to add static assets: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// TODO: build args are static we need load from somewhere that is user defined
func (dc *DockerManager) GetBuildArgs() map[string]*string <span class="cov0" title="0">{
        nodeEnv := "production"
        nodeVersion := "20-alpine"
        appEnv := "production"

        return map[string]*string{
                "NODE_ENV":     &amp;nodeEnv,
                "NODE_VERSION": &amp;nodeVersion,
                "APP_ENV":      &amp;appEnv,
        }
}</span>
func (dm DockerManager) addFileIfExists(tw *tar.Writer, filename string) error <span class="cov0" title="0">{
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // File doesn't exist - skip silently
                        dlog.Debug("File %s does not exist, skipping", filename)
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if err := addFileToTar(tw, filename, content, 0644); err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to add file %s to tar: %v", filename, err)
                return fmt.Errorf("failed to add file %s to tar: %w", filename, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Helper functions
func addFileToTar(tw *tar.Writer, name string, content []byte, mode int64) error <span class="cov0" title="0">{
        hdr := &amp;tar.Header{
                Name: name,
                Mode: mode,
                Size: int64(len(content)),
        }
        if err := tw.WriteHeader(hdr); err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to write header for %s: %v", name, err)
                return err
        }</span>
        <span class="cov0" title="0">_, err := tw.Write(content)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to write content for %s: %v", name, err)
                // Return a more descriptive error
                return fmt.Errorf("failed to write content for %s: %w", name, err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

// DockerfileExists checks if a Dockerfile exists in the specified directory
func (dm *DockerManager) DockerfileExists(dir string) (bool, error) <span class="cov0" title="0">{
        path := filepath.Join(dir, DockerfileName)
        dlog.Debug("Checking for Dockerfile at: %s", path)

        stat, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        dlog.Debug("Dockerfile does not exist at: %s", path)
                        return false, nil
                }</span>
                <span class="cov0" title="0">dlog.Error("Error checking Dockerfile: %v", err)
                return false, fmt.Errorf("error checking Dockerfile: %w", err)</span>
        }
        <span class="cov0" title="0">if stat.IsDir() </span><span class="cov0" title="0">{
                dlog.Error("Dockerfile path is a directory, expected a file")
                return false, fmt.Errorf("dockerfile path is a directory")
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// GenerateDockerfile creates a new Dockerfile with content tailored to the package manager
func (dm *DockerManager) GenerateDockerfile(dir, pkgManager string, overwrite bool) error <span class="cov0" title="0">{
        exists, err := dm.DockerfileExists(dir)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to check Dockerfile existence: %v", err)
                return fmt.Errorf("failed to check Dockerfile existence: %w", err)
        }</span>
        <span class="cov0" title="0">if exists &amp;&amp; !overwrite </span><span class="cov0" title="0">{
                return ErrDockerfileExists
        }</span>
        <span class="cov0" title="0">content, err := dm.GenerateDockerfileContent(pkgManager)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to generate Dockerfile content: %v", err)
                return fmt.Errorf("failed to generate Dockerfile content: %w", err)
        }</span>

        <span class="cov0" title="0">return dm.WriteDockerfile(dir, content)</span>
}

// WriteDockerfile writes content to Dockerfile in the specified directory
func (dm *DockerManager) WriteDockerfile(dir, content string) error <span class="cov0" title="0">{
        content = strings.TrimSpace(content) + "\n"
        dlog.Debug("Writing Dockerfile with content:\n%s", content)

        path := filepath.Join(dir, DockerfileName)
        err := os.WriteFile(path, []byte(content), 0644)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to write Dockerfile: %v", err)
                return fmt.Errorf("failed to write Dockerfile: %w", err)
        }</span>

        <span class="cov0" title="0">dlog.Success("Dockerfile created successfully at %s", path)
        return nil</span>
}

// generateDockerfileContent creates Dockerfile content based on package manager
func (dm *DockerManager) GenerateDockerfileContent(pkgManager string) (string, error) <span class="cov0" title="0">{
        // Predefined templates for different package managers
        templates := map[string]string{
                "yarn": `# ---------- STAGE 1: Build ----------
FROM node:18-alpine AS base
WORKDIR /app

# Install dependencies needed by some node modules
RUN apk add --no-cache libc6-compat

# ---------- STAGE 2: Dependencies ----------
FROM base AS deps

# Copy package files first
COPY package.json yarn.lock ./

# Configure Yarn to use node_modules instead of PnP
RUN echo "nodeLinker: node-modules" &gt; .yarnrc.yml

# Install Yarn Berry and dependencies
RUN corepack enable &amp;&amp; \
    yarn set version stable &amp;&amp; \
    yarn install --immutable
# ---------- STAGE 3: Builder ----------
FROM base AS builder

# First copy only the files needed for dependency installation
COPY --from=deps /app/ ./

# Then copy all other files
COPY . .
RUN corepack enable 
# set yarn version to stable 
RUN yarn set version stable 
# Install production dependencies
# Build the Next.js application 
# Build the application
RUN yarn build

# ---------- STAGE 4: Runner ----------
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

# Create non-root user
RUN addgroup --system --gid 1001 nodejs &amp;&amp; \
    adduser --system --uid 1001 nextjs

# Copy necessary files from builder
COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

CMD ["node", "server.js"]
`,

                "pnpm": `# ---------- STAGE 1: Build ----------
FROM node:%s AS builder

WORKDIR /app

COPY package.json ./
COPY pnpm-lock.yaml ./

RUN pnpm install --frozen-lockfile

COPY . .

RUN pnpm run build

# ---------- STAGE 2: Runtime ----------
FROM node:%s

WORKDIR /app

COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

RUN adduser -D nextjs &amp;&amp; chown -R nextjs:nextjs /app
USER nextjs

EXPOSE 3000
ENV PORT=3000
ENV NODE_ENV=production

CMD ["node", "server.js"]`,
        }

        template, ok := templates[pkgManager]
        if !ok </span><span class="cov0" title="0">{
                dlog.Debug("Unknown package manager '%s', defaulting to npm", pkgManager)
                template = templates["npm"]
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(template, nodeVersion, nodeVersion), nil</span>
}

// ValidateImageName checks if a Docker image name is valid
func (dm *DockerManager) ValidateImageName(name string) error <span class="cov0" title="0">{
        if len(name) == 0 </span><span class="cov0" title="0">{
                dlog.Error("Image name cannot be empty")
                return fmt.Errorf("%w: image name cannot be empty", ErrInvalidImageName)
        }</span>

        <span class="cov0" title="0">if len(name) &gt; 255 </span><span class="cov0" title="0">{
                dlog.Error("Image name exceeds 255 characters")
                return fmt.Errorf("%w: exceeds 255 characters", ErrInvalidImageName)
        }</span>

        // Updated regex patterns with better support for git commit hashes
        <span class="cov0" title="0">validImageName := regexp.MustCompile(`^[a-z0-9]+(?:[._-][a-z0-9]+)*(?:/[a-z0-9]+(?:[._-][a-z0-9]+)*)*$`)
        validTag := regexp.MustCompile(`^[a-z0-9][a-z0-9._-]{0,127}$`)

        parts := strings.SplitN(name, ":", 2)
        if !validImageName.MatchString(parts[0]) </span><span class="cov0" title="0">{
                dlog.Error("Invalid repository name: %s", parts[0])
                return fmt.Errorf("%w: invalid repository name", ErrInvalidImageName)
        }</span>

        <span class="cov0" title="0">if len(parts) == 2 </span><span class="cov0" title="0">{
                tag := parts[1]
                if len(tag) &gt; 128 </span><span class="cov0" title="0">{
                        dlog.Error("Tag exceeds maximum length (128 characters)")
                        return fmt.Errorf("%w: tag exceeds maximum length", ErrInvalidImageName)
                }</span>

                // Special case for git commit hashes (7-40 hex chars)
                <span class="cov0" title="0">if isGitCommitHash(tag) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if !validTag.MatchString(tag) </span><span class="cov0" title="0">{
                        dlog.Error("Invalid tag format: %s", tag)
                        return fmt.Errorf("%w: invalid tag format", ErrInvalidImageName)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// isGitCommitHash checks if the tag is a valid git commit hash (7-40 hex characters)
func isGitCommitHash(tag string) bool <span class="cov0" title="0">{
        if len(tag) &lt; 7 || len(tag) &gt; 40 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">matched, _ := regexp.MatchString(`^[a-f0-9]+$`, tag)
        return matched</span>
}

// CheckDockerInstalled verifies Docker is available
func (dm *DockerManager) CheckDockerInstalled() error <span class="cov0" title="0">{
        dlog.Info("Checking if Docker is installed...")
        path, err := exec.LookPath("docker")
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Docker not found in PATH: %v", err)
                return fmt.Errorf("%w: %s", ErrDockerNotInstalled, err)
        }</span>

        <span class="cov0" title="0">dlog.Success("Docker found at: %s", path)

        // Verify docker is actually working
        cmd := exec.Command("docker", "version")
        err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Docker command failed: %v", err)
                return fmt.Errorf("%w: %s", ErrDockerNotInstalled, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (dm *DockerManager) PushImage(ctx context.Context, imageName string, ProvisionECRUser bool, Fresh bool) error <span class="cov0" title="0">{
        err := dm.ValidateImageName(imageName)
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Invalid Docker image name: %s", imageName)
                return fmt.Errorf("%w: %s", ErrInvalidImageName, err)
        }</span>
        <span class="cov0" title="0">err = dm.CheckDockerInstalled()
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Docker is not installed or not functioning: %v", err)
                return fmt.Errorf("%w: %s", ErrDockerNotInstalled, err)
        }</span>
        <span class="cov0" title="0">cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                dlog.Error("Failed to load configuration: %v", err)
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>
        <span class="cov0" title="0">if cfg.Docker.Registry == "ecr" </span><span class="cov0" title="0">{
                dlog.Info("Preparing ECR context for image push")
                ecrContext := registry.ECRContext{
                        ECRRepoName: cfg.Docker.Image,
                        ECRRegion:   cfg.Docker.RegistryRegion,
                }
                if ProvisionECRUser </span><span class="cov0" title="0">{
                        if Fresh </span><span class="cov0" title="0">{
                                dlog.Info("Provisioning new ECR user and policy and new old ones for name conflict")
                                // before deleting we we need to confirm user to deleted exists in order to avoid try to non-existing user deletion
                                exists, err := registry.CheckUserExists()
                                if err != nil </span><span class="cov0" title="0">{
                                        dlog.Error("Failed to check if ECR user exists: %v", err)
                                        return fmt.Errorf("failed to check if ECR user exists: %w", err)
                                }</span>
                                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                                        err = registry.DeleteECRUserAndPolicy()
                                        if err != nil </span><span class="cov0" title="0">{
                                                dlog.Error("Failed to delete old ECR user and policy: %v", err)
                                                return fmt.Errorf("failed to delete old ECR user and policy: %w", err)
                                        }</span> else<span class="cov0" title="0"> {
                                                dlog.Info("Old ECR user and policy deleted successfully")
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">user, err := registry.CreateECRUserAndPolicy()
                        if err != nil </span><span class="cov0" title="0">{
                                dlog.Error("Failed to create ECR user and policy: %v", err)
                                return fmt.Errorf("failed to create ECR user and policy: %w", err)
                        }</span>
                        <span class="cov0" title="0">dlog.Info("ECR user created: %v", user)</span>
                }
                <span class="cov0" title="0">dlog.Debug("ECR context: %+v", ecrContext)
                // prepare ecr push context
                err = registry.PrepareECRPushContext(ctx, Fresh)
                if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Failed to prepare ECR push context: %v", err)
                        return fmt.Errorf("failed to prepare ECR push context: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if strings.Contains(cfg.Docker.Registry, "digitalocean") </span><span class="cov0" title="0">{
                dlog.Info("Preparing DigitalOcean context for image push")
                if err := registry.DigitalOceanRegistry(ctx); err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Failed to prepare DigitalOcean push context: %v", err)
                        return fmt.Errorf("failed to prepare DigitalOcean push context: %w", err)
                }</span>
        }
        // Push the image using 'docker push' command  if default which docker hub
        <span class="cov0" title="0">dockerhub := strings.Contains(cfg.Docker.Registry, "docker")
        if dockerhub </span><span class="cov0" title="0">{
                dlog.Info("Pushing Docker image: %s", imageName)
                cmd := exec.CommandContext(ctx, "docker", "push", imageName)
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr

                err = cmd.Run()
                if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Failed to push Docker image: %v", err)
                        return fmt.Errorf("%w: %s", ErrPushFailed, err)
                }</span>
                <span class="cov0" title="0">dlog.Success("Image pushed successfully: %s", imageName)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func HandleDockerfileSetup(cmd *cobra.Command, dm *DockerManager, reader *bufio.Reader) error <span class="cov0" title="0">{
        if skipPrompts || config.PromptYesNo(reader, "Set up Dockerfile for your project?") </span><span class="cov0" title="0">{
                exists, err := dm.DockerfileExists(".")
                if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Failed to check for Dockerfile: %v", err)
                        return fmt.Errorf("failed to check for Dockerfile: %w", err)
                }</span>

                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        if !forceOverwrite &amp;&amp; !skipPrompts &amp;&amp; !config.PromptYesNo(reader, "Dockerfile exists. Overwrite?") </span><span class="cov0" title="0">{
                                dlog.Info("Skipping Dockerfile creation")
                                cmd.Println("‚ÑπÔ∏è Using existing Dockerfile")
                                return nil
                        }</span>
                }

                <span class="cov0" title="0">pkgManager := "npm"
                if !skipPrompts </span><span class="cov0" title="0">{
                        cwd, err := os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                dlog.Error("Failed to get current directory: %v", err)
                                return fmt.Errorf("failed to get current directory: %w", err)
                        }</span>
                        <span class="cov0" title="0">detectManager, err := nextcore.DetectPackageManager(cwd)
                        if err != nil </span><span class="cov0" title="0">{
                                dlog.Error("Failed to detect package manager: %v", err)
                                return fmt.Errorf("failed to detect package manager: %w", err)
                        }</span>
                        <span class="cov0" title="0">pkgManager = detectManager.String()</span>
                }

                <span class="cov0" title="0">err = dm.GenerateDockerfile(".", pkgManager, true)
                if err != nil </span><span class="cov0" title="0">{
                        dlog.Error("Failed to generate Dockerfile: %v", err)
                        return fmt.Errorf("failed to generate Dockerfile: %w", err)
                }</span>
                <span class="cov0" title="0">dlog.Success("Dockerfile created successfully")
                // Add .dockerignore file creation
                if skipPrompts || config.PromptYesNo(reader, "Create .dockerignore file?") </span><span class="cov0" title="0">{
                        if err := createDockerignore(); err != nil </span><span class="cov0" title="0">{

                                dlog.Error("‚ö†Ô∏è Couldn't create .dockerignore: %v\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                dlog.Success("‚úÖ Created .dockerignore")
                                cmd.Println("‚úÖ Created .dockerignore")
                        }</span>
                } else<span class="cov0" title="0"> {
                        dlog.Info("‚ÑπÔ∏è Skipping .dockerignore creation")
                }</span>

                <span class="cov0" title="0">if skipPrompts || config.PromptYesNo(reader, "Add .env and node_modules to .gitignore?") </span><span class="cov0" title="0">{
                        if err := updateGitignore(); err != nil </span><span class="cov0" title="0">{
                                dlog.Error("‚ö†Ô∏è Couldn't update .gitignore: %v\n", err)
                                cmd.Printf("‚ö†Ô∏è Couldn't update .gitignore: %v\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                dlog.Success("‚úÖ Updated .gitignore")
                                cmd.Println("‚úÖ Updated .gitignore")
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func updateGitignore() error <span class="cov0" title="0">{
        entries := []string{
                "\n# NextDeploy",
                ".env",
                "node_modules",
                ".next",
                "dist",
        }

        content := ""
        if file, err := os.ReadFile(".gitignore"); err == nil </span><span class="cov0" title="0">{
                content = string(file)
        }</span>

        <span class="cov0" title="0">toAdd := []string{}
        for _, entry := range entries </span><span class="cov0" title="0">{
                if !strings.Contains(content, entry) </span><span class="cov0" title="0">{
                        toAdd = append(toAdd, entry)
                }</span>
        }

        <span class="cov0" title="0">if len(toAdd) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">f, err := os.OpenFile(".gitignore", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open .gitignore file: %w", err)
        }</span>

        <span class="cov0" title="0">err = f.Close()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to close .gitignore file: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = f.WriteString(strings.Join(toAdd, "\n") + "\n")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to .gitignore file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func createDockerignore() error <span class="cov0" title="0">{
        patterns := []string{
                "# NextDeploy Dockerignore: auto-generated file",
                "",
                "# Node modules and build directories",
                "node_modules",
                ".next",
                "dist",
                "",
                "# Environment files",
                ".env*",
                "",
                "# Logs",
                "npm-debug.log*",
                "yarn-debug.log*",
                "yarn-error.log*",
                "",
                "# Git",
                ".git",
                ".gitignore",
                "",
                "# IDE",
                ".idea",
                ".vscode",
                "",
                "# OS generated files",
                ".DS_Store",
                "Thumbs.db",
        }

        // Check if file already exists
        if _, err := os.Stat(".dockerignore"); err == nil </span><span class="cov0" title="0">{
                // Read existing content
                existingContent, err := os.ReadFile(".dockerignore")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read existing .dockerignore: %w", err)
                }</span>

                // Split existing content into lines
                <span class="cov0" title="0">existingLines := strings.Split(string(existingContent), "\n")

                // Create a map for existing patterns for quick lookup
                existingPatterns := make(map[string]bool)
                for _, line := range existingLines </span><span class="cov0" title="0">{
                        line = strings.TrimSpace(line)
                        if line != "" &amp;&amp; !strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                                existingPatterns[line] = true
                        }</span>
                }

                // Add only new patterns that don't exist already
                <span class="cov0" title="0">var newPatterns []string
                for _, line := range patterns </span><span class="cov0" title="0">{
                        line = strings.TrimSpace(line)
                        if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                                newPatterns = append(newPatterns, line)
                        }</span> else<span class="cov0" title="0"> if !existingPatterns[line] </span><span class="cov0" title="0">{
                                newPatterns = append(newPatterns, line)
                        }</span>
                }

                // Combine existing content with new patterns
                <span class="cov0" title="0">content := string(existingContent)
                if len(content) &gt; 0 &amp;&amp; !strings.HasSuffix(content, "\n") </span><span class="cov0" title="0">{
                        content += "\n"
                }</span>
                <span class="cov0" title="0">content += strings.Join(newPatterns, "\n")

                // Write the merged file
                err = os.WriteFile(".dockerignore", []byte(content), 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update .dockerignore: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Write the file if it doesn't exist
        <span class="cov0" title="0">content := strings.Join(patterns, "\n")
        err := os.WriteFile(".dockerignore", []byte(content), 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .dockerignore: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package envstore

import (
        "bufio"
        "fmt"
        "nextdeploy/shared"
        "os"
        "strings"
)

type Store[T any] struct {
        data     map[string]T
        filename string
}

var (
        storeLogger = shared.PackageLogger("ENV", "üå± ENV")
)

// Option is a functional option pattern type for configuring Store
type Option[T any] func(*Store[T]) error

// WithEnvFile configures the store to load initial data from an env file
func WithEnvFile[T any](filename string) Option[T] <span class="cov0" title="0">{
        return func(s *Store[T]) error </span><span class="cov0" title="0">{
                s.filename = filename
                envData, err := readEnvFile(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Convert env data to type T - this is simplistic and would need adaptation
                // based on how you want to map env vars to your type T
                <span class="cov0" title="0">for k, _ := range envData </span><span class="cov0" title="0">{
                        // This is a placeholder - actual conversion depends on T
                        var value T
                        // You'd need type-specific conversion here
                        s.data[k] = value
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

// New creates a new Store with optional configurations
func New[T any](opts ...Option[T]) (*Store[T], error) <span class="cov0" title="0">{
        s := &amp;Store[T]{
                data: make(map[string]T),
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(s); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return s, nil</span>
}

// Create adds a new item to the store
func (s *Store[T]) Create(key string, value T) error <span class="cov0" title="0">{
        if _, exists := s.data[key]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("key %s already exists", key)
        }</span>
        <span class="cov0" title="0">s.data[key] = value
        return nil</span>
}

// Read retrieves an item from the store
func (s *Store[T]) Read(key string) (T, error) <span class="cov0" title="0">{
        value, exists := s.data[key]
        if !exists </span><span class="cov0" title="0">{
                return value, fmt.Errorf("key %s not found", key)
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

// Update modifies an existing item in the store
func (s *Store[T]) Update(key string, value T) error <span class="cov0" title="0">{
        if _, exists := s.data[key]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("key %s not found", key)
        }</span>
        <span class="cov0" title="0">s.data[key] = value
        return nil</span>
}

// Delete removes an item from the store
func (s *Store[T]) Delete(key string) error <span class="cov0" title="0">{
        if _, exists := s.data[key]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("key %s not found", key)
        }</span>
        <span class="cov0" title="0">delete(s.data, key)
        return nil</span>
}

// Env variable operations

// GetEnv reads a single value from the environment or env file
func (s *Store[T]) GetEnv(key string) (string, error) <span class="cov0" title="0">{
        // First try OS environment
        if value, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                return value, nil
        }</span>

        // Fall back to env file if configured
        <span class="cov0" title="0">if s.filename != "" </span><span class="cov0" title="0">{
                envData, err := readEnvFile(s.filename)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if value, exists := envData[key]; exists </span><span class="cov0" title="0">{
                        return value, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("environment variable %s not found", key)</span>
}

// Helper function to read env file
func readEnvFile(filename string) (map[string]string, error) <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">storeLogger.Debug("Reading env file: %v", filename)
        defer func() </span><span class="cov0" title="0">{
                if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                        storeLogger.Error("Failed to close env file: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">env := make(map[string]string)
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := strings.TrimSpace(scanner.Text())
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">env[strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return env, nil</span>
}

// Functional variants that return functions for composition

// CreateFn returns a function that performs a Create operation
func CreateFn[T any](key string, value T) func(*Store[T]) error <span class="cov0" title="0">{
        return func(s *Store[T]) error </span><span class="cov0" title="0">{
                return s.Create(key, value)
        }</span>
}

// ReadFn returns a function that performs a Read operation
func ReadFn[T any](key string, fn func(T) error) func(*Store[T]) error <span class="cov0" title="0">{
        return func(s *Store[T]) error </span><span class="cov0" title="0">{
                value, err := s.Read(key)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return fn(value)</span>
        }
}

// UpdateFn returns a function that performs an Update operation
func UpdateFn[T any](key string, value T) func(*Store[T]) error <span class="cov0" title="0">{
        return func(s *Store[T]) error </span><span class="cov0" title="0">{
                return s.Update(key, value)
        }</span>
}

// DeleteFn returns a function that performs a Delete operation
func DeleteFn[T any](key string) func(*Store[T]) error <span class="cov0" title="0">{
        return func(s *Store[T]) error </span><span class="cov0" title="0">{
                return s.Delete(key)
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package failfast

import (
        "nextdeploy/shared"
        "os"
        "runtime"
)

type ErrorLevel int

const (
        Ignore   ErrorLevel = iota // do nothing, just log
        Warn                       // log a Warning
        Error                      // log an Error and exit with code 1
        Critical                   // log a Critical error and exit with code 1
        Panic                      // log a Panic error and Panic
        // Note: Panic will stop the program immediately, so use with caution.

)

var (
        failfastLogger = shared.PackageLogger("FailFast::", "üö® FailFast::")
)

func Failfast(err error, level ErrorLevel, message string) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">pc, file, line, ok := runtime.Caller(1)
        if !ok </span><span class="cov0" title="0">{
                failfastLogger.Error("Failed to retrieve caller information: %v", err)
                return
        }</span>
        <span class="cov0" title="0">funcname := runtime.FuncForPC(pc).Name()
        logMsg := `
  üîß ERROR: %s
üìÑ FILE: %s
üìå LINE: %d
‚öôÔ∏è  FUNC: %s
üí• MSG: %s

        `
        failfastLogger.Error(logMsg, err, file, line, funcname, message)
        switch level </span>{
        case Ignore:<span class="cov0" title="0">
                failfastLogger.Info("Ignoring error as per configuration.")</span>
        case Warn:<span class="cov0" title="0">
                failfastLogger.Warn("Warning: %s", err)</span>
        case Error:<span class="cov0" title="0">
                failfastLogger.Error("Error: %s", err)
                os.Exit(1)</span>
        case Critical:<span class="cov0" title="0">
                failfastLogger.Error("Critical error: %s", err)
                os.Exit(1)</span>
        case Panic:<span class="cov0" title="0">
                panic(err)</span>
        }

}
</pre>
		
		<pre class="file" id="file38" style="display: none">package fs

import (
        "fmt"
        "os"
)

type FileWriter struct {
        force  bool
        dryRun bool
}

func NewFileWriter(force, dryRun bool) *FileWriter <span class="cov0" title="0">{
        return &amp;FileWriter{force: force, dryRun: dryRun}
}</span>

func (fw *FileWriter) Write(path string, content []byte) error <span class="cov0" title="0">{
        if _, err := os.Stat(path); err == nil &amp;&amp; !fw.force </span><span class="cov0" title="0">{
                fmt.Printf("! Skipped: %s already exists\n", path)
                return nil
        }</span>

        <span class="cov0" title="0">if fw.dryRun </span><span class="cov0" title="0">{
                fmt.Printf("‚úì Would create: %s\n", path)
                return nil
        }</span>

        <span class="cov0" title="0">err := os.WriteFile(path, content, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Printf("‚úì Created: %s\n", path)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package git

import (
        "bytes"
        "errors"
        "fmt"
        "os/exec"
        "strings"
)

type RepositoryInfo struct {
        CommitHash string
        BranchName string
        IsDirty    bool
}

func GetRepositoryInfo() (*RepositoryInfo, error) <span class="cov0" title="0">{
        hash, err := exec.Command("git", "rev-parse", "--short", "HEAD").Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">branch, err := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD").Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dirty, _ := exec.Command("git", "status", "--porcelain").Output()

        return &amp;RepositoryInfo{
                CommitHash: strings.TrimSpace(string(hash)),
                BranchName: strings.TrimSpace(string(branch)),
                IsDirty:    len(strings.TrimSpace(string(dirty))) &gt; 0,
        }, nil</span>
}

// GetCurrentBranch returns the name of the current Git branch in the working directory.
// Returns an error if the directory is not a Git repository or if the command fails.
func GetCurrentBranch() (string, error) <span class="cov0" title="0">{
        // Check if git is installed and available in PATH
        if _, err := exec.LookPath("git"); err != nil </span><span class="cov0" title="0">{
                return "", errors.New("git command not found")
        }</span>

        // Run git command to get the current branch
        <span class="cov0" title="0">cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("not a git repository or unable to get branch: " + err.Error())
        }</span>

        // Clean up the output (remove newlines and whitespace)
        <span class="cov0" title="0">branch := strings.TrimSpace(string(output))
        if branch == "" </span><span class="cov0" title="0">{
                return "", errors.New("could not determine current branch")
        }</span>

        <span class="cov0" title="0">return branch, nil</span>
}

// GetSecondLatestCommitHash returns the second latest commit hash in the current repository
func GetSecondLatestCommitHash() (string, error) <span class="cov0" title="0">{
        // Run git log command to get the last two commits
        cmd := exec.Command("git", "log", "--pretty=format:%H", "-n", "2")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get git log: %w", err)
        }</span>

        // Split the output by newlines to get individual commit hashes
        <span class="cov0" title="0">commits := strings.Split(strings.TrimSpace(string(output)), "\n")

        if len(commits) &lt; 2 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("not enough commits in repository (need at least 2, got %d)", len(commits))
        }</span>

        // The second commit is at index 1 (index 0 is the latest)
        <span class="cov0" title="0">return commits[1], nil</span>
}

// Alternative version using git rev-parse for better performance
func GetSecondLatestCommitHashAlt() (string, error) <span class="cov0" title="0">{
        // Get the parent of the latest commit (which would be the second latest)
        cmd := exec.Command("git", "rev-parse", "HEAD~1")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get parent commit: %w", err)
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}
func GetCommitHash() (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("git", "rev-parse", "--short=7", "HEAD")

        var out bytes.Buffer
        cmd.Stdout = &amp;out

        err := cmd.Run()

        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("git command failed: %w", err)
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(out.String()), nil</span>
}

func IsDirty() bool <span class="cov0" title="0">{
        cmd := exec.Command("git", "status", "--porcelain")

        var out bytes.Buffer

        cmd.Stdout = &amp;out
        _ = cmd.Run()
        return out.Len() &gt; 0
}</span>
func GetGitCommitHash() (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("git", "rev-parse", "HEAD")
        var out bytes.Buffer
        cmd.Stdout = &amp;out
        cmd.Stderr = &amp;out

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Failed to get Git commit hash: %v\n%s", err, out.String())
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(out.String()), nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">
package health

import (
        "context"
        "net/http"
        "time"
)

func CheckWithTimeout(url string, timeout time.Duration) bool <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()

        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return false</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        resp, err := http.Get(url)
                        if err == nil &amp;&amp; resp.StatusCode == 200 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package shared

import (
        "crypto/ecdsa"
        "github.com/golang-jwt/jwt/v5"
        "strings"

        "time"
)

// WSClaims represents the custom claims structure for WebSocket JWT tokens
type WSClaims struct {
        ClientID             string `json:"cid"`      // Client identifier
        SessionID            string `json:"sid"`      // Unique session ID
        Scope                string `json:"scope"`    // Authorization scope (e.g., "read:logs", "deploy")
        AgentID              string `json:"agent_id"` // Optional agent identifier
        jwt.RegisteredClaims        // Standard JWT claims
}

// JWTOptions configures token generation options
type JWTOptions struct {
        ExpiresIn time.Duration
        NotBefore time.Duration // Optional delay before token is valid
        Issuer    string        // Token issuer
        Audience  []string      // Intended audience
        Scope     string        // Access scope
        ClientIP  string        // Optional client IP for binding
}

func GenerateWSToken(privateKey *ecdsa.PrivateKey, clientID string, opts JWTOptions) (string, error) <span class="cov0" title="0">{
        if privateKey == nil </span><span class="cov0" title="0">{
                return "", ErrNilKey
        }</span>

        <span class="cov0" title="0">if clientID == "" </span><span class="cov0" title="0">{
                return "", ErrEmptyClientID
        }</span>
        <span class="cov0" title="0">now := time.Now()
        claims := WSClaims{
                ClientID:  clientID,
                SessionID: GenerateSessionID(),
                Scope:     opts.Scope,
                RegisteredClaims: jwt.RegisteredClaims{
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now.Add(opts.NotBefore)),
                        Issuer:    opts.Issuer,
                        Audience:  opts.Audience,
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodES256, claims)
        token.Header["kid"] = GenerateKeyFingerprint(&amp;privateKey.PublicKey)
        return token.SignedString(privateKey)</span>

}

func GenerateKeyFingerprint(publicKey *ecdsa.PublicKey) string <span class="cov0" title="0">{
        // Generate a unique fingerprint for the public key
        // This is a placeholder; actual implementation may vary based on your requirements
        return "fingerprint-" + publicKey.X.Text(16) + "-" + publicKey.Y.Text(16)
}</span>

// VerifyWSJWT validates and parses a WebSocket JWT token
func VerifyWSJWT(
        tokenString string,
        publicKey *ecdsa.PublicKey,
        expectedAudience string,
) (*WSClaims, error) <span class="cov0" title="0">{
        if publicKey == nil </span><span class="cov0" title="0">{
                return nil, ErrNilKey
        }</span>

        <span class="cov0" title="0">token, err := jwt.ParseWithClaims(tokenString, &amp;WSClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                // Validate algorithm
                if _, ok := token.Method.(*jwt.SigningMethodECDSA); !ok </span><span class="cov0" title="0">{
                        return nil, ErrInvalidSigningMethod
                }</span>

                // Optional: Verify key ID matches expected key
                <span class="cov0" title="0">if kid, ok := token.Header["kid"].(string); ok </span><span class="cov0" title="0">{
                        expectedKid := GenerateKeyFingerprint(publicKey)
                        if kid != expectedKid </span><span class="cov0" title="0">{
                                return nil, ErrKeyMismatch
                        }</span>
                }

                <span class="cov0" title="0">return publicKey, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*WSClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                // Validate audience if required
                if expectedAudience != "" </span><span class="cov0" title="0">{
                        if len(claims.Audience) == 0 || claims.Audience[0] != expectedAudience </span><span class="cov0" title="0">{
                                return nil, ErrInvalidAudience
                        }</span>

                }
                <span class="cov0" title="0">return claims, nil</span>
        }

        <span class="cov0" title="0">return nil, ErrInvalidToken</span>
}

func GenerateSessionID() string <span class="cov0" title="0">{
        // Generate a unique session ID (e.g., using UUID or random bytes)
        // For simplicity, we'll use a timestamp-based approach here

        return strings.ReplaceAll(time.Now().Format("20060102150405.000"), ".", "")

}</span>

func DeriveSessionKey(claims *WSClaims) (sessionKey []byte, err error) <span class="cov0" title="0">{
        // Derive a session key from the WebSocket JWT claims
        // This is a placeholder function; actual implementation would depend on your security requirements
        // For example, you might use HKDF or another key derivation function based on the JWT claims
        return
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package shared

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"
        "runtime"
        "strings"
        "sync"
        "time"
)

// LogLevel represents different log levels
type LogLevel int

const (
        LevelTrace LogLevel = iota
        LevelDebug
        LevelInfo
        LevelWarn
        LevelSuccess
        LevelError
        LevelFatal
)

var levelNames = map[LogLevel]string{
        LevelTrace:   "TRACE",
        LevelDebug:   "DEBUG",
        LevelInfo:    "INFO ",
        LevelWarn:    "WARN ",
        LevelError:   "ERROR",
        LevelFatal:   "FATAL",
        LevelSuccess: "GOOD ",
}

var levelColors = map[LogLevel]string{
        LevelTrace:   "\033[38;5;245m", // Gray
        LevelDebug:   "\033[38;5;14m",  // Bright Cyan
        LevelInfo:    "\033[38;5;12m",  // Bright Blue
        LevelWarn:    "\033[38;5;11m",  // Bright Yellow
        LevelError:   "\033[38;5;9m",   // Bright Red
        LevelFatal:   "\033[48;5;9m",   // Red background
        LevelSuccess: "\033[38;5;10m",  // Bright Green
}

var levelEmojis = map[LogLevel]string{
        LevelTrace:   "üîç",
        LevelDebug:   "üêû",
        LevelInfo:    "‚ÑπÔ∏è ",
        LevelWarn:    "‚ö†Ô∏è ",
        LevelError:   "üí•",
        LevelFatal:   "‚ò†Ô∏è ",
        LevelSuccess: "‚ú®",
}

var levelBanners = map[LogLevel]string{
        LevelTrace:   "‚ñÅ‚ñÅ‚ñÅ‚ñÅ‚ñÅ",
        LevelDebug:   "‚ñÇ‚ñÇ‚ñÇ‚ñÇ‚ñÇ",
        LevelInfo:    "‚ñÉ‚ñÉ‚ñÉ‚ñÉ‚ñÉ",
        LevelWarn:    "‚ñÖ‚ñÖ‚ñÖ‚ñÖ‚ñÖ",
        LevelError:   "‚ñÜ‚ñÜ‚ñÜ‚ñÜ‚ñÜ",
        LevelFatal:   "‚ñá‚ñá‚ñá‚ñá‚ñá",
        LevelSuccess: "‚ñî‚ñî‚ñî‚ñî‚ñî",
}

// Logger is the main logger struct
type Logger struct {
        mu            sync.Mutex
        minLevel      LogLevel
        logger        *log.Logger
        showCaller    bool
        showTimestamp bool
        showBanner    bool
        packageMap    map[string]string
        colorEnabled  bool
        timeFormat    string
        indentLevel   int
}

// New creates a new Logger instance
func New(out io.Writer, prefix string, flag int, minLevel LogLevel) *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                minLevel:      minLevel,
                logger:        log.New(out, prefix, 0), // We handle flags ourselves
                showCaller:    true,
                showTimestamp: true,
                showBanner:    true,
                packageMap:    make(map[string]string),
                colorEnabled:  true,
                timeFormat:    "2006-01-02 15:04:05.000",
        }
}</span>

// DefaultLogger creates a logger with default settings
func DefaultLogger() *Logger <span class="cov0" title="0">{
        return New(os.Stdout, "", 0, LevelDebug)
}</span>

// SetLevel sets the minimum log level
func (l *Logger) SetLevel(level LogLevel) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.minLevel = level
}</span>

// SetOutput sets the output destination
func (l *Logger) SetOutput(w io.Writer) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.logger.SetOutput(w)
}</span>

// EnableCallerInfo enables/disables caller information
func (l *Logger) EnableCallerInfo(enable bool) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.showCaller = enable
}</span>

// EnableTimestamp enables/disables timestamp
func (l *Logger) EnableTimestamp(enable bool) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.showTimestamp = enable
}</span>

// EnableBanner enables/disables the level banner
func (l *Logger) EnableBanner(enable bool) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.showBanner = enable
}</span>

// EnableColor enables/disables color output
func (l *Logger) EnableColor(enable bool) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.colorEnabled = enable
}</span>

// SetTimeFormat sets the timestamp format (default: "2006-01-02 15:04:05.000")
func (l *Logger) SetTimeFormat(format string) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.timeFormat = format
}</span>

// RegisterPackage registers a package with a custom emoji/name
func (l *Logger) RegisterPackage(pkg string, displayName string) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.packageMap[pkg] = displayName
}</span>

// Indent increases the indentation level
func (l *Logger) Indent() *Logger <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()
        return &amp;Logger{
                minLevel:      l.minLevel,
                logger:        l.logger,
                showCaller:    l.showCaller,
                showTimestamp: l.showTimestamp,
                showBanner:    l.showBanner,
                packageMap:    l.packageMap,
                colorEnabled:  l.colorEnabled,
                timeFormat:    l.timeFormat,
                indentLevel:   l.indentLevel + 1,
        }
}</span>

// Log logs a message at a specific level
func (l *Logger) Log(level LogLevel, msg string, args ...interface{}) <span class="cov0" title="0">{
        if level &lt; l.minLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.mu.Lock()
        defer l.mu.Unlock()

        var callerInfo string
        if l.showCaller </span><span class="cov0" title="0">{
                // Get caller info (file and line number)
                _, file, line, ok := runtime.Caller(2) // 2 levels up the stack
                if ok </span><span class="cov0" title="0">{
                        // Shorten file path
                        parts := strings.Split(file, "/")
                        if len(parts) &gt; 3 </span><span class="cov0" title="0">{
                                file = strings.Join(parts[len(parts)-3:], "/")
                        }</span>
                        <span class="cov0" title="0">callerInfo = fmt.Sprintf("%s:%d", file, line)</span>
                }
        }

        // Get package display name if registered
        <span class="cov0" title="0">var pkgDisplay string
        if l.logger.Prefix() != "" </span><span class="cov0" title="0">{
                if display, exists := l.packageMap[l.logger.Prefix()]; exists </span><span class="cov0" title="0">{
                        pkgDisplay = display + " "
                }</span>
        }

        // Format the log message
        <span class="cov0" title="0">levelName := levelNames[level]
        levelColor := levelColors[level]
        levelEmoji := levelEmojis[level]
        levelBanner := levelBanners[level]
        resetColor := "\033[0m"

        if !l.colorEnabled </span><span class="cov0" title="0">{
                levelColor = ""
                resetColor = ""
        }</span>

        <span class="cov0" title="0">formattedMsg := fmt.Sprintf(msg, args...)

        // Add indentation
        indent := strings.Repeat("  ", l.indentLevel)
        formattedMsg = indent + strings.Replace(formattedMsg, "\n", "\n"+indent, -1)

        var logLine strings.Builder

        // Timestamp
        if l.showTimestamp </span><span class="cov0" title="0">{
                logLine.WriteString(fmt.Sprintf("\033[90m%s\033[0m ", time.Now().Format(l.timeFormat)))
        }</span>

        // Level banner
        <span class="cov0" title="0">if l.showBanner </span><span class="cov0" title="0">{
                logLine.WriteString(fmt.Sprintf("%s%s%s ", levelColor, levelBanner, resetColor))
        }</span>

        // Level info
        <span class="cov0" title="0">logLine.WriteString(fmt.Sprintf("%s%s%s %s ", levelColor, levelName, resetColor, levelEmoji))

        // Package display
        if pkgDisplay != "" </span><span class="cov0" title="0">{
                logLine.WriteString(fmt.Sprintf("%s", pkgDisplay))
        }</span>

        // Message
        <span class="cov0" title="0">logLine.WriteString(formattedMsg)

        // Caller info
        if callerInfo != "" </span><span class="cov0" title="0">{
                logLine.WriteString(fmt.Sprintf(" \033[90m(%s)\033[0m", callerInfo))
        }</span>

        <span class="cov0" title="0">l.logger.Println(logLine.String())</span>
}

// Trace logs a trace message (most verbose)
func (l *Logger) Trace(msg string, args ...interface{}) <span class="cov0" title="0">{
        l.Log(LevelTrace, msg, args...)
}</span>

// Debug logs a debug message
func (l *Logger) Debug(msg string, args ...interface{}) <span class="cov0" title="0">{
        l.Log(LevelDebug, msg, args...)
}</span>

// Info logs an info message
func (l *Logger) Info(msg string, args ...interface{}) <span class="cov0" title="0">{
        l.Log(LevelInfo, msg, args...)
}</span>

// Warn logs a warning message
func (l *Logger) Warn(msg string, args ...interface{}) <span class="cov0" title="0">{
        l.Log(LevelWarn, msg, args...)
}</span>

// Error logs an error message
func (l *Logger) Error(msg string, args ...interface{}) <span class="cov0" title="0">{
        l.Log(LevelError, msg, args...)
}</span>

// Fatal logs a fatal message and exits
func (l *Logger) Fatal(msg string, args ...interface{}) <span class="cov0" title="0">{
        l.Log(LevelFatal, msg, args...)
        os.Exit(1)
}</span>

// Success logs a success message
func (l *Logger) Success(msg string, args ...interface{}) <span class="cov0" title="0">{
        l.Log(LevelSuccess, msg, args...)
}</span>

// WithPrefix returns a new Logger with the specified prefix
func (l *Logger) WithPrefix(prefix string) *Logger <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        newLogger := &amp;Logger{
                minLevel:      l.minLevel,
                logger:        log.New(l.logger.Writer(), prefix, 0),
                showCaller:    l.showCaller,
                showTimestamp: l.showTimestamp,
                showBanner:    l.showBanner,
                packageMap:    make(map[string]string),
                colorEnabled:  l.colorEnabled,
                timeFormat:    l.timeFormat,
        }

        // Copy the package map
        for k, v := range l.packageMap </span><span class="cov0" title="0">{
                newLogger.packageMap[k] = v
        }</span>

        <span class="cov0" title="0">return newLogger</span>
}

// PackageLogger creates a logger with package-specific settings
func PackageLogger(pkgName string, displayName string) *Logger <span class="cov0" title="0">{
        logger := DefaultLogger()
        logger.RegisterPackage(pkgName, displayName)
        return logger.WithPrefix(pkgName)
}</span>

// Timed logs the duration of a function execution with a spinner animation
func (l *Logger) Timed(label string, fn func()) <span class="cov0" title="0">{
        start := time.Now()
        done := make(chan bool)

        go func() </span><span class="cov0" title="0">{
                spinner := []string{"‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è"}
                i := 0
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-done:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                l.mu.Lock()
                                levelColor := levelColors[LevelInfo]
                                resetColor := "\033[0m"
                                if !l.colorEnabled </span><span class="cov0" title="0">{
                                        levelColor = ""
                                        resetColor = ""
                                }</span>
                                <span class="cov0" title="0">msg := fmt.Sprintf("%s%s%s %s %s...", levelColor, levelNames[LevelInfo], resetColor, spinner[i], label)
                                if l.showTimestamp </span><span class="cov0" title="0">{
                                        msg = fmt.Sprintf("\033[90m%s\033[0m %s", time.Now().Format(l.timeFormat), msg)
                                }</span>
                                <span class="cov0" title="0">l.logger.Print("\r" + msg)
                                l.mu.Unlock()
                                i = (i + 1) % len(spinner)
                                time.Sleep(100 * time.Millisecond)</span>
                        }
                }
        }()

        <span class="cov0" title="0">fn()
        close(done)

        // Clear the spinner line
        l.logger.Print("\r\033[K")

        duration := time.Since(start)
        l.Info("%s completed in %s", label, duration)</span>
}

// JSON logs data in pretty-printed JSON format
func (l *Logger) JSON(level LogLevel, data interface{}) <span class="cov0" title="0">{
        if level &lt; l.minLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">jsonData, err := json.MarshalIndent(data, strings.Repeat("  ", l.indentLevel), "  ")
        if err != nil </span><span class="cov0" title="0">{
                l.Error("Failed to marshal JSON: %v", err)
                return
        }</span>

        <span class="cov0" title="0">fmtattedJSON := string(jsonData)
        fmt.Println("" + fmtattedJSON)</span>

}

// Table logs tabular data
func (l *Logger) Table(level LogLevel, headers []string, rows [][]string) <span class="cov0" title="0">{
        if level &lt; l.minLevel </span><span class="cov0" title="0">{
                return
        }</span>

        // Calculate column widths
        <span class="cov0" title="0">colWidths := make([]int, len(headers))
        for i, h := range headers </span><span class="cov0" title="0">{
                colWidths[i] = len(h)
        }</span>

        <span class="cov0" title="0">for _, row := range rows </span><span class="cov0" title="0">{
                for i, cell := range row </span><span class="cov0" title="0">{
                        if len(cell) &gt; colWidths[i] </span><span class="cov0" title="0">{
                                colWidths[i] = len(cell)
                        }</span>
                }
        }

        // Build the table
        <span class="cov0" title="0">var table strings.Builder

        // Header
        table.WriteString("\n")
        for i, h := range headers </span><span class="cov0" title="0">{
                table.WriteString(fmt.Sprintf(" %-*s ", colWidths[i], h))
                if i &lt; len(headers)-1 </span><span class="cov0" title="0">{
                        table.WriteString("‚îÇ")
                }</span>
        }

        // Separator
        <span class="cov0" title="0">table.WriteString("\n")
        for i, w := range colWidths </span><span class="cov0" title="0">{
                table.WriteString(strings.Repeat("‚îÄ", w+2))
                if i &lt; len(colWidths)-1 </span><span class="cov0" title="0">{
                        table.WriteString("‚îº")
                }</span>
        }
        <span class="cov0" title="0">table.WriteString("\n")

        // Rows
        for _, row := range rows </span><span class="cov0" title="0">{
                for i, cell := range row </span><span class="cov0" title="0">{
                        table.WriteString(fmt.Sprintf(" %-*s ", colWidths[i], cell))
                        if i &lt; len(row)-1 </span><span class="cov0" title="0">{
                                table.WriteString("‚îÇ")
                        }</span>
                }
                <span class="cov0" title="0">table.WriteString("\n")</span>
        }

        <span class="cov0" title="0">l.Info("%s", table.String())</span>

}

// Progress creates a progress bar
func (l *Logger) Progress(level LogLevel, current, total int, label string) <span class="cov0" title="0">{
        if level &lt; l.minLevel </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">const barWidth = 30
        progress := float64(current) / float64(total)
        filled := int(barWidth * progress)

        bar := strings.Repeat("‚ñà", filled) + strings.Repeat("‚ñë", barWidth-filled)

        levelColor := levelColors[level]
        resetColor := "\033[0m"
        if !l.colorEnabled </span><span class="cov0" title="0">{
                levelColor = ""
                resetColor = ""
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("%s [%s] %3.0f%% %s", label, bar, progress*100, levelEmojis[level])

        l.mu.Lock()
        defer l.mu.Unlock()

        var logLine strings.Builder

        if l.showTimestamp </span><span class="cov0" title="0">{
                logLine.WriteString(fmt.Sprintf("\033[90m%s\033[0m ", time.Now().Format(l.timeFormat)))
        }</span>

        <span class="cov0" title="0">logLine.WriteString(fmt.Sprintf("%s%s%s %s %s",
                levelColor, levelNames[level], resetColor,
                levelEmojis[level], msg))

        l.logger.Print("\r" + logLine.String())
        if current &gt;= total </span><span class="cov0" title="0">{
                l.logger.Println()
        }</span>
}

// package main
//
// import (
//         "os"
//         "time"
//         "yourmodulepath/shared"
// )
//
// func main() {
//         // Create and configure logger
//         logger := shared.DefaultLogger()
//         logger.SetLevel(shared.LevelDebug)
//         logger.RegisterPackage("main", "üèÅ MAIN")
//
//         // Basic logging
//         logger.Info("Application starting")
//
//         // Package-specific logging
//         dbLogger := shared.PackageLogger("database", "üì¶ DB")
//         apiLogger := shared.PackageLogger("api", "üåê API")
//
//         dbLogger.Info("Connecting to database...")
//         apiLogger.Info("Starting HTTP server...")
//
//         // Timed operation
//         logger.Timed("Data processing", func() {
//                 time.Sleep(1 * time.Second)
//                 indented := logger.Indent()
//                 indented.Info("Processing chunk 1")
//                 time.Sleep(500 * time.Millisecond)
//                 indented.Info("Processing chunk 2")
//         })
//
//         // JSON logging
//         config := map[string]interface{}{
//                 "env":     "production",
//                 "version": "1.2.3",
//                 "ports":   []int{8080, 8081},
//         }
//         logger.JSON(shared.LevelDebug, config)
//
//         // Table logging
//         headers := []string{"ID", "Name", "Status"}
//         rows := [][]string{
//                 {"1", "Service A", "OK"},
//                 {"2", "Service B", "WARNING"},
//                 {"3", "Service C", "ERROR"},
//         }
//         logger.Table(shared.LevelInfo, headers, rows)
//
//         // Progress bar
//         logger.Info("Processing items:")
//         total := 25
//         for i := 0; i &lt;= total; i++ {
//                 logger.Progress(shared.LevelInfo, i, total, "Items")
//                 time.Sleep(100 * time.Millisecond)
//         }
//
//         logger.Success("All operations completed successfully!")
// }
</pre>
		
		<pre class="file" id="file43" style="display: none">package shared

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "time"
)

type SecureMessage struct {
        IV         []byte `json:"iv"`
        Ciphertext []byte `json:"ciphertext"`
        Tag        []byte `json:"tag"`
        Sequence   uint64 `json:"sequence"`
        Timestamp  int64  `json:"timestamp"`
}

type MessageHeader struct {
        Type      string `json:"type"`
        SessionID string `json:"session_id"`
}

func EncryptMessage(key []byte, sequence uint64, payload interface{}) ([]byte, error) <span class="cov0" title="0">{
        // Serialize payload
        payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal payload: %w", err)
        }</span>

        // Create AES-GCM cipher
        <span class="cov0" title="0">block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // Generate nonce
        <span class="cov0" title="0">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate nonce: %w", err)
        }</span>

        // Encrypt data
        <span class="cov0" title="0">ciphertext := gcm.Seal(nil, nonce, payloadBytes, nil)

        // Split ciphertext and tag
        tagStart := len(ciphertext) - gcm.Overhead()
        msg := SecureMessage{
                IV:         nonce,
                Ciphertext: ciphertext[:tagStart],
                Tag:        ciphertext[tagStart:],
                Sequence:   sequence,
                Timestamp:  time.Now().Unix(),
        }

        return json.Marshal(msg)</span>
}

func DecryptMessage(key []byte, data []byte) ([]byte, uint64, error) <span class="cov0" title="0">{
        var msg SecureMessage
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to unmarshal message: %w", err)
        }</span>

        // Verify timestamp (prevent replay)
        <span class="cov0" title="0">if time.Since(time.Unix(msg.Timestamp, 0)) &gt; 30*time.Second </span><span class="cov0" title="0">{
                return nil, 0, errors.New("message too old")
        }</span>

        // Reconstruct ciphertext
        <span class="cov0" title="0">fullCiphertext := append(msg.Ciphertext, msg.Tag...)

        // Create AES-GCM cipher
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        // Decrypt data
        <span class="cov0" title="0">plaintext, err := gcm.Open(nil, msg.IV, fullCiphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("decryption failed: %w", err)
        }</span>

        <span class="cov0" title="0">return plaintext, msg.Sequence, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package nextcore

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
)

func SendFakeData() error <span class="cov0" title="0">{
        data := map[string]interface{}{
                "app_name":     "contextbytes",
                "framework":    "Next.js",
                "build_target": "static",
                "env": []string{
                        "NODE_ENV=production",
                        "PORT=3000",
                },
                "domains": []string{
                        "app.contextbytes.com",
                },
        }

        payload, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal error: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := http.Post("http://127.0.0.1:8371/nextcore/intake", "application/json", bytes.NewBuffer(payload))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("post failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        fmt.Println("üì§ Sent fake NextCore data to daemon. Status:", resp.Status)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package nextcore

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
)

func CollectBuildMetadata() (*NextBuildMetadata, error) <span class="cov0" title="0">{
        projectDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">NextCoreLogger.Debug("Build the next to generate build metadata")
        PackageManager, err := DetectPackageManager(projectDir)
        if err != nil </span><span class="cov0" title="0">{
                PackageManager = "npm"
        }</span>
        <span class="cov0" title="0">buildCommand, err := buildCommand(string(PackageManager))
        if err != nil </span><span class="cov0" title="0">{
                PackageManager = "npm"
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(".nextdeploy", 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create .nextdeploy directory: %w", err)
        }</span>
        <span class="cov0" title="0">cmd := exec.Command("sh", "-c", buildCommand.String())
        cmd.Dir = projectDir
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stdout

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("build failed:%w", err)
        }</span>

        <span class="cov0" title="0">nextDir := filepath.Join(projectDir, ".next")
        buildID, err := os.ReadFile(filepath.Join(nextDir, "BUILD_ID"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("faileed to read BUILD_ID:%s", err)
        }</span>
        <span class="cov0" title="0">readJSON := func(filename string) (interface{}, error) </span><span class="cov0" title="0">{
                data, err := os.ReadFile(filepath.Join(nextDir, filename))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">var result interface{}
                if err := json.Unmarshal(data, &amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return result, nil</span>
        }

        // Collect all manifests
        <span class="cov0" title="0">buildManifest, _ := readJSON("build-manifest.json")
        appBuildManifest, _ := readJSON("app-build-manifest.json")
        prerenderManifest, _ := readJSON("prerender-manifest.json")
        routesManifest, _ := readJSON("routes-manifest.json")
        imagesManifest, _ := readJSON("images-manifest.json")
        appPathRoutesManifest, _ := readJSON("app-path-routes-manifest.json")
        reactLoadableManifest, _ := readJSON("react-loadable-manifest.json")
        var diagnostics []string
        diagnosticsDir := filepath.Join(nextDir, "diagnostics")
        if files, err := os.ReadDir(diagnosticsDir); err != nil </span><span class="cov0" title="0">{
                for _, file := range files </span><span class="cov0" title="0">{
                        diagnostics = append(diagnostics, file.Name())
                }</span>
        }

        <span class="cov0" title="0">return &amp;NextBuildMetadata{
                BuildID:               string(buildID),
                BuildManifest:         buildManifest,
                AppBuildManifest:      appBuildManifest,
                PrerenderManifest:     prerenderManifest,
                RoutesManifest:        routesManifest,
                ImagesManifest:        imagesManifest,
                AppPathRoutesManifest: appPathRoutesManifest,
                ReactLoadableManifest: reactLoadableManifest,
                Diagnostics:           diagnostics,
        }, nil</span>

}
</pre>
		
		<pre class="file" id="file46" style="display: none">package nextcore

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

// ParseNextConfig dynamically reads and parses Next.js configuration files

// extractConfigObject extracts the Next.js config object from file content
func extractConfigObject(content string) (map[string]interface{}, error) <span class="cov0" title="0">{
        // First try to find explicit nextConfig declaration
        if configStr, err := extractExplicitConfig(content); err == nil </span><span class="cov0" title="0">{
                return parseConfigString(configStr)
        }</span>

        // Fallback to extracting exported object
        <span class="cov0" title="0">if configStr, err := extractExportedConfig(content); err == nil </span><span class="cov0" title="0">{
                return parseConfigString(configStr)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("could not find valid config object in content")</span>
}

// extractExplicitConfig finds const nextConfig = {...} declarations
func extractExplicitConfig(content string) (string, error) <span class="cov0" title="0">{
        // Find the start of the config object
        start := strings.Index(content, "const nextConfig =")
        if start == -1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("nextConfig declaration not found")
        }</span>

        // Find the opening brace
        <span class="cov0" title="0">openBrace := strings.Index(content[start:], "{")
        if openBrace == -1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("config object not properly formatted")
        }</span>
        <span class="cov0" title="0">openBrace += start

        // Find matching closing brace
        configContent, err := extractBalancedBraces(content[openBrace:])
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to extract balanced braces from config content: %s", err)
                return "", fmt.Errorf("failed to extract config object: %w", err)
        }</span>

        <span class="cov0" title="0">return normalizeToJSON(configContent), nil</span>
}

// extractExportedConfig finds module.exports or export default
func extractExportedConfig(content string) (string, error) <span class="cov0" title="0">{
        patterns := []*regexp.Regexp{
                regexp.MustCompile(`module\.exports\s*=\s*({[\s\S]*?})\s*;`),
                regexp.MustCompile(`export\s+default\s*({[\s\S]*?})\s*;`),
        }

        for _, re := range patterns </span><span class="cov0" title="0">{
                if matches := re.FindStringSubmatch(content); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        return normalizeToJSON(matches[1]), nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no exported config found")</span>
}

// extractBalancedBraces extracts content between balanced braces
func extractBalancedBraces(content string) (string, error) <span class="cov0" title="0">{
        braceCount := 1
        closeBrace := 1
        for ; closeBrace &lt; len(content) &amp;&amp; braceCount &gt; 0; closeBrace++ </span><span class="cov0" title="0">{
                switch content[closeBrace] </span>{
                case '{':<span class="cov0" title="0">
                        braceCount++</span>
                case '}':<span class="cov0" title="0">
                        braceCount--</span>
                }
        }

        <span class="cov0" title="0">if braceCount != 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unbalanced braces in config object")
        }</span>

        <span class="cov0" title="0">return content[:closeBrace], nil</span>
}

// normalizeToJSON converts JavaScript object to JSON-compatible format
func normalizeToJSON(js string) string <span class="cov0" title="0">{
        // Normalize whitespace
        js = strings.ReplaceAll(js, "\r\n", "\n")
        js = strings.ReplaceAll(js, "\t", " ")
        js = strings.ReplaceAll(js, "\n", "\\n")

        // Strip comments
        js = stripComments(js)

        // Normalize quotes
        js = strings.ReplaceAll(js, "`", `"`)
        js = strings.ReplaceAll(js, `'`, `"`)

        // Remove trailing commas
        js = regexp.MustCompile(`,\s*([}\]])`).ReplaceAllString(js, "$1")

        // Quote unquoted keys
        js = regexp.MustCompile(`([{\[,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:`).ReplaceAllString(js, `$1"$2":`)

        // Escape function bodies into strings
        js = escapeFunctions(js)

        return js
}</span>

func stripComments(code string) string <span class="cov0" title="0">{
        // Multi-line
        code = regexp.MustCompile(`/\*[\s\S]*?\*/`).ReplaceAllString(code, "")
        // Single-line
        code = regexp.MustCompile(`(?m)//.*$`).ReplaceAllString(code, "")
        return code
}</span>

func escapeFunctions(js string) string <span class="cov0" title="0">{
        // Arrow functions: webpack: (x) =&gt; {...}
        arrowFn := regexp.MustCompile(`(\b(?:webpack|experimental|config)\b\s*:\s*)\([^)]*\)\s*=&gt;\s*{[^}]*}`)
        js = arrowFn.ReplaceAllStringFunc(js, func(match string) string </span><span class="cov0" title="0">{
                parts := strings.SplitN(match, ":", 2)
                escaped := strings.ReplaceAll(parts[1], `"`, `\"`)
                return parts[0] + `: "` + strings.TrimSpace(escaped) + `"`
        }</span>)

        // Regular functions: webpack: function(x) {...}
        <span class="cov0" title="0">regFn := regexp.MustCompile(`(\b(?:webpack|experimental|config)\b\s*:\s*)function\s*\([^)]*\)\s*{[^}]*}`)
        js = regFn.ReplaceAllStringFunc(js, func(match string) string </span><span class="cov0" title="0">{
                parts := strings.SplitN(match, ":", 2)
                escaped := strings.ReplaceAll(parts[1], `"`, `\"`)
                return parts[0] + `: "` + strings.TrimSpace(escaped) + `"`
        }</span>)

        <span class="cov0" title="0">return js</span>
}

// parseConfigString parses normalized JSON config string
func parseConfigString(configStr string) (map[string]interface{}, error) <span class="cov0" title="0">{
        var result map[string]interface{}
        if err := json.Unmarshal([]byte(configStr), &amp;result); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to parse config JSON: %s", err)
                return nil, fmt.Errorf("failed to parse config JSON: %w", err)
        }</span>

        // Unescape function strings
        <span class="cov0" title="0">for k, v := range result </span><span class="cov0" title="0">{
                if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                        if strings.Contains(str, "function") || strings.Contains(str, "=&gt;") </span><span class="cov0" title="0">{
                                // Unescape newlines and quotes
                                unescaped := strings.ReplaceAll(str, "\\n", "\n")
                                unescaped = strings.ReplaceAll(unescaped, "\\\"", "\"")
                                result[k] = unescaped
                        }</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// transpileTypeScriptConfig removes TypeScript-specific syntax
func transpileTypeScriptConfig(content string) string <span class="cov0" title="0">{
        // Remove type annotations
        content = regexp.MustCompile(`(?m)^\s*\/\*\*.*?\*\/\s*$`).ReplaceAllString(content, "")
        content = regexp.MustCompile(`:\s*\w+\s*([,;}])`).ReplaceAllString(content, "$1")

        // Remove import statements
        content = regexp.MustCompile(`(?m)^\s*import\s+.*?;\s*$`).ReplaceAllString(content, "")

        return content
}</span>

// parseEdgeRegions extracts edge regions from config content
func parseEdgeRegions(content string) []string <span class="cov0" title="0">{
        regionsRegex := regexp.MustCompile(`regions:\s*(\[[^\]]+\])`)
        matches := regionsRegex.FindStringSubmatch(content)
        if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                cleaned := strings.ReplaceAll(matches[1], "'", `"`)
                var regions []string
                if err := json.Unmarshal([]byte(cleaned), &amp;regions); err == nil </span><span class="cov0" title="0">{
                        return regions
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// parseConfigObject converts raw config map to structured NextConfig
func parseConfigObject(config map[string]interface{}) (*NextConfig, error) <span class="cov0" title="0">{
        result := &amp;NextConfig{
                Env:                 make(map[string]string),
                PublicRuntimeConfig: make(map[string]interface{}),
                ServerRuntimeConfig: make(map[string]interface{}),
        }

        // Helper functions to safely extract values
        getString := func(key string) string </span><span class="cov0" title="0">{
                if val, ok := config[key].(string); ok </span><span class="cov0" title="0">{
                        return val
                }</span>
                <span class="cov0" title="0">return ""</span>
        }

        <span class="cov0" title="0">getBool := func(key string) bool </span><span class="cov0" title="0">{
                if val, ok := config[key].(bool); ok </span><span class="cov0" title="0">{
                        return val
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">if webpack, ok := config["webpack"]; ok </span><span class="cov0" title="0">{
                if webpackStr, ok := webpack.(string); ok &amp;&amp; webpackStr == "webpack_function" </span><span class="cov0" title="0">{
                        // This was a function we converted to a string
                        result.Webpack = nil
                }</span> else<span class="cov0" title="0"> {
                        result.Webpack = webpack
                }</span>
        }

        <span class="cov0" title="0">getStringSlice := func(key string) []string </span><span class="cov0" title="0">{
                if arr, ok := config[key].([]interface{}); ok </span><span class="cov0" title="0">{
                        var result []string
                        for _, v := range arr </span><span class="cov0" title="0">{
                                if s, ok := v.(string); ok </span><span class="cov0" title="0">{
                                        result = append(result, s)
                                }</span>
                        }
                        <span class="cov0" title="0">return result</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        // Parse basic configuration
        <span class="cov0" title="0">result.BasePath = getString("basePath")
        result.Output = getString("output")
        result.ReactStrictMode = getBool("reactStrictMode")
        result.PoweredByHeader = getBool("poweredByHeader")
        result.TrailingSlash = getBool("trailingSlash")
        result.PageExtensions = getStringSlice("pageExtensions")
        result.AssetPrefix = getString("assetPrefix")
        result.DistDir = getString("distDir")
        result.CleanDistDir = getBool("cleanDistDir")
        result.GenerateBuildId = config["generateBuildId"]
        result.OnDemandEntries = toMap(config["onDemandEntries"])
        result.CompileOptions = toMap(config["compileOptions"])
        result.SkipMiddlewareUrlNormalize = getBool("skipMiddlewareUrlNormalize")
        result.SkipTrailingSlashRedirect = getBool("skipTrailingSlashRedirect")
        result.Webpack5 = getBool("webpack5")
        result.AnalyticsId = getString("analyticsId")
        result.MdxRs = getBool("mdxRs")
        result.EdgeRuntime = getString("edgeRuntime")

        // Parse nested configurations
        if images, ok := config["images"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                result.Images = &amp;ImageConfig{
                        Domains:               getStringSliceFromMap(images, "domains"),
                        Formats:               getStringSliceFromMap(images, "formats"),
                        DeviceSizes:           getIntSliceFromMap(images, "deviceSizes"),
                        ImageSizes:            getIntSliceFromMap(images, "imageSizes"),
                        Path:                  getStringFromMap(images, "path"),
                        Loader:                getStringFromMap(images, "loader"),
                        LoaderFile:            getStringFromMap(images, "loaderFile"),
                        MinimumCacheTTL:       getIntFromMap(images, "minimumCacheTTL"),
                        Unoptimized:           getBoolFromMap(images, "unoptimized"),
                        ContentSecurityPolicy: getStringFromMap(images, "contentSecurityPolicy"),
                }
                if patterns, ok := images["remotePatterns"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, p := range patterns </span><span class="cov0" title="0">{
                                if pattern, ok := p.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        result.Images.RemotePatterns = append(result.Images.RemotePatterns, ImageRemotePattern{
                                                Protocol: getStringFromMap(pattern, "protocol"),
                                                Hostname: getStringFromMap(pattern, "hostname"),
                                                Port:     getStringFromMap(pattern, "port"),
                                                Pathname: getStringFromMap(pattern, "pathname"),
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if experimental, ok := config["experimental"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                result.Experimental = &amp;ExperimentalConfig{
                        AppDir:                            getBoolFromMap(experimental, "appDir"),
                        CaseSensitiveRoutes:               getBoolFromMap(experimental, "caseSensitiveRoutes"),
                        UseDeploymentId:                   getBoolFromMap(experimental, "useDeploymentId"),
                        UseDeploymentIdServerActions:      getBoolFromMap(experimental, "useDeploymentIdServerActions"),
                        DeploymentId:                      getStringFromMap(experimental, "deploymentId"),
                        ServerComponents:                  getBoolFromMap(experimental, "serverComponents"),
                        ServerActions:                     getBoolFromMap(experimental, "serverActions"),
                        ServerActionsBodySizeLimit:        getIntFromMap(experimental, "serverActionsBodySizeLimit"),
                        OptimizeCss:                       getBoolFromMap(experimental, "optimizeCss"),
                        OptimisticClientCache:             getBoolFromMap(experimental, "optimisticClientCache"),
                        ClientRouterFilter:                getBoolFromMap(experimental, "clientRouterFilter"),
                        ClientRouterFilterRedirects:       getBoolFromMap(experimental, "clientRouterFilterRedirects"),
                        ClientRouterFilterAllowedRate:     getFloat64FromMap(experimental, "clientRouterFilterAllowedRate"),
                        ExternalDir:                       getStringFromMap(experimental, "externalDir"),
                        ExternalMiddlewareRewritesResolve: getBoolFromMap(experimental, "externalMiddlewareRewritesResolve"),
                        FallbackNodePolyfills:             getBoolFromMap(experimental, "fallbackNodePolyfills"),
                        ForceSwcTransforms:                getBoolFromMap(experimental, "forceSwcTransforms"),
                        FullySpecified:                    getBoolFromMap(experimental, "fullySpecified"),
                        SwcFileReading:                    getBoolFromMap(experimental, "swcFileReading"),
                        SwcMinify:                         getBoolFromMap(experimental, "swcMinify"),
                        SwcPlugins:                        toSlice(experimental["swcPlugins"]),
                        SwcTraceProfiling:                 getBoolFromMap(experimental, "swcTraceProfiling"),
                        Turbo:                             toMap(experimental["turbo"]),
                        Turbotrace:                        toMap(experimental["turbotrace"]),
                        ScrollRestoration:                 getBoolFromMap(experimental, "scrollRestoration"),
                        NewNextLinkBehavior:               getBoolFromMap(experimental, "newNextLinkBehavior"),
                        ManualClientBasePath:              getBoolFromMap(experimental, "manualClientBasePath"),
                        LegacyBrowsers:                    getBoolFromMap(experimental, "legacyBrowsers"),
                        DisableOptimizedLoading:           getBoolFromMap(experimental, "disableOptimizedLoading"),
                        GzipSize:                          getBoolFromMap(experimental, "gzipSize"),
                        SharedPool:                        getBoolFromMap(experimental, "sharedPool"),
                        WebVitalsAttribution:              getStringSliceFromMap(experimental, "webVitalsAttribution"),
                        InstrumentationHook:               getStringFromMap(experimental, "instrumentationHook"),
                }
        }</span>

        <span class="cov0" title="0">if i18n, ok := config["i18n"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                var domains []Domain
                if i18nDomains, ok := i18n["domains"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, d := range i18nDomains </span><span class="cov0" title="0">{
                                if domain, ok := d.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        domains = append(domains, Domain{
                                                Domain:        getStringFromMap(domain, "domain"),
                                                Locales:       getStringSliceFromMap(domain, "locales"),
                                                DefaultLocale: getStringFromMap(domain, "defaultLocale"),
                                        })
                                }</span>
                        }
                }
                <span class="cov0" title="0">result.I18n = &amp;I18nConfig{
                        Locales:         getStringSliceFromMap(i18n, "locales"),
                        DefaultLocale:   getStringFromMap(i18n, "defaultLocale"),
                        Domains:         domains,
                        LocaleDetection: getBoolFromMap(i18n, "localeDetection"),
                }</span>
        }

        // Parse other sections
        <span class="cov0" title="0">if env, ok := config["env"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for k, v := range env </span><span class="cov0" title="0">{
                        if s, ok := v.(string); ok </span><span class="cov0" title="0">{
                                result.Env[k] = s
                        }</span>
                }
        }

        <span class="cov0" title="0">if headers, ok := config["headers"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.Headers = headers
        }</span>

        <span class="cov0" title="0">if redirects, ok := config["redirects"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.Redirects = redirects
        }</span>

        <span class="cov0" title="0">if rewrites, ok := config["rewrites"].([]interface{}); ok </span><span class="cov0" title="0">{
                result.Rewrites = rewrites
        }</span>

        <span class="cov0" title="0">if publicRuntimeConfig, ok := config["publicRuntimeConfig"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                result.PublicRuntimeConfig = publicRuntimeConfig
        }</span>

        <span class="cov0" title="0">if serverRuntimeConfig, ok := config["serverRuntimeConfig"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                result.ServerRuntimeConfig = serverRuntimeConfig
        }</span>

        <span class="cov0" title="0">if webpack, ok := config["webpack"]; ok </span><span class="cov0" title="0">{
                result.Webpack = webpack
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Helper functions
func getStringFromMap(m map[string]interface{}, key string) string <span class="cov0" title="0">{
        if val, ok := m[key].(string); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func getBoolFromMap(m map[string]interface{}, key string) bool <span class="cov0" title="0">{
        if val, ok := m[key].(bool); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return false</span>
}

func getIntFromMap(m map[string]interface{}, key string) int <span class="cov0" title="0">{
        if val, ok := m[key].(int); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">if val, ok := m[key].(float64); ok </span><span class="cov0" title="0">{
                return int(val)
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func getFloat64FromMap(m map[string]interface{}, key string) float64 <span class="cov0" title="0">{
        if val, ok := m[key].(float64); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func getStringSliceFromMap(m map[string]interface{}, key string) []string <span class="cov0" title="0">{
        if arr, ok := m[key].([]interface{}); ok </span><span class="cov0" title="0">{
                var result []string
                for _, v := range arr </span><span class="cov0" title="0">{
                        if s, ok := v.(string); ok </span><span class="cov0" title="0">{
                                result = append(result, s)
                        }</span>
                }
                <span class="cov0" title="0">return result</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func getIntSliceFromMap(m map[string]interface{}, key string) []int <span class="cov0" title="0">{
        if arr, ok := m[key].([]interface{}); ok </span><span class="cov0" title="0">{
                var result []int
                for _, v := range arr </span><span class="cov0" title="0">{
                        if i, ok := v.(int); ok </span><span class="cov0" title="0">{
                                result = append(result, i)
                        }</span> else<span class="cov0" title="0"> if f, ok := v.(float64); ok </span><span class="cov0" title="0">{
                                result = append(result, int(f))
                        }</span>
                }
                <span class="cov0" title="0">return result</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func toMap(value interface{}) map[string]interface{} <span class="cov0" title="0">{
        if m, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                return m
        }</span>
        <span class="cov0" title="0">return make(map[string]interface{})</span>
}

func toSlice(value interface{}) []interface{} <span class="cov0" title="0">{
        if s, ok := value.([]interface{}); ok </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package nextcore

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "nextdeploy/shared"
        "nextdeploy/shared/config"
        "nextdeploy/shared/git"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"
)

const (
        BuildLockFileName = ".nextdeploy/build.lock"
        MetadataFileName  = ".nextdeploy/metadata.json"
        AssetsOutputDir   = ".nextdeploy/assets"
        PublicDir         = "public"
)

var (
        NextCoreLogger = shared.PackageLogger("nextcore", "üì¶ NEXTCORE")
)

// TODO: add temporal workflow context for metadata ingeestion and usage pipelines
func GenerateMetadata() (metadata NextCorePayload, err error) <span class="cov0" title="0">{
        // This function will generate metadata for the Next.js application
        // and return a NextCorePayload with the necessary fields filled.
        NextCoreLogger.Info("Generating metadata for Next.js application...")
        //Get the app name
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to load configuration: %v", err)
                return NextCorePayload{}, err
        }</span>

        <span class="cov0" title="0">AppName := cfg.App.Name

        // Get the nextjs version
        NextJsVersion, err := GetNextJsVersion("package.json")
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to get Next.js version: %v", err)
                return NextCorePayload{}, err
        }</span>
        <span class="cov0" title="0">NextCoreLogger.Info("Next.js version: %s", NextJsVersion)
        // get the build meta data
        NextCoreLogger.Info("Collecting build metadata...")
        buildMeta, err := CollectBuildMetadata()
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to collect build metadata: %v", err)
                return NextCorePayload{}, err
        }</span>
        // add config data to the metadata also
        <span class="cov0" title="0">config, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to load configuration: %v", err)
                return NextCorePayload{}, err
        }</span>
        // static_routes := []string{}
        <span class="cov0" title="0">routeInfo, err := getRoutesFromManifests(buildMeta)
        if err != nil </span><span class="cov0" title="0">{
                return NextCorePayload{}, err
        }</span>
        <span class="cov0" title="0">cwd, err := os.Getwd()
        packageManager, err := DetectPackageManager(cwd)
        buildCommand, err := buildCommand(packageManager.String())

        startCommand, err := startCommand(packageManager.String())
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to get start command: %v", err)
                return NextCorePayload{}, err
        }</span>
        <span class="cov0" title="0">imagesAssets, err := detectImageAssets(buildMeta, cwd)
        var HasImageAssets bool
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to detect image assets: %v", err)
                return NextCorePayload{}, err
        }</span>
        <span class="cov0" title="0">if imagesAssets == nil </span><span class="cov0" title="0">{
                NextCoreLogger.Info("No image assets found in the Next.js build")
        }</span> else<span class="cov0" title="0"> {
                HasImageAssets = true
        }</span>

        <span class="cov0" title="0">domainName := config.App.Domain
        middlewareConfig, err := ParseMiddleware(cwd)

        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to parse middleware configuration: %v", err)
                return NextCorePayload{}, err
        }</span>

        <span class="cov0" title="0">StaticAssets, err := ParseStaticAssets(cwd)
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to parse static assets: %v", err)
                return NextCorePayload{}, err
        }</span>

        <span class="cov0" title="0">gitCommt, err := git.GetCommitHash()
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to get git commit hash: %v", err)
                return NextCorePayload{}, err
        }</span> else<span class="cov0" title="0"> {
                NextCoreLogger.Debug("Git commit hash: %s", gitCommt)
        }</span>
        <span class="cov0" title="0">gitDiry := git.IsDirty()

        PayloadPath, err := filepath.Abs(filepath.Join(cwd, MetadataFileName))
        buildLockPath, err := filepath.Abs(filepath.Join(cwd, BuildLockFileName))
        AssetsOutputDir, err := filepath.Abs(filepath.Join(cwd, AssetsOutputDir))
        // 4. Copy static assets
        if err := copyStaticAssets(); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to copy static assets: %v", err)
                return NextCorePayload{}, fmt.Errorf("failed to copy static assets: %w", err)
        }</span>

        // 4. Track git state
        <span class="cov0" title="0">metadata = NextCorePayload{
                AppName:           AppName,
                NextVersion:       NextJsVersion,
                NextBuildMetadata: *buildMeta,
                Config:            config,
                BuildCommand:      buildCommand.String(),
                StartCommand:      startCommand,
                HasImageAssets:    HasImageAssets,
                CDNEnabled:        false,
                Domain:            domainName,
                RouteInfo:         *routeInfo,
                Middleware:        middlewareConfig,
                StaticAssets:      StaticAssets,
                GitCommit:         gitCommt,
                GitDirty:          gitDiry,
                GeneratedAt:       time.Now().Format(time.RFC3339),
                MetadataFilePath:  PayloadPath,
                BuildLockFile:     buildLockPath,
                AssetsOutputDir:   AssetsOutputDir,
                PackageManager:    packageManager.String(),
                RootDir:           cwd,
        }

        if err := createBuildLock(&amp;metadata); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to create build lock: %v", err)
                return NextCorePayload{}, fmt.Errorf("failed to create build lock: %w", err)
        }</span>

        <span class="cov0" title="0">return metadata, nil</span>
}

func copyStaticAssets() error <span class="cov0" title="0">{
        srcDir := "public"
        dstDir := filepath.Join(".nextdeploy", "assets")

        // Create destination directory
        if err := os.MkdirAll(dstDir, 0755); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to create destination directory: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return filepath.Walk(srcDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        NextCoreLogger.Error("Error walking path %s: %v", path, err)
                        return err
                }</span>

                // Skip directories
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Create relative path
                <span class="cov0" title="0">relPath, err := filepath.Rel(srcDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        NextCoreLogger.Error("Failed to get relative path for %s: %v", path, err)
                        return err
                }</span>

                // Create destination path
                <span class="cov0" title="0">dstPath := filepath.Join(dstDir, relPath)

                // Create destination directory structure
                if err := os.MkdirAll(filepath.Dir(dstPath), 0755); err != nil </span><span class="cov0" title="0">{
                        NextCoreLogger.Error("Failed to create directory for %s: %v", dstPath, err)
                        return err
                }</span>

                // Copy file
                <span class="cov0" title="0">return copyFile(path, dstPath)</span>
        })
}

// copyFile copies a file from src to dst
func copyFile(src, dst string) error <span class="cov0" title="0">{
        source, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to open source file %s: %v", src, err)
                return err
        }</span>
        <span class="cov0" title="0">defer source.Close()

        destination, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to create destination file %s: %v", dst, err)
                return err
        }</span>
        <span class="cov0" title="0">defer destination.Close()

        _, err = io.Copy(destination, source)
        return err</span>
}

// createBuildLock creates the build.lock file with git state
func createBuildLock(metadata *NextCorePayload) error <span class="cov0" title="0">{
        commitHash, err := git.GetCommitHash()
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to get git commit hash: %v", err)
                return fmt.Errorf("failed to get git commit hash: %w", err)
        }</span>

        <span class="cov0" title="0">dirty := git.IsDirty()
        // Write metadata to json file
        fileName := ".nextdeploy/metadata.json"
        marshalledData, err := json.MarshalIndent(metadata, "", "  ")
        os.WriteFile(fileName, marshalledData, 0644)

        buildLock := BuildLock{
                GitCommit:   commitHash,
                GitDirty:    dirty,
                GeneratedAt: metadata.GeneratedAt,
                Metadata:    fileName,
        }

        data, err := json.MarshalIndent(buildLock, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to marshal build lock: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(filepath.Join(".nextdeploy", "build.lock"), data, 0644)</span>
}

// getPublicEnvVars collects NEXT_PUBLIC_* environment variables
func getPublicEnvVars() map[string]string <span class="cov0" title="0">{
        vars := make(map[string]string)
        for _, env := range os.Environ() </span><span class="cov0" title="0">{
                if strings.HasPrefix(env, "NEXT_PUBLIC_") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(env, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                vars[parts[0]] = parts[1]
                        }</span>
                }
        }
        <span class="cov0" title="0">return vars</span>
}

// ValidateBuildState checks if the current git state matches the build lock
func ValidateBuildState() error <span class="cov0" title="0">{
        lockPath := filepath.Join(".nextdeploy", "build.lock")
        data, err := os.ReadFile(lockPath)
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to read build lock file: %v", err)
                return fmt.Errorf("failed to read build lock: %w", err)
        }</span>

        <span class="cov0" title="0">var lock BuildLock
        if err := json.Unmarshal(data, &amp;lock); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to parse build lock file: %v", err)
                return fmt.Errorf("failed to parse build lock: %w", err)
        }</span>

        <span class="cov0" title="0">currentCommit, err := git.GetCommitHash()
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to get current git commit: %v", err)
                return fmt.Errorf("failed to get current git commit: %w", err)
        }</span>
        //TODO: use this data to avoid unnecessary builds
        <span class="cov0" title="0">dlog.Info("Current git commit: %s", currentCommit)
        dlog.Info("Expected git commit: %s", lock.GitCommit)
        if currentCommit != lock.GitCommit </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Git commit mismatch: expected %s, got %s", lock.GitCommit, currentCommit)
                return fmt.Errorf("git commit mismatch: expected %s, got %s", lock.GitCommit, currentCommit)
        }</span>

        <span class="cov0" title="0">if git.IsDirty() &amp;&amp; !lock.GitDirty </span><span class="cov0" title="0">{
                return errors.New("working directory is dirty but build lock expects clean state")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

var assetExtensions = map[string]string{
        // Images
        ".jpg":  "image",
        ".jpeg": "image",
        ".png":  "image",
        ".gif":  "image",
        ".webp": "image",
        ".avif": "image",
        ".svg":  "image",
        ".ico":  "image",

        // Fonts
        ".woff":  "font",
        ".woff2": "font",
        ".ttf":   "font",
        ".otf":   "font",
        ".eot":   "font",

        // Stylesheets
        ".css": "stylesheet",

        // Scripts
        ".js":  "script",
        ".mjs": "script",
        ".cjs": "script",
        ".jsx": "script",
        ".ts":  "script",
        ".tsx": "script",

        // Documents
        ".html": "document",
        ".htm":  "document",
        ".pdf":  "document",
        ".txt":  "document",
        ".md":   "document",
        ".json": "document",
        ".xml":  "document",
}

// ParseStaticAssets scans the project for static assets
func ParseStaticAssets(projectDir string) (*StaticAssets, error) <span class="cov0" title="0">{
        assets := &amp;StaticAssets{}

        // 1. Scan public directory
        publicDir := filepath.Join(projectDir, "public")
        if _, err := os.Stat(publicDir); err == nil </span><span class="cov0" title="0">{
                NextCoreLogger.Debug("Scanning public directory: %s", publicDir)
                publicAssets, err := scanDirectory(publicDir, projectDir, "/")
                if err != nil </span><span class="cov0" title="0">{
                        NextCoreLogger.Error("Failed to scan public directory: %v", err)
                        return nil, fmt.Errorf("failed to scan public directory: %w", err)
                }</span>
                <span class="cov0" title="0">assets.PublicDir = publicAssets</span>
        }

        // 2. Scan static directory (legacy)
        <span class="cov0" title="0">staticDir := filepath.Join(projectDir, "static")
        if _, err := os.Stat(staticDir); err == nil </span><span class="cov0" title="0">{
                NextCoreLogger.Debug("Scanning static directory: %s", staticDir)
                staticAssets, err := scanDirectory(staticDir, projectDir, "/static")
                if err != nil </span><span class="cov0" title="0">{
                        NextCoreLogger.Error("Failed to scan static directory: %v", err)
                        return nil, fmt.Errorf("failed to scan static directory: %w", err)
                }</span>
                <span class="cov0" title="0">assets.StaticFolder = staticAssets</span>
        }

        // 3. Scan .next/static directory
        <span class="cov0" title="0">nextStaticDir := filepath.Join(projectDir, ".next", "static")
        if _, err := os.Stat(nextStaticDir); err == nil </span><span class="cov0" title="0">{
                NextCoreLogger.Debug("Scanning .next/static directory: %s", nextStaticDir)
                nextStaticAssets, err := scanDirectory(nextStaticDir, projectDir, "/_next/static")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan .next/static directory: %w", err)
                }</span>
                <span class="cov0" title="0">assets.NextStatic = nextStaticAssets</span>
        }

        // 4. Scan for other common static assets in root
        <span class="cov0" title="0">rootAssets, err := scanRootAssets(projectDir)
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to scan root assets: %v", err)
                return nil, fmt.Errorf("failed to scan root assets: %w", err)
        }</span>
        <span class="cov0" title="0">assets.OtherAssets = rootAssets

        return assets, nil</span>
}

// scanDirectory recursively scans a directory for static assets
func scanDirectory(dirPath, projectDir, publicPathPrefix string) ([]StaticAsset, error) <span class="cov0" title="0">{
        var assets []StaticAsset

        err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        NextCoreLogger.Error("Error accessing path %s: %v", path, err)
                        return err
                }</span>

                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        relPath, err := filepath.Rel(dirPath, path)
                        if err != nil </span><span class="cov0" title="0">{
                                NextCoreLogger.Error("Failed to get relative path for %s: %v", path, err)
                                return err
                        }</span>

                        <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(path))
                        assetType := "other"
                        if t, ok := assetExtensions[ext]; ok </span><span class="cov0" title="0">{
                                assetType = t
                        }</span>

                        <span class="cov0" title="0">relProjectPath, err := filepath.Rel(projectDir, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">publicPath := filepath.Join(publicPathPrefix, relPath)
                        // Convert path separators to forward slashes for URLs
                        publicPath = filepath.ToSlash(publicPath)

                        assets = append(assets, StaticAsset{
                                Path:         relProjectPath,
                                AbsolutePath: path,
                                PublicPath:   publicPath,
                                Type:         assetType,
                                Extension:    ext,
                                Size:         info.Size(),
                        })</span>
                }
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return assets, err</span>
}

// scanRootAssets scans for common static files in project root
func scanRootAssets(projectDir string) ([]StaticAsset, error) <span class="cov0" title="0">{
        var assets []StaticAsset

        rootFiles := []string{
                "favicon.ico",
                "robots.txt",
                "sitemap.xml",
                "manifest.json",
        }

        for _, file := range rootFiles </span><span class="cov0" title="0">{
                path := filepath.Join(projectDir, file)
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        info, err := os.Stat(path)
                        if err != nil </span><span class="cov0" title="0">{
                                NextCoreLogger.Debug("Failed to get file info for %s: %v", path, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(path))
                        assetType := "other"
                        if t, ok := assetExtensions[ext]; ok </span><span class="cov0" title="0">{
                                assetType = t
                        }</span>

                        <span class="cov0" title="0">assets = append(assets, StaticAsset{
                                Path:         file,
                                AbsolutePath: path,
                                PublicPath:   "/" + file,
                                Type:         assetType,
                                Extension:    ext,
                                Size:         info.Size(),
                        })</span>
                }
        }

        <span class="cov0" title="0">return assets, nil</span>
}

// ParseMiddleware parses Next.js middleware configuration
func ParseMiddleware(projectDir string) (*MiddlewareConfig, error) <span class="cov0" title="0">{
        config := &amp;MiddlewareConfig{
                Path:     filepath.Join(projectDir, "middleware.js"),
                Matchers: []MiddlewareRoute{},
                Runtime:  "nodejs", // Default runtime
        }

        // Check for middleware.ts first, then middleware.js
        middlewarePaths := []string{
                filepath.Join(projectDir, "middleware.ts"),
                filepath.Join(projectDir, "middleware.js"),
        }

        var middlewareFile string
        for _, path := range middlewarePaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        middlewareFile = path
                        config.Path = path
                        break</span>
                }
        }

        <span class="cov0" title="0">if middlewareFile == "" </span><span class="cov0" title="0">{
                return nil, nil // No middleware file found
        }</span>

        // Read middleware file content
        <span class="cov0" title="0">content, err := os.ReadFile(middlewareFile)
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to read middleware file: %v", err)
                return nil, fmt.Errorf("failed to read middleware file: %w", err)
        }</span>

        // Parse middleware matchers
        <span class="cov0" title="0">matchers, err := parseMiddlewareMatchers(string(content))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse middleware matchers: %w", err)
        }</span>
        <span class="cov0" title="0">config.Matchers = matchers

        // Check for Edge runtime
        if strings.Contains(string(content), "runtime: 'edge'") </span><span class="cov0" title="0">{
                config.Runtime = "edge"
        }</span>

        // Check for regions configuration
        <span class="cov0" title="0">if regions := parseEdgeRegions(string(content)); len(regions) &gt; 0 </span><span class="cov0" title="0">{
                config.Regions = regions
        }</span>

        // Check for unstable flags
        <span class="cov0" title="0">if flag := parseUnstableFlag(string(content)); flag != "" </span><span class="cov0" title="0">{
                config.UnstableFlag = flag
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// parseMiddlewareMatchers extracts route matchers from middleware file
func parseMiddlewareMatchers(content string) ([]MiddlewareRoute, error) <span class="cov0" title="0">{
        var matchers []MiddlewareRoute

        // First try to parse config object style
        configObjRegex := regexp.MustCompile(`config\s*=\s*{([^}]*)}`)
        configMatches := configObjRegex.FindStringSubmatch(content)
        if len(configMatches) &gt; 1 </span><span class="cov0" title="0">{
                // Try to parse as JSON (with some cleaning)
                cleaned := strings.ReplaceAll(configMatches[1], "'", `"`)
                cleaned = strings.ReplaceAll(cleaned, "\n", "")
                cleaned = fmt.Sprintf("{%s}", cleaned)

                var config struct {
                        Matcher []struct {
                                Pathname string `json:"pathname"`
                                Pattern  string `json:"pattern"`
                                Has      []struct {
                                        Type  string `json:"type"`
                                        Key   string `json:"key"`
                                        Value string `json:"value"`
                                } `json:"has"`
                                Missing []struct {
                                        Type  string `json:"type"`
                                        Key   string `json:"key"`
                                        Value string `json:"value"`
                                } `json:"missing"`
                        } `json:"matcher"`
                }

                if err := json.Unmarshal([]byte(cleaned), &amp;config); err == nil </span><span class="cov0" title="0">{
                        for _, m := range config.Matcher </span><span class="cov0" title="0">{
                                route := MiddlewareRoute{
                                        Pathname: m.Pathname,
                                        Pattern:  m.Pattern,
                                }

                                for _, h := range m.Has </span><span class="cov0" title="0">{
                                        route.Has = append(route.Has, MiddlewareCondition{
                                                Type:  h.Type,
                                                Key:   h.Key,
                                                Value: h.Value,
                                        })
                                }</span>

                                <span class="cov0" title="0">for _, miss := range m.Missing </span><span class="cov0" title="0">{
                                        route.Missing = append(route.Missing, MiddlewareCondition{
                                                Type:  miss.Type,
                                                Key:   miss.Key,
                                                Value: miss.Value,
                                        })
                                }</span>

                                <span class="cov0" title="0">matchers = append(matchers, route)</span>
                        }
                        <span class="cov0" title="0">return matchers, nil</span>
                }
        }

        // Fallback to parsing individual matchers
        <span class="cov0" title="0">matcherRegex := regexp.MustCompile(`matcher:\s*(\[[^\]]+\]|{[^}]+})`)
        matcherMatches := matcherRegex.FindStringSubmatch(content)
        if len(matcherMatches) &gt; 1 </span><span class="cov0" title="0">{
                cleaned := strings.ReplaceAll(matcherMatches[1], "'", `"`)
                cleaned = strings.ReplaceAll(cleaned, "\n", "")

                // Handle array of paths
                if strings.HasPrefix(cleaned, "[") </span><span class="cov0" title="0">{
                        var paths []string
                        if err := json.Unmarshal([]byte(cleaned), &amp;paths); err == nil </span><span class="cov0" title="0">{
                                for _, path := range paths </span><span class="cov0" title="0">{
                                        matchers = append(matchers, MiddlewareRoute{
                                                Pathname: path,
                                        })
                                }</span>
                                <span class="cov0" title="0">return matchers, nil</span>
                        }
                }

                // Handle object matcher
                <span class="cov0" title="0">if strings.HasPrefix(cleaned, "{") </span><span class="cov0" title="0">{
                        var matcher struct {
                                Pathname string `json:"pathname"`
                                Pattern  string `json:"pattern"`
                        }
                        if err := json.Unmarshal([]byte(cleaned), &amp;matcher); err == nil </span><span class="cov0" title="0">{
                                matchers = append(matchers, MiddlewareRoute{
                                        Pathname: matcher.Pathname,
                                        Pattern:  matcher.Pattern,
                                })
                                return matchers, nil
                        }</span>
                }
        }

        // Fallback to parsing simple path strings
        <span class="cov0" title="0">pathRegex := regexp.MustCompile(`path:\s*['"]([^'"]+)['"]`)
        pathMatches := pathRegex.FindAllStringSubmatch(content, -1)
        for _, match := range pathMatches </span><span class="cov0" title="0">{
                if len(match) &gt; 1 </span><span class="cov0" title="0">{
                        matchers = append(matchers, MiddlewareRoute{
                                Pathname: match[1],
                        })
                }</span>
        }

        <span class="cov0" title="0">return matchers, nil</span>
}

// parseUnstableFlag extracts unstable configuration flags
func parseUnstableFlag(content string) string <span class="cov0" title="0">{
        flagRegex := regexp.MustCompile(`unstable_(\w+):\s*true`)
        matches := flagRegex.FindStringSubmatch(content)
        if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                return matches[1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func parseImageConfig(images map[string]interface{}) ImageConfig <span class="cov0" title="0">{
        result := ImageConfig{
                Loader: "default",
        }

        if domains, ok := images["domains"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, d := range domains </span><span class="cov0" title="0">{
                        if s, ok := d.(string); ok </span><span class="cov0" title="0">{
                                result.Domains = append(result.Domains, s)
                        }</span>
                }
        }

        <span class="cov0" title="0">if formats, ok := images["formats"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, f := range formats </span><span class="cov0" title="0">{
                        if s, ok := f.(string); ok </span><span class="cov0" title="0">{
                                result.Formats = append(result.Formats, s)
                        }</span>
                }
        }

        <span class="cov0" title="0">if deviceSizes, ok := images["deviceSizes"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, s := range deviceSizes </span><span class="cov0" title="0">{
                        if n, ok := s.(float64); ok </span><span class="cov0" title="0">{
                                result.DeviceSizes = append(result.DeviceSizes, int(n))
                        }</span>
                }
        }

        <span class="cov0" title="0">if imageSizes, ok := images["imageSizes"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, s := range imageSizes </span><span class="cov0" title="0">{
                        if n, ok := s.(float64); ok </span><span class="cov0" title="0">{
                                result.ImageSizes = append(result.ImageSizes, int(n))
                        }</span>
                }
        }

        <span class="cov0" title="0">if loader, ok := images["loader"].(string); ok </span><span class="cov0" title="0">{
                result.Loader = loader
        }</span>

        <span class="cov0" title="0">if path, ok := images["path"].(string); ok </span><span class="cov0" title="0">{
                result.Path = path
        }</span>

        <span class="cov0" title="0">if ttl, ok := images["minimumCacheTTL"].(float64); ok </span><span class="cov0" title="0">{
                result.MinimumCacheTTL = int(ttl)
        }</span>

        <span class="cov0" title="0">if unoptimized, ok := images["unoptimized"].(bool); ok </span><span class="cov0" title="0">{
                result.Unoptimized = unoptimized
        }</span>

        <span class="cov0" title="0">return result</span>
}

// detectImageAssets finds all image assets in the Next.js build
func detectImageAssets(buildMeta *NextBuildMetadata, projectDir string) (*ImageAssets, error) <span class="cov0" title="0">{
        assets := &amp;ImageAssets{}
        var err error

        // 1. Find images in public directory
        publicDir := filepath.Join(projectDir, PublicDir)
        assets.PublicImages, err = findPublicImages(publicDir, projectDir)
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to find public images: %v", err)
                return nil, err
        }</span>

        // 2. Find optimized images from Next.js image manifest
        <span class="cov0" title="0">if buildMeta.ImagesManifest != nil </span><span class="cov0" title="0">{
                if imagesManifest, ok := buildMeta.ImagesManifest.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        assets.OptimizedImages = parseImagesManifest(imagesManifest, projectDir)
                }</span>
        }

        // 3. Find static image imports from build manifest
        <span class="cov0" title="0">if buildMeta.BuildManifest != nil </span><span class="cov0" title="0">{
                if buildManifest, ok := buildMeta.BuildManifest.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        assets.StaticImports = parseStaticImageImports(buildManifest, projectDir)
                }</span>
        }

        <span class="cov0" title="0">return assets, nil</span>
}

// findPublicImages scans the public directory for image assets
func findPublicImages(publicDir, projectDir string) ([]ImageAsset, error) <span class="cov0" title="0">{
        var images []ImageAsset

        // Supported image extensions
        imageExts := map[string]bool{
                ".jpg":  true,
                ".jpeg": true,
                ".png":  true,
                ".webp": true,
                ".gif":  true,
                ".avif": true,
                ".svg":  true,
        }

        err := filepath.Walk(publicDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        ext := strings.ToLower(filepath.Ext(path))
                        if imageExts[ext] </span><span class="cov0" title="0">{
                                relPath, err := filepath.Rel(publicDir, path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">images = append(images, ImageAsset{
                                        Path:         relPath,
                                        AbsolutePath: path,
                                        PublicPath:   filepath.Join("/", relPath),
                                        Format:       strings.TrimPrefix(ext, "."),
                                        IsOptimized:  false,
                                })</span>
                        }
                }
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return images, err</span>
}

// parseImagesManifest extracts info from Next.js images-manifest.json
func parseImagesManifest(manifest map[string]interface{}, projectDir string) []ImageAsset <span class="cov0" title="0">{
        var images []ImageAsset

        if imagesMap, ok := manifest["images"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for _, img := range imagesMap </span><span class="cov0" title="0">{
                        if imgMap, ok := img.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                path, _ := imgMap["path"].(string)
                                format, _ := imgMap["format"].(string)

                                asset := ImageAsset{
                                        Path:         path,
                                        AbsolutePath: filepath.Join(projectDir, ".next", "server", path),
                                        PublicPath:   "/_next/image?url=" + path + "&amp;w=3840&amp;q=75", // Example URL
                                        Format:       format,
                                        IsOptimized:  true,
                                }

                                if width, ok := imgMap["width"].(float64); ok </span><span class="cov0" title="0">{
                                        asset.Width = int(width)
                                }</span>
                                <span class="cov0" title="0">if height, ok := imgMap["height"].(float64); ok </span><span class="cov0" title="0">{
                                        asset.Height = int(height)
                                }</span>

                                <span class="cov0" title="0">images = append(images, asset)</span>
                        }
                }
        }

        <span class="cov0" title="0">return images</span>
}

// parseStaticImageImports finds statically imported images from build manifest
func parseStaticImageImports(buildManifest map[string]interface{}, projectDir string) []ImageAsset <span class="cov0" title="0">{
        var images []ImageAsset

        if files, ok := buildManifest["staticImageImports"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for path, data := range files </span><span class="cov0" title="0">{
                        if dataMap, ok := data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                format := strings.TrimPrefix(filepath.Ext(path), ".")

                                asset := ImageAsset{
                                        Path:           path,
                                        AbsolutePath:   filepath.Join(projectDir, path),
                                        PublicPath:     path, // This will be hashed in the actual build
                                        Format:         format,
                                        IsOptimized:    true,
                                        IsStaticImport: true,
                                }

                                if width, ok := dataMap["width"].(float64); ok </span><span class="cov0" title="0">{
                                        asset.Width = int(width)
                                }</span>
                                <span class="cov0" title="0">if height, ok := dataMap["height"].(float64); ok </span><span class="cov0" title="0">{
                                        asset.Height = int(height)
                                }</span>

                                <span class="cov0" title="0">images = append(images, asset)</span>
                        }
                }
        }

        <span class="cov0" title="0">return images</span>
}
func startCommand(PackageManager string) (string, error) <span class="cov0" title="0">{
        if PackageManager == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no package manager provided")
        }</span>
        <span class="cov0" title="0">switch PackageManager </span>{
        case "npm":<span class="cov0" title="0">
                return "npm start", nil</span>
        case "yarn":<span class="cov0" title="0">
                return "yarn start", nil</span>
        case "pnpm":<span class="cov0" title="0">
                return "pnpm start", nil</span>
        default:<span class="cov0" title="0">
                return "npm start", fmt.Errorf("unsupported package manager: %s", PackageManager)</span>

        }
}
func buildCommand(PackageManager string) (PackageManager, error) <span class="cov0" title="0">{

        if PackageManager == "" </span><span class="cov0" title="0">{
                PackageManager = "npm" // default to npm if not specified
        }</span>

        <span class="cov0" title="0">switch PackageManager </span>{
        case "npm":<span class="cov0" title="0">
                return "npm run build", nil</span>
        case "yarn":<span class="cov0" title="0">
                return "yarn build", nil</span>
        case "pnpm":<span class="cov0" title="0">
                return "pnpm run build", nil</span>
        default:<span class="cov0" title="0">
                return "npm run build", fmt.Errorf("unsupported package manager: %s", PackageManager)</span>
        }

}
</pre>
		
		<pre class="file" id="file48" style="display: none">// NOTE: CROSS COMPILE SAFE
package nextcore

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/cobra"
)

// PackageJSON represents the structure of package.json we care about
type PackageJSON struct {
        Name            string            `json:"name"`
        Version         string            `json:"version"`
        Dependencies    map[string]string `json:"dependencies"`
        DevDependencies map[string]string `json:"devDependencies"`
        Scripts         map[string]string `json:"scripts"`
        Private         bool              `json:"private"`
}

func GetNextJsVersion(packageJsonPath string) (string, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(packageJsonPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("package.json not found at %s", packageJsonPath)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("error reading package.json: %w", err)</span>
        }
        <span class="cov0" title="0">var pkg PackageJSON
        if err := json.Unmarshal(data, &amp;pkg); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error parsing package.json: %w", err)
        }</span>
        // check at both dev and regular dependencies
        <span class="cov0" title="0">if version, exists := pkg.Dependencies["next"]; exists </span><span class="cov0" title="0">{
                return version, nil
        }</span>
        <span class="cov0" title="0">if version, exists := pkg.DevDependencies["next"]; exists </span><span class="cov0" title="0">{
                return version, nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("Next.js dependency not found in package.json")</span>

}

// ValidateNextJSProject checks if the current or specified directory is a valid Next.js project
func ValidateNextJSProject(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        targetDir := "."
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                targetDir = args[0]
        }</span>

        <span class="cov0" title="0">absPath, err := filepath.Abs(targetDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get absolute path for directory '%s': %w", targetDir, err)
        }</span>
        <span class="cov0" title="0">err = validateDirectory(absPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate directory '%s': %w", absPath, err)
        }</span>
        <span class="cov0" title="0">isNextJS, reason, err := IsNextJSProject(absPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate Next.js project: %w", err)
        }</span>
        <span class="cov0" title="0">if !isNextJS </span><span class="cov0" title="0">{
                if reason != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("directory '%s' is not a Next.js project: %s", absPath, reason)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("directory doesn't appear to be a Next.js project")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateDirectory checks if the path exists and is a directory
func validateDirectory(path string) error <span class="cov0" title="0">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("directory '%s' does not exist", path)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to access directory: %w", err)</span>
        }
        <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("'%s' is not a directory", path)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsNextJSProject performs comprehensive Next.js project validation
// Returns: (isNextJS bool, reason string, err error)
func IsNextJSProject(dir string) (bool, string, error) <span class="cov0" title="0">{
        // Check for package.json first
        pkg, err := readPackageJSON(dir)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>
        <span class="cov0" title="0">if pkg == nil </span><span class="cov0" title="0">{
                return false, "no package.json found", nil
        }</span>

        // Check for Next.js in dependencies
        <span class="cov0" title="0">if hasNextDependency(pkg.Dependencies) || hasNextDependency(pkg.DevDependencies) </span><span class="cov0" title="0">{
                return true, "", nil
        }</span>

        // Check for Next.js in scripts
        <span class="cov0" title="0">if hasNextScript(pkg.Scripts) </span><span class="cov0" title="0">{
                return true, "", nil
        }</span>

        // Check for Next.js specific files and directories
        <span class="cov0" title="0">if hasNextJSStructure(dir) </span><span class="cov0" title="0">{
                return true, "", nil
        }</span>

        <span class="cov0" title="0">return false, "no Next.js dependencies, scripts, or project structure found", nil</span>
}

// readPackageJSON reads and parses package.json
func readPackageJSON(dir string) (*PackageJSON, error) <span class="cov0" title="0">{
        path := filepath.Join(dir, "package.json")
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error reading package.json: %w", err)</span>
        }

        <span class="cov0" title="0">var pkg PackageJSON
        if err := json.Unmarshal(data, &amp;pkg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing package.json: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;pkg, nil</span>
}

// hasNextDependency checks if Next.js is in dependencies
func hasNextDependency(deps map[string]string) bool <span class="cov0" title="0">{
        if deps == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">_, exists := deps["next"]
        return exists</span>
}

// hasNextScript checks if any script contains "next"
func hasNextScript(scripts map[string]string) bool <span class="cov0" title="0">{
        if scripts == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, script := range scripts </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(script), "next") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// hasNextJSStructure checks for Next.js specific files and directories
func hasNextJSStructure(dir string) bool <span class="cov0" title="0">{
        nextjsFiles := []string{
                "next.config.js",
                "next.config.mjs",
                "next.config.ts",
                "next-env.d.ts",
        }

        for _, file := range nextjsFiles </span><span class="cov0" title="0">{
                if _, err := os.Stat(filepath.Join(dir, file)); err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">nextjsDirs := []string{
                "pages",
                "src/pages",
                "app",
                "src/app",
                "public",
        }

        // More robust directory checking that handles case differences
        for _, dirPath := range nextjsDirs </span><span class="cov0" title="0">{
                if entries, err := os.ReadDir(dir); err == nil </span><span class="cov0" title="0">{
                        for _, entry := range entries </span><span class="cov0" title="0">{
                                if strings.EqualFold(entry.Name(), dirPath) &amp;&amp; entry.IsDir() </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package nextcore

// TODO(yussuf): Rename plog from "cmd" to "detect" to better reflect this package's context.
//   - Use: logger.PackageLogger("detect", "üì¶ DETECT")

// TODO(yussuf): Split logger instances (plog, dlog, slog) if not all are used here.
//   - If this file only detects package managers, remove dlog/slog to avoid noise.

// TODO(yussuf): Move indicator definitions into a `var indicators = ...` block outside the function.
//   - Keeps `DetectPackageManager()` smaller and more readable.
//   - Possibly expose as a constant or unexported var for testability or override.

// TODO(yussuf): Add file existence check helper:
//   - func fileExists(path string) bool
//   - Cleans up repeated os.Stat logic and avoids clutter in detection loop.

// TODO(yussuf): Refactor score weighting logic for readability:
//   - Abstract into: `scoreManager(scores map[PackageManager]int, manager PackageManager, weight int)`
//   - Reduces cognitive load while reading scoring rules.

// TODO(yussuf): Avoid hardcoded string weights inside `package.json` check:
//   - Create constants for `"pnpm"` and `"yarn"` match scores.
//   - Improves maintainability if scoring logic changes.

// TODO(yussuf): Move `.env` variable scoring outside the function or document clearly:
//   - Document supported env vars and why they influence scoring.
//   - Possibly expose via optional `WithEnvDetection` flag/config.

// TODO(yussuf): Add tie-breaker logic or warning in case of tied scores:
//   - Currently, first highest wins ‚Äî add fallback preference ordering or warning log.

// TODO(yussuf): Add `DetectPackageManager()` unit tests:
//   - With fake file systems or using a temp dir with mock files.
//   - Ensure coverage of scoring, env detection, tie-breaker logic.

// TODO(yussuf): Add godoc comment above `DetectPackageManager()`:
//   - // DetectPackageManager inspects a project directory to determine the Node.js package manager used.
//   - Explain heuristics, expected inputs, and output.
import (
        "fmt"
        "nextdeploy/shared"
        "os"
        "path/filepath"
        "strings"
)

type PackageManager string

var (
        plog = shared.PackageLogger("cmd", "üöÄ CMD")
        dlog = shared.PackageLogger("docker", "üê≥ DOCKER")
        slog = shared.PackageLogger("secrets", "üîí SECRETS")
)

const (
        NPM     PackageManager = "npm"
        Yarn    PackageManager = "yarn"
        PNPM    PackageManager = "pnpm"
        Unknown PackageManager = "unknown"
)

func (pm PackageManager) String() string <span class="cov0" title="0">{
        return string(pm)
}</span>

func DetectPackageManager(projectPath string) (PackageManager, error) <span class="cov0" title="0">{
        plog.Debug("Detecting package manager in %s", projectPath)

        indicators := map[string]struct {
                manager PackageManager
                weight  int
        }{
                "pnpm-lock.yaml":      {PNPM, 100},
                "yarn.lock":           {Yarn, 100},
                "package-lock.json":   {NPM, 100},
                ".npmrc":              {NPM, 40},
                ".yarnrc":             {Yarn, 40},
                "pnpm-workspace.yaml": {PNPM, 40},
                ".yarn":               {Yarn, 30},
                ".pnpm-store":         {PNPM, 30},
                "node_modules/.yarn":  {Yarn, 30},
        }

        pkgPath := filepath.Join(projectPath, "package.json")
        if _, err := os.Stat(pkgPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                plog.Error("No package.json found in %s", projectPath)
                return Unknown, fmt.Errorf("not a Node.js project")
        }</span>

        <span class="cov0" title="0">scores := make(map[PackageManager]int)
        for filename, data := range indicators </span><span class="cov0" title="0">{
                if _, err := os.Stat(filepath.Join(projectPath, filename)); err == nil </span><span class="cov0" title="0">{
                        plog.Debug("Found indicator file: %s", filename)
                        scores[data.manager] += data.weight
                }</span>
        }

        <span class="cov0" title="0">pkgJson, err := os.ReadFile(pkgPath)
        if err == nil </span><span class="cov0" title="0">{
                content := string(pkgJson)
                if strings.Contains(content, "pnpm") </span><span class="cov0" title="0">{
                        scores[PNPM] += 20
                }</span>
                <span class="cov0" title="0">if strings.Contains(content, "yarn") </span><span class="cov0" title="0">{
                        scores[Yarn] += 20
                }</span>
                <span class="cov0" title="0">if strings.Contains(content, `"pnpm"`) </span><span class="cov0" title="0">{
                        scores[PNPM] += 50
                }</span>
                <span class="cov0" title="0">if strings.Contains(content, `"yarn"`) </span><span class="cov0" title="0">{
                        scores[Yarn] += 50
                }</span>
        }

        <span class="cov0" title="0">if os.Getenv("PNPM_HOME") != "" </span><span class="cov0" title="0">{
                scores[PNPM] += 30
        }</span>
        <span class="cov0" title="0">if os.Getenv("YARN_VERSION") != "" </span><span class="cov0" title="0">{
                scores[Yarn] += 30
        }</span>

        <span class="cov0" title="0">var result PackageManager
        maxScore := 0
        for manager, score := range scores </span><span class="cov0" title="0">{
                if score &gt; maxScore </span><span class="cov0" title="0">{
                        maxScore = score
                        result = manager
                }</span>
        }

        <span class="cov0" title="0">if maxScore == 0 </span><span class="cov0" title="0">{
                plog.Debug("No clear package manager detected, checking binaries")
                if _, err := os.Stat(filepath.Join(projectPath, "node_modules", ".bin", "pnpm")); err == nil </span><span class="cov0" title="0">{
                        return PNPM, nil
                }</span>
                <span class="cov0" title="0">if _, err := os.Stat(filepath.Join(projectPath, "node_modules", ".bin", "yarn")); err == nil </span><span class="cov0" title="0">{
                        return Yarn, nil
                }</span>
                <span class="cov0" title="0">return NPM, nil</span>
        }

        <span class="cov0" title="0">plog.Info("Detected package manager: %s", result)
        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package nextcore

import (
        "path/filepath"
)

func getRoutesFromManifests(buildMeta *NextBuildMetadata) (*RouteInfo, error) <span class="cov0" title="0">{
        info := &amp;RouteInfo{
                SSGRoutes:      make(map[string]string),
                ISRRoutes:      make(map[string]string),
                FallbackRoutes: make(map[string]string),
        }
        // process routes from route-manifest.json
        // Process routes from routes-manifest.json
        if routesManifest, ok := buildMeta.RoutesManifest.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if staticRoutes, ok := routesManifest["staticRoutes"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, route := range staticRoutes </span><span class="cov0" title="0">{
                                if routeMap, ok := route.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if page, ok := routeMap["page"].(string); ok </span><span class="cov0" title="0">{
                                                info.StaticRoutes = append(info.StaticRoutes, page)
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">if dynamicRoutes, ok := routesManifest["dynamicRoutes"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, route := range dynamicRoutes </span><span class="cov0" title="0">{
                                if routeMap, ok := route.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if page, ok := routeMap["page"].(string); ok </span><span class="cov0" title="0">{
                                                info.DynamicRoutes = append(info.DynamicRoutes, page)
                                        }</span>
                                }
                        }
                }
        }
        // Process prerender-manifest.json
        <span class="cov0" title="0">if prerenderManifest, ok := buildMeta.PrerenderManifest.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if routes, ok := prerenderManifest["routes"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        for route, details := range routes </span><span class="cov0" title="0">{
                                if detailMap, ok := details.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if initialRevalidate, ok := detailMap["initialRevalidateSeconds"].(float64); ok </span><span class="cov0" title="0">{
                                                if initialRevalidate &gt; 0 </span><span class="cov0" title="0">{
                                                        info.ISRRoutes[route] = filepath.Join(".next", "server", detailMap["dataRoute"].(string))
                                                }</span> else<span class="cov0" title="0"> {
                                                        info.SSGRoutes[route] = filepath.Join(".next", "server", "pages", route+".html")
                                                }</span>
                                        }
                                }
                        }
                }
                <span class="cov0" title="0">if dynamicRoutes, ok := prerenderManifest["dynamicRoutes"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        for route, details := range dynamicRoutes </span><span class="cov0" title="0">{
                                if detailMap, ok := details.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if fallback, ok := detailMap["fallback"].(string); ok &amp;&amp; fallback != "" </span><span class="cov0" title="0">{
                                                info.FallbackRoutes[route] = fallback
                                        }</span>
                                }
                        }
                }
        }

        // Process middleware routes from build-manifest.json
        <span class="cov0" title="0">if buildManifest, ok := buildMeta.BuildManifest.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if middleware, ok := buildManifest["middleware"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        for route := range middleware </span><span class="cov0" title="0">{
                                info.MiddlewareRoutes = append(info.MiddlewareRoutes, route)
                        }</span>
                }
        }

        <span class="cov0" title="0">return info, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package nextcore

import (
        "bufio"
        "context"
        "fmt"
        "net"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/docker/docker/api/types/container"
        "github.com/docker/docker/api/types/mount"
        "github.com/docker/docker/api/types/network"
        "github.com/docker/docker/client"
        "github.com/docker/go-connections/nat"
)

/*
*  The nextruntime struct creates the logic for defining
*  data intensive runtime for next js app in docker environment
*  It has nice integration with caddy as proxy
 */
type nextruntime struct {
        dockerclient *client.Client
        payload      *NextCorePayload
}

func NewNextRuntime(payload *NextCorePayload) (*nextruntime, error) <span class="cov0" title="0">{
        startTime := time.Now()
        NextCoreLogger.Info("Creating nextruntime instance for app: %s", payload.AppName)
        cli, err := client.NewClientWithOpts(
                client.FromEnv,
                client.WithAPIVersionNegotiation(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Docker client: %w", err)
        }</span>
        <span class="cov0" title="0">nr := &amp;nextruntime{
                dockerclient: cli,
                payload:      payload,
        }

        NextCoreLogger.Info("nextruntime instance created successfully for app: %s in %s", payload.AppName, time.Since(startTime))
        return nr, nil</span>
}

func (nr *nextruntime) InitializeInfrastructure(ctx context.Context) error <span class="cov0" title="0">{
        NextCoreLogger.Debug("Initializing docker infra")
        if err := nr.ensureNetwork(ctx); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to ensure network: %s", err)
                return fmt.Errorf("failed to ensure network: %w", err)
        }</span>
        <span class="cov0" title="0">if err := nr.ensureCaddy(); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Failed to ensure Caddy: %s", err)
                return fmt.Errorf("failed to ensure Caddy: %w", err)
        }</span>
        <span class="cov0" title="0">NextCoreLogger.Debug("Docker infrastructure initialized successfully")
        return nil</span>
}
func (nr *nextruntime) validateCaddyfile(config string) error <span class="cov0" title="0">{
        cmd := exec.Command("caddy", "validate", "--config", "-")
        cmd.Stdin = strings.NewReader(config)
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Caddyfile validation failed: %s\n%s", err, string(output))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (nr *nextruntime) ensureNetwork(ctx context.Context) error <span class="cov0" title="0">{
        NetworkInspect, err := nr.dockerclient.NetworkInspect(ctx, "nextcore-network", network.InspectOptions{})
        NextCoreLogger.Debug("network inspect result:%v", NetworkInspect)
        if err == nil </span><span class="cov0" title="0">{
                // Network exists, return nil
                NextCoreLogger.Info("nextcore-network already exists")
                return nil
        }</span>
        // only process if no error
        <span class="cov0" title="0">createOpts := network.CreateOptions{
                Driver:     "bridge",
                Attachable: true,
        }

        resp, err := nr.dockerclient.NetworkCreate(ctx, "nextcore-network", createOpts)
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("failed to create nextcore-network: %s", err)
                return fmt.Errorf("failed to create nextcore-network: %w", err)
        }</span>

        <span class="cov0" title="0">NextCoreLogger.Info("nextcore-network created successfully with ID: %s", resp.ID)
        return nil</span>
}

func (nr *nextruntime) ensureCaddy() error <span class="cov0" title="0">{
        NextCoreLogger.Debug("Ensuring caddy container is running")
        // check if caddy installed first
        _, err := exec.LookPath("caddy")
        if err == nil </span><span class="cov0" title="0">{
                NextCoreLogger.Info("Caddy is installed on the system")
                return nr.ensureCaddyRunning()
        }</span>
        <span class="cov0" title="0">return nr.ensureCaddyRunning()</span>

}

func (nr *nextruntime) ensureCaddyRunning() error <span class="cov0" title="0">{
        // Check if admin API is already responsive
        if conn, err := net.DialTimeout("tcp", "localhost:2019", 500*time.Millisecond); err == nil </span><span class="cov0" title="0">{
                conn.Close()
                NextCoreLogger.Debug("Caddy admin API already running")
                return nil
        }</span>

        // Format Caddyfile first
        <span class="cov0" title="0">fmtCmd := exec.Command("caddy", "fmt", "--overwrite", "/etc/caddy/Caddyfile")
        if output, err := fmtCmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Warn("Caddyfile formatting failed (non-critical): %s", string(output))
        }</span>

        // Start Caddy with full output capture
        <span class="cov0" title="0">cmd := exec.Command("caddy", "run",
                "--config", "/etc/caddy/Caddyfile",
                "--adapter", "caddyfile",
                "--watch",
                "--resume")

        // Create pipe for real-time output
        stdoutPipe, _ := cmd.StdoutPipe()
        stderrPipe, _ := cmd.StderrPipe()

        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Caddy failed to start: %v", err)
                return fmt.Errorf("Caddy failed to start: %w", err)
        }</span>

        // Stream output in goroutines
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                scanner := bufio.NewScanner(stdoutPipe)
                for scanner.Scan() </span><span class="cov0" title="0">{
                        NextCoreLogger.Debug("Caddy stdout: %s", scanner.Text())
                }</span>
        }()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                scanner := bufio.NewScanner(stderrPipe)
                for scanner.Scan() </span><span class="cov0" title="0">{
                        NextCoreLogger.Debug("Caddy stderr: %s", scanner.Text())
                }</span>
        }()

        // Wait for Caddy to be ready with longer timeout
        <span class="cov0" title="0">timeout := time.After(15 * time.Second)
        tick := time.Tick(500 * time.Millisecond)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-timeout:<span class="cov0" title="0">
                        if cmd.Process != nil </span><span class="cov0" title="0">{
                                cmd.Process.Kill()
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("Caddy failed to start within 15 seconds")</span>
                case &lt;-tick:<span class="cov0" title="0">
                        if conn, err := net.Dial("tcp", "localhost:2019"); err == nil </span><span class="cov0" title="0">{
                                conn.Close()
                                NextCoreLogger.Info("Caddy started successfully")
                                return nil
                        }</span>
                }
        }
}
func (nr *nextruntime) reloadCaddy() error <span class="cov0" title="0">{
        // Try admin API first
        if err := exec.Command("caddy", "reload", "--config", "/etc/caddy/Caddyfile").Run(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Fallback to full restart
        <span class="cov0" title="0">NextCoreLogger.Warn("Admin reload failed, restarting Caddy...")
        exec.Command("pkill", "caddy").Run()
        return nr.ensureCaddyRunning()</span>
}

// Call this in CreateContainer() before ContainerCreate()
func (nr *nextruntime) createNetworkingConfig() *network.NetworkingConfig <span class="cov0" title="0">{
        // Create a default network confi with caddy in mind
        serviceName := nr.payload.Config.App.Name
        config := &amp;network.NetworkingConfig{
                EndpointsConfig: map[string]*network.EndpointSettings{
                        "nextcore-network": {
                                Aliases: []string{
                                        nr.getContainerName(),
                                        serviceName},
                        },
                },
        }
        config.EndpointsConfig["nextcore-network"].Links = []string{
                "caddy:nextcore-caddy",
        }

        // configure for optimal caddy proxying
        config.EndpointsConfig["nextcore-network"].DriverOpts = map[string]string{
                "com.docker.network.bridge.enable_icc":           "true",
                "com.docker.network.bridge.enable_ip_masquerade": "true",
                "com.docker.network.bridge.host_binding_ipv4":    "0.0.0.0",
                "com.docker.network.driver.mu":                   "1500",
        }

        NextCoreLogger.Debug("configured networking for caddy proxying: %v", config.EndpointsConfig["nextcore-network"])

        return config
}</span>

func (nr *nextruntime) CreateContainer(ctx context.Context) (string, error) <span class="cov0" title="0">{
        // configure container based on metadata
        if err := nr.ensureNetwork(ctx); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("failed to ensure network: %s", err)
                return "", fmt.Errorf("failed to ensure network: %w", err)
        }</span>
        <span class="cov0" title="0">containerConfig := nr.createContainerConfig()
        NextCoreLogger.Debug("the container config is:%+v", containerConfig)
        hostConfig := nr.createHostConfig()
        NextCoreLogger.Debug("the host config is:%+v", hostConfig)
        neworkingConfig := nr.createNetworkingConfig()
        NextCoreLogger.Debug("the networking config looks like this:%+v", neworkingConfig)
        NextCoreLogger.Info("Creating container with name: %s", nr.getContainerName())
        // create the container
        resp, err := nr.dockerclient.ContainerCreate(
                ctx,
                containerConfig,
                hostConfig,
                neworkingConfig,
                nil,
                nr.getContainerName(),
        )

        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Error creating container:%s", err)
                return "", fmt.Errorf("failed to create container:%w", err)
        }</span>
        <span class="cov0" title="0">return resp.ID, nil</span>
}
func (nr *nextruntime) Cleanup(ctx context.Context) error <span class="cov0" title="0">{
        // Only remove network if we created it
        if err := nr.dockerclient.NetworkRemove(ctx, "nextcore-network"); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("failed to remove network :%s", err)
                return fmt.Errorf("failed to remove network: %w", err)
        }</span>
        <span class="cov0" title="0">NextCoreLogger.Info("Removed Docker network: nextcore-network")
        return nil</span>
}
func (nr *nextruntime) createContainerConfig() *container.Config <span class="cov0" title="0">{
        config := &amp;container.Config{
                Image:        nr.getImageName(),
                ExposedPorts: nr.getExposedPorts(),
                Env:          nr.getEnvironmentVariables(),
                Labels:       nr.getLabels(),
        }

        // Configure health check if needed
        if nr.payload.Output == "standalone" </span><span class="cov0" title="0">{
                config.Healthcheck = &amp;container.HealthConfig{
                        Test:     []string{"CMD-SHELL", "curl -f http://localhost:3000/api/health || exit 1"},
                        Interval: 30 * time.Second,
                        Timeout:  10 * time.Second,
                        Retries:  3,
                }
        }</span>

        <span class="cov0" title="0">return config</span>

}

func (nr *nextruntime) createHostConfig() *container.HostConfig <span class="cov0" title="0">{
        hostConfig := &amp;container.HostConfig{
                PortBindings: nr.getPortBindings(),
                RestartPolicy: container.RestartPolicy{
                        Name: "unless-stopped",
                },
                Mounts:      nr.getMounts(),
                Resources:   container.Resources{},
                SecurityOpt: []string{"no-new-privileges"},
        }

        // Configure memory limits based on routes
        if len(nr.payload.RouteInfo.SSRRoutes) &gt; 0 </span><span class="cov0" title="0">{
                hostConfig.Resources.Memory = 512 * 1024 * 1024 // 512MB
        }</span> else<span class="cov0" title="0"> {
                hostConfig.Resources.Memory = 256 * 1024 * 1024 // 256MB
        }</span>

        <span class="cov0" title="0">return hostConfig</span>
}

func (nr *nextruntime) getContainerName() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%s", strings.ToLower(nr.payload.Config.App.Name), nr.payload.GitCommit)
}</span>

func (nr *nextruntime) getImageName() string <span class="cov0" title="0">{
        tag := nr.payload.GitCommit
        if tag == "" </span><span class="cov0" title="0">{
                tag = "latest"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s:%s", strings.ToLower(nr.payload.Config.App.Name), tag)</span>
}

func (nr *nextruntime) getExposedPorts() map[nat.Port]struct{} <span class="cov0" title="0">{
        ports := make(map[nat.Port]struct{})
        ports["3000/tcp"] = struct{}{}

        // Add additional ports if specified in config
        // TODO: This port check is bad find a better way to do it
        if nr.payload.Config != nil &amp;&amp; nr.payload.Config.App.Port != 0 </span><span class="cov0" title="0">{
                ports[nat.Port(string(nr.getPort())+"/tcp")] = struct{}{}
        }</span>
        <span class="cov0" title="0">return ports</span>

}

func (nr *nextruntime) getEnvironmentVariables() []string <span class="cov0" title="0">{
        // TODO: Implement environment variable handling
        var envVars []string
        return envVars
}</span>

func (nr *nextruntime) getPort() string <span class="cov0" title="0">{
        if nr.payload.Config != nil &amp;&amp; nr.payload.Config.App.Port != 0 </span><span class="cov0" title="0">{
                return strconv.Itoa(nr.payload.Config.App.Port)
        }</span>
        <span class="cov0" title="0">return "3000"</span> // Default value
}

// we need this to be more eloborate
func (nr *nextruntime) GetStartCommand() []string <span class="cov0" title="0">{
        if nr.payload.StartCommand != "" </span><span class="cov0" title="0">{
                switch nr.payload.Output </span>{
                case "standalone":<span class="cov0" title="0">
                        return []string{"node", "server.js"}</span>
                case "export":<span class="cov0" title="0">
                        return []string{"npm", "run", "start"}</span>

                }
        }
        <span class="cov0" title="0">return []string{"npm", "start"}</span>
}

func (nr *nextruntime) getLabels() map[string]string <span class="cov0" title="0">{
        lables := map[string]string{
                "appname":     nr.payload.AppName,
                "nextversion": nr.payload.NextVersion,
                "gitcommit":   nr.payload.GitCommit,
                "buildtime":   nr.payload.GeneratedAt,
        }
        // add middleware if info present
        if nr.payload.Middleware != nil </span><span class="cov0" title="0">{
                lables["middlewareruntime"] = nr.payload.Middleware.Runtime
        }</span>

        <span class="cov0" title="0">return lables</span>
}

func (nr *nextruntime) getPortBindings() map[nat.Port][]nat.PortBinding <span class="cov0" title="0">{
        bindings := make(map[nat.Port][]nat.PortBinding)
        port := nr.getPort()
        bindings[nat.Port(string(port)+"/tcp")] = []nat.PortBinding{
                {
                        HostIP:   "0.0.0.0",
                        HostPort: string(port),
                },
        }

        return bindings
}</span>

func (nr *nextruntime) getMounts() []mount.Mount <span class="cov0" title="0">{
        var mounts []mount.Mount

        // Mount static assets if CDN is disabled
        if !nr.payload.CDNEnabled &amp;&amp; nr.payload.AssetsOutputDir != "" </span><span class="cov0" title="0">{
                mounts = append(mounts, mount.Mount{
                        Type:   mount.TypeBind,
                        Source: nr.payload.AssetsOutputDir,
                        Target: "/app/public",
                })
        }</span>

        // Mount image cache if using image optimization
        <span class="cov0" title="0">if nr.payload.HasImageAssets </span><span class="cov0" title="0">{
                cacheDir := filepath.Join(os.TempDir(), "next-image-cache")
                os.MkdirAll(cacheDir, 0755)
                mounts = append(mounts, mount.Mount{
                        Type:   mount.TypeBind,
                        Source: cacheDir,
                        Target: "/tmp/cache",
                })
        }</span>

        <span class="cov0" title="0">return mounts</span>
}

func (nr *nextruntime) ConfigureReverseProxy() error <span class="cov0" title="0">{
        // Generate caddy file content based on nextjs metadata
        caddyfileConfig := nr.GenerateCaddyfile()
        NextCoreLogger.Debug("The caddy configuration is:\n%s", caddyfileConfig)
        // validate before writing
        err := nr.validateCaddyfile(caddyfileConfig)
        if err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("Caddyfile validation failed: %s", err)
                return fmt.Errorf("Caddyfile validation failed: %w", err)
        }</span>
        // write caddy file to appropriate location
        <span class="cov0" title="0">caddyfilePath := filepath.Join("/etc/caddy", "Caddyfile")
        if err := os.MkdirAll(filepath.Dir(caddyfilePath), 0755); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("failed to crate caddy directory:%s", err)
                return fmt.Errorf("failed to create caddy directory:%w", err)

        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(caddyfilePath, []byte(caddyfileConfig), 0644); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("failed to write caddy file :%s", err)
                return fmt.Errorf("failed to wrote Caddyfile:%s", err)
        }</span>

        // reload caddy configuration
        <span class="cov0" title="0">if err := nr.reloadCaddy(); err != nil </span><span class="cov0" title="0">{
                NextCoreLogger.Error("error reloading config:%s", err)
                return fmt.Errorf("failedd to reload Caddy")
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func (nr *nextruntime) GenerateCaddyfile() string <span class="cov0" title="0">{
        if nr == nil || nr.payload == nil || nr.payload.Domain == "" </span><span class="cov0" title="0">{
                NextCoreLogger.Error("nextruntime or payload is nil or domain is empty")
                return ""
        }</span>
        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("{\n")
        // we will have to handle https at proxy level
        sb.WriteString("  auto_https off\n")
        sb.WriteString("  admin off\n")
        sb.WriteString("  admin 0.0.0.0:2019\n")
        sb.WriteString("}\n\n")

        // main server block
        sb.WriteString(nr.payload.Domain + " {\n")
        // handle static assets
        sb.WriteString(nr.generateStaticAssetHandlers())
        // handle api routes
        sb.WriteString(nr.generateAPIHandlers())
        // handle ssr routes
        sb.WriteString(nr.generateSSRHandlers())
        // handle ssg/isr routes
        sb.WriteString(nr.generateStaticPageHandlers())
        // handle middlware routes
        sb.WriteString(nr.generateMiddlewareHandlers())
        // Default reverse proxy to Next.js app
        sb.WriteString(fmt.Sprintf("  reverse_proxy http://%s:%s {\n", nr.payload.Config.App.Name, nr.getPort()))
        sb.WriteString("    header_up X-Forwarded-Proto {scheme}\n")
        sb.WriteString("    header_up X-Real-IP {remote}\n")
        sb.WriteString("    transport http {\n")
        sb.WriteString("      keepalive 32s\n")
        sb.WriteString("      keepalive_interval 30s\n")
        sb.WriteString("    }\n")
        sb.WriteString("  }\n")

        sb.WriteString("}\n")

        return sb.String()</span>
}
func convertRegexToCaddyMatcher(regex string) string <span class="cov0" title="0">{
        // Simple conversion - for more complex cases you might need a better approach
        return strings.TrimPrefix(strings.TrimSuffix(regex, "$"), "^")
}</span>

func (nr *nextruntime) generateAPIHandlers() string <span class="cov0" title="0">{
        if len(nr.payload.RouteInfo.APIRoutes) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("  # API routes\n")

        for _, route := range nr.payload.RouteInfo.APIRoutes </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("  handle %s {\n", route))
                sb.WriteString(fmt.Sprintf("    reverse_proxy http://%s:%s%s {\n",
                        nr.getContainerName(), nr.getPort(), route))
                sb.WriteString("      header_up X-Forwarded-Proto {scheme}\n")
                sb.WriteString("      header_up X-Real-IP {remote}\n")
                sb.WriteString("    }\n")
                sb.WriteString("  }\n\n")
        }</span>

        <span class="cov0" title="0">return sb.String()</span>
}
func (nr *nextruntime) generateMiddlewareHandlers() string <span class="cov0" title="0">{
        if nr.payload.Middleware == nil || len(nr.payload.Middleware.Matchers) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("  # Middleware routes\n")

        for _, matcher := range nr.payload.Middleware.Matchers </span><span class="cov0" title="0">{
                // Convert Next.js middleware matcher to Caddy syntax
                path := matcher.Pathname
                if path == "" &amp;&amp; matcher.Pattern != "" </span><span class="cov0" title="0">{
                        path = convertRegexToCaddyMatcher(matcher.Pattern)
                }</span>

                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("  @%s path %s\n", matcher.Type, path))

                // Add conditions
                for _, condition := range matcher.Has </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("    %s %s %s\n",
                                condition.Type, condition.Key, condition.Value))
                }</span>

                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("  handle @%s {\n", matcher.Type))
                sb.WriteString(fmt.Sprintf("    reverse_proxy http://localhost:%s {\n", nr.getPort()))
                sb.WriteString("      header_up X-Forwarded-Proto {scheme}\n")
                sb.WriteString("      header_up X-Real-IP {remote}\n")
                sb.WriteString("    }\n")
                sb.WriteString("  }\n\n")</span>
        }

        <span class="cov0" title="0">return sb.String()</span>
}
func (nr *nextruntime) generateStaticPageHandlers() string <span class="cov0" title="0">{
        if len(nr.payload.RouteInfo.SSRRoutes) == 0 &amp;&amp; len(nr.payload.RouteInfo.ISRRoutes) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var sb strings.Builder

        // ssg routes
        if len(nr.payload.RouteInfo.SSRRoutes) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString(" # SSG routes\n")
                for route, file := range nr.payload.RouteInfo.SSGRoutes </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("  handle %s {\n", route))
                        sb.WriteString(fmt.Sprintf("   root * %s\n", filepath.Dir(file)))
                        sb.WriteString("     try_files {path} %s\n, filepath.Base(file))")
                        sb.WriteString("     header {\n")
                        sb.WriteString("       Cache-Control \"public, max-age=0 , must-revalidate\"\n")
                        sb.WriteString("    }\n")
                        sb.WriteString("  }\n\n")

                }</span>
        }
        // isr routes
        <span class="cov0" title="0">if len(nr.payload.RouteInfo.ISRRoutes) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString(" # ISR routes\n")
                for route, revalidate := range nr.payload.RouteInfo.ISRRoutes </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("  handle %s {\n", route))
                        sb.WriteString(fmt.Sprintf("    reverse_proxy http://%s:%s {\n", nr.getContainerName(), nr.getPort()))
                        sb.WriteString("      header_up X-Forwarded-Proto {scheme}\n")
                        sb.WriteString("      header_up X-Real-IP {remote}\n")
                        sb.WriteString(fmt.Sprintf("      header Cache-Control \"public, max-age=%s, stale-while-revalidate=60\"\n", revalidate))
                        sb.WriteString("    }\n")
                        sb.WriteString("  }\n\n")
                }</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
}
func (nr *nextruntime) generateStaticAssetHandlers() string <span class="cov0" title="0">{
        var sb strings.Builder

        if len(nr.payload.StaticAssets.PublicDir) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("  # Public directory assets\n")
                sb.WriteString("  handle /public/* {\n")
                sb.WriteString("    root * .nextdeploy/static\n")
                sb.WriteString("    file_server\n")

                // Add caching headers for static assets
                sb.WriteString("    header {\n")
                sb.WriteString("      Cache-Control \"public, max-age=31536000, immutable\"\n")
                sb.WriteString("    }\n")
                sb.WriteString("  }\n\n")
        }</span>

        <span class="cov0" title="0">if len(nr.payload.StaticAssets.NextStatic) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("  # Next.js static assets\n")
                sb.WriteString("  handle /_next/static/* {\n")
                sb.WriteString("    root * .next/static\n")
                sb.WriteString("    file_server\n")
                sb.WriteString("    header {\n")
                sb.WriteString("      Cache-Control \"public, max-age=31536000, immutable\"\n")
                sb.WriteString("    }\n")
                sb.WriteString("  }\n\n")
        }</span>

        <span class="cov0" title="0">return sb.String()</span>
}

func (nr *nextruntime) generateSSRHandlers() string <span class="cov0" title="0">{
        if len(nr.payload.RouteInfo.SSRRoutes) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("  # SSR routes\n")

        for _, route := range nr.payload.RouteInfo.SSRRoutes </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("  handle %s {\n", route))
                sb.WriteString(fmt.Sprintf("    reverse_proxy http://localhost:%s {\n", nr.getPort()))
                sb.WriteString("      header_up X-Forwarded-Proto {scheme}\n")
                sb.WriteString("      header_up X-Real-IP {remote}\n")
                sb.WriteString("    }\n")
                sb.WriteString("  }\n\n")
        }</span>

        <span class="cov0" title="0">return sb.String()</span>
}

func (nr *nextruntime) GetRuntimeStats(ctx context.Context) (container.StatsResponseReader, error) <span class="cov0" title="0">{
        containerName := nr.getContainerName()
        return nr.dockerclient.ContainerStats(ctx, containerName, false)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package nextdeploy

import (
        "errors"
        "fmt"
        "gopkg.in/yaml.v3"
        "nextdeploy/shared"
        "os"
        "path/filepath"
)

// Config represents the structure of a nextdeploy.yml file
// New creates a new Config with default values
var (
        ylogger = shared.PackageLogger("YAML", "‚Ü™ YAML")
)

func New() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Version: "1.0",
                App: AppConfig{
                        Environment: "production",
                        Port:        3000,
                },
                Repository: Repository{
                        Branch:     "main",
                        AutoDeploy: true,
                },
                Docker: DockerConfig{
                        Build: DockerBuild{
                                Context:    ".",
                                Dockerfile: "Dockerfile",
                                NoCache:    false,
                                Args:       make(map[string]string),
                        },
                        Push: true,
                },
                Deployment: Deployment{
                        Server: Server{
                                UseSudo: false,
                        },
                        Container: Container{
                                Restart: "always",
                                Healthcheck: ContainerHealthcheck{
                                        Interval: "30s",
                                        Timeout:  "5s",
                                        Retries:  3,
                                },
                        },
                },
                Logging: Logging{
                        Enabled:    true,
                        Provider:   "nextdeploy",
                        StreamLogs: true,
                },
                Monitoring: Monitoring{
                        Enabled:         true,
                        CPUThreshold:    80,
                        MemoryThreshold: 75,
                        DiskThreshold:   90,
                },
                Backup: Backup{
                        Enabled:       true,
                        Frequency:     "daily",
                        RetentionDays: 7,
                },
                SSL: SSL{
                        Enabled:   true,
                        Provider:  "letsencrypt",
                        AutoRenew: true,
                },
        }
}</span>

// Load reads a nextdeploy.yml file and returns a Config struct
func Load(filename string) (*Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">config := New()
        err = yaml.Unmarshal(data, config)
        if err != nil </span><span class="cov0" title="0">{
                ylogger.Error("Failed to parse YAML")
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// Save writes the Config to a nextdeploy.yml file
func (c *Config) Save(filename string) error <span class="cov0" title="0">{
        data, err := yaml.Marshal(c)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config to YAML: %w", err)
        }</span>

        // Ensure the directory exists
        <span class="cov0" title="0">dir := filepath.Dir(filename)
        if dir != "" </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory: %w", err)
                }</span>
        }

        <span class="cov0" title="0">err = os.WriteFile(filename, data, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateApp updates the app configuration
func (c *Config) UpdateApp(name, environment, domain string, port int) <span class="cov0" title="0">{
        c.App.Name = name
        c.App.Environment = environment
        c.App.Domain = domain
        c.App.Port = port
}</span>

// UpdateRepository updates the repository configuration
func (c *Config) UpdateRepository(url, branch string, autoDeploy bool, webhookSecret string) <span class="cov0" title="0">{
        c.Repository.URL = url
        c.Repository.Branch = branch
        c.Repository.AutoDeploy = autoDeploy
        c.Repository.WebhookSecret = webhookSecret
}</span>

// AddDockerBuildArg adds or updates a Docker build argument
func (c *Config) AddDockerBuildArg(key, value string) <span class="cov0" title="0">{
        if c.Docker.Build.Args == nil </span><span class="cov0" title="0">{
                c.Docker.Build.Args = make(map[string]string)
        }</span>
        <span class="cov0" title="0">c.Docker.Build.Args[key] = value</span>
}

// RemoveDockerBuildArg removes a Docker build argument
func (c *Config) RemoveDockerBuildArg(key string) <span class="cov0" title="0">{
        delete(c.Docker.Build.Args, key)
}</span>

// AddContainerVolume adds a volume to the container configuration
func (c *Config) AddContainerVolume(volume string) error <span class="cov0" title="0">{
        for _, v := range c.Deployment.Container.Volumes </span><span class="cov0" title="0">{
                if v == volume </span><span class="cov0" title="0">{
                        return errors.New("volume already exists")
                }</span>
        }
        <span class="cov0" title="0">c.Deployment.Container.Volumes = append(c.Deployment.Container.Volumes, volume)
        return nil</span>
}

// RemoveContainerVolume removes a volume from the container configuration
func (c *Config) RemoveContainerVolume(volume string) error <span class="cov0" title="0">{
        for i, v := range c.Deployment.Container.Volumes </span><span class="cov0" title="0">{
                if v == volume </span><span class="cov0" title="0">{
                        c.Deployment.Container.Volumes = append(c.Deployment.Container.Volumes[:i], c.Deployment.Container.Volumes[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return errors.New("volume not found")</span>
}

// AddContainerPort adds a port mapping to the container configuration
func (c *Config) AddContainerPort(port string) error <span class="cov0" title="0">{
        for _, p := range c.Deployment.Container.Ports </span><span class="cov0" title="0">{
                if p == port </span><span class="cov0" title="0">{
                        return errors.New("port already exists")
                }</span>
        }
        <span class="cov0" title="0">c.Deployment.Container.Ports = append(c.Deployment.Container.Ports, port)
        return nil</span>
}

// RemoveContainerPort removes a port mapping from the container configuration
func (c *Config) RemoveContainerPort(port string) error <span class="cov0" title="0">{
        for i, p := range c.Deployment.Container.Ports </span><span class="cov0" title="0">{
                if p == port </span><span class="cov0" title="0">{
                        c.Deployment.Container.Ports = append(c.Deployment.Container.Ports[:i], c.Deployment.Container.Ports[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return errors.New("port not found")</span>
}

// AddSuccessWebhook adds a webhook to be triggered on successful deployment
func (c *Config) AddSuccessWebhook(url string) <span class="cov0" title="0">{
        c.Webhook.OnSuccess = append(c.Webhook.OnSuccess, url)
}</span>

// RemoveSuccessWebhook removes a webhook from the success list
func (c *Config) RemoveSuccessWebhook(url string) error <span class="cov0" title="0">{
        for i, u := range c.Webhook.OnSuccess </span><span class="cov0" title="0">{
                if u == url </span><span class="cov0" title="0">{
                        c.Webhook.OnSuccess = append(c.Webhook.OnSuccess[:i], c.Webhook.OnSuccess[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return errors.New("webhook not found")</span>
}

// AddFailureWebhook adds a webhook to be triggered on failed deployment
func (c *Config) AddFailureWebhook(url string) <span class="cov0" title="0">{
        c.Webhook.OnFailure = append(c.Webhook.OnFailure, url)
}</span>

// RemoveFailureWebhook removes a webhook from the failure list
func (c *Config) RemoveFailureWebhook(url string) error <span class="cov0" title="0">{
        for i, u := range c.Webhook.OnFailure </span><span class="cov0" title="0">{
                if u == url </span><span class="cov0" title="0">{
                        c.Webhook.OnFailure = append(c.Webhook.OnFailure[:i], c.Webhook.OnFailure[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return errors.New("webhook not found")</span>
}

// Validate checks if the configuration is valid
func (c *Config) Validate(Config *Config) error <span class="cov0" title="0">{
        if Config.App.Name == "" </span><span class="cov0" title="0">{
                return errors.New("app name is required")
        }</span>
        <span class="cov0" title="0">if Config.App.Domain == "" </span><span class="cov0" title="0">{
                return errors.New("app domain is required")
        }</span>
        <span class="cov0" title="0">if Config.Repository.URL == "" </span><span class="cov0" title="0">{
                return errors.New("repository URL is required")
        }</span>
        <span class="cov0" title="0">if Config.Deployment.Server.Host == "" </span><span class="cov0" title="0">{
                return errors.New("deployment server host is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Config) ConfigOkay() (bool, error) <span class="cov0" title="0">{
        if _, err := os.Stat("nextdeploy.yml"); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("nextdeploy.yml missing - run 'init' first")
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("config file error: %w", err)</span>
        }
        <span class="cov0" title="0">Config, err := Load("nextdeploy.yml")
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to load nextdeploy.yml: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.Validate(Config); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package registry

import (
        "context"
        "errors"
        "fmt"
        "nextdeploy/shared/config"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsConfig "github.com/aws/aws-sdk-go-v2/config"
)

func (e *ECRContext) AwsConfig() (aws.Config, error) <span class="cov0" title="0">{
        if e.Region == "" </span><span class="cov0" title="0">{
                return aws.Config{}, errors.New("ECR region is not set")
        }</span>
        <span class="cov0" title="0">nextconfig, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load configuration: %v", err)
                return aws.Config{}, fmt.Errorf("failed to load configuration: %w", err)
        }</span>
        <span class="cov0" title="0">profile := nextconfig.App.Domain

        cfg, err := awsConfig.LoadDefaultConfig(context.TODO(),
                awsConfig.WithRegion(e.Region),
                awsConfig.WithSharedConfigProfile(profile),
        )
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Unable to load AWS config: %v", err)
                return aws.Config{}, fmt.Errorf("unable to load AWS config: %w", err)
        }</span>
        <span class="cov0" title="0">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package registry

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "nextdeploy/shared/config"
        "nextdeploy/shared/envstore"
        "nextdeploy/shared/git"
        "nextdeploy/shared"
        "os"
        "os/exec"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/service/ecr"
)

var (
        ECRLogger = shared.PackageLogger("ECR", "üÖ∞Ô∏è ECR")
)

type ECRContext struct {
        ECRRepoName string
        ECRRegion   string
        AccessKey   string
        SecretKey   string
        Region      string
}

func NewECRContext() (*ECRContext, error) <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load configuration: %v", err)
                return nil, fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        <span class="cov0" title="0">store, err := envstore.New(
                envstore.WithEnvFile[string](".env"),
        )
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to create env store: %v", err)
                return nil, fmt.Errorf("failed to create env store: %w", err)
        }</span>

        <span class="cov0" title="0">accessKey, err := store.GetEnv("AWS_ACCESS_KEY_ID")
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to get AWS_ACCESS_KEY_ID from env store: %v", err)
                return nil, fmt.Errorf("failed to get AWS_ACCESS_KEY_ID from env store: %w", err)
        }</span>
        <span class="cov0" title="0">secretKey, err := store.GetEnv("AWS_SECRET_ACCESS_KEY")
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to get AWS_SECRET_ACCESS_KEY from env store: %v", err)
                return nil, fmt.Errorf("failed to get AWS_SECRET_ACCESS_KEY from env store: %w", err)
        }</span>
        <span class="cov0" title="0">if accessKey == "" || secretKey == "" </span><span class="cov0" title="0">{
                return nil, errors.New("AWS credentials not found in environment variables")
        }</span>

        <span class="cov0" title="0">return &amp;ECRContext{
                ECRRepoName: cfg.Docker.Image,
                Region:      cfg.Docker.RegistryRegion,
                AccessKey:   accessKey,
                SecretKey:   secretKey,
        }, nil</span>
}
func (ctx ECRContext) ECRURL() string <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load configuration: %v", err)
                return ""
        }</span>
        <span class="cov0" title="0">return cfg.Docker.Image</span>
}

func (ctx ECRContext) FullImageName(image string) string <span class="cov0" title="0">{
        tag, err := git.GetCommitHash()
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to get commit hash: %v", err)
                return fmt.Sprintf("%s:latest", image)
        }</span>
        <span class="cov0" title="0">return image + ":" + tag</span>
}

func (e *ECRContext) EnsureRepository() error <span class="cov0" title="0">{
        cfg, err := e.AwsConfig()
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load AWS config: %v", err)
                return fmt.Errorf("failed to load AWS config: %w", err)
        }</span>
        <span class="cov0" title="0">configs, err := config.Load() // Replace with your profile name
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load configuration: %v", err)
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>
        <span class="cov0" title="0">profile := configs.App.Domain

        identity, err := GetAWSIdentity(profile)
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to get AWS identity: %v", err)
                return err
        }</span>

        // Print formatted results
        <span class="cov0" title="0">fmt.Printf("‚úÖ AWS Profile: %s\n", profile)
        fmt.Printf("   Account ID: %s\n", identity.Account)
        fmt.Printf("   User ID:    %s\n", identity.UserID)
        fmt.Printf("   ARN:        %s\n", identity.ARN)
        ecrClient := ecr.NewFromConfig(cfg)
        _, region, repoName, err := ExtractECRDetails(e.ECRRepoName)
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to extract ECR details: %v", err)
                return fmt.Errorf("failed to extract ECR details: %w", err)
        }</span>
        <span class="cov0" title="0">e.ECRRegion = region
        ECRLogger.Info("Ensuring ECR repository %s exists in region %s", repoName, e.ECRRegion)
        _, err = ecrClient.DescribeRepositories(context.TODO(), &amp;ecr.DescribeRepositoriesInput{
                RepositoryNames: []string{repoName},
        })
        if err != nil &amp;&amp; strings.Contains(err.Error(), "RepositoryNotFoundException") </span><span class="cov0" title="0">{
                ECRLogger.Info("ECR repository %s does not exist, creating it", e.ECRRepoName)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to describe ECR repository: %v", err)
                return fmt.Errorf("failed to describe ECR repository, no such repo exits: %w", err)
        }</span>

        <span class="cov0" title="0">ECRLogger.Info("ECR repository %s already exists", e.ECRRepoName)
        return nil</span>
}

// DockerLoginWithToken performs docker login with an ECR token

func PrepareECRPushContext(ctx context.Context, createRepo bool) error <span class="cov0" title="0">{
        ecrCtx, err := NewECRContext()
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to create ECR context: %v", err)
                return fmt.Errorf("failed to create ECR context: %w", err)
        }</span>

        <span class="cov0" title="0">if createRepo </span><span class="cov0" title="0">{
                if err := ecrCtx.EnsureRepository(); err != nil </span><span class="cov0" title="0">{
                        ECRLogger.Error("Failed to ensure ECR repository exists: %v", err)
                        return fmt.Errorf("failed  to ensure repository exists: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return ecrCtx.Login()</span>
}
func (e *ECRContext) Login() error <span class="cov0" title="0">{
        ECRLogger.Info("Logging in to ECR repository %s in region %s", e.ECRRepoName, e.Region)

        // Validate inputs first
        if e.ECRRepoName == "" || e.Region == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required ECR parameters (repo: %s, region: %s)",
                        e.ECRRepoName, e.Region)
        }</span>

        // Get ECR token with retry logic
        <span class="cov0" title="0">token, err := GetECRTokenWithRetry(e.Region, e.AccessKey, e.SecretKey, "", 3)
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to get ECR token after retries: %v", err)
                return fmt.Errorf("failed to get ECR token: %w", err)
        }</span>

        // Mask token in logs for security
        // Attempt Docker login with timeout
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := DockerLoginWithToken(ctx, token, e.ECRRepoName); err != nil </span><span class="cov0" title="0">{
                // Check for common error patterns
                if strings.Contains(err.Error(), "401 Unauthorized") </span><span class="cov0" title="0">{
                        ECRLogger.Error("Authentication failed - check AWS permissions and credentials")
                        return fmt.Errorf("ecr authentication failed: %w", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("docker login failed: %w", err)</span>
        }

        <span class="cov0" title="0">ECRLogger.Success("Successfully authenticated with ECR")
        return nil</span>
}

func GetECRTokenWithRetry(region, accessKey, secretKey, sessionToken string, maxRetries int) (string, error) <span class="cov0" title="0">{
        var lastErr error
        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                token, err := GetECRToken(accessKey, secretKey, sessionToken)
                if err == nil </span><span class="cov0" title="0">{
                        return token, nil
                }</span>
                <span class="cov0" title="0">lastErr = err
                time.Sleep(time.Duration(i+1) * time.Second)</span> // Exponential backoff
        }
        <span class="cov0" title="0">return "", fmt.Errorf("after %d retries: %w", maxRetries, lastErr)</span>
}

func DockerLoginWithToken(ctx context.Context, token string, registryURL string) error <span class="cov0" title="0">{
        // Validate registry URL format
        if !strings.HasPrefix(registryURL, "http") </span><span class="cov0" title="0">{
                registryURL = "https://" + registryURL
        }</span>

        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "docker", "login", "-u", "AWS", "--password-stdin", registryURL)
        cmd.Stdin = strings.NewReader(token)

        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                // Enhanced error analysis
                errMsg := stderr.String()
                switch </span>{
                case strings.Contains(errMsg, "401 Unauthorized"):<span class="cov0" title="0">
                        return fmt.Errorf("invalid credentials or insufficient permissions")</span>
                case strings.Contains(errMsg, "no such host"):<span class="cov0" title="0">
                        return fmt.Errorf("network error - cannot reach ECR endpoint")</span>
                case strings.Contains(errMsg, "certificate"):<span class="cov0" title="0">
                        return fmt.Errorf("TLS certificate error - check system time")</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("docker login failed: %v\nstderr: %s", err, errMsg)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// func PrepareECRPullContext(ctx context.Context, ecrCtx ECRContext) (string, error) {
//         ECRLogger.Info("Preparing ECR pull context")
//
//         loginCommand := exec.CommandContext(ctx, "aws", "ecr", "get-login-password", "--region", ecrCtx.ECRRegion)
//         var stdout, stderr bytes.Buffer
//         loginCommand.Stdout = &amp;stdout
//         loginCommand.Stderr = &amp;stderr
//
//         err := loginCommand.Run()
//         if err != nil {
//                 ECRLogger.Error("Failed to get ECR login password: %v", err)
//                 return "", fmt.Errorf("failed to get ECR login password: %w\n%s", err, stderr.String())
//         }
//
//         return stdout.String(), nil
// }

func writeCredentialsToEnvFile(accessKey, secretKey string) error <span class="cov0" title="0">{
        ECRLogger.Info("Writing AWS credentials to .env file")
        envFile := ".env"

        existingContent := make(map[string]string)
        if _, err := os.Stat(envFile); err == nil </span><span class="cov0" title="0">{
                fileContent, err := os.ReadFile(envFile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read existing .env file: %w", err)
                }</span>

                <span class="cov0" title="0">for _, line := range strings.Split(string(fileContent), "\n") </span><span class="cov0" title="0">{
                        if strings.HasPrefix(line, "AWS_ACCESS_KEY_ID=") ||
                                strings.HasPrefix(line, "AWS_SECRET_ACCESS_KEY=") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if strings.Contains(line, "=") </span><span class="cov0" title="0">{
                                parts := strings.SplitN(line, "=", 2)
                                existingContent[parts[0]] = parts[1]
                        }</span>
                }
        }

        <span class="cov0" title="0">file, err := os.Create(envFile)
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to create or open .env file: %v", err)
                return fmt.Errorf("failed to create or open .env file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        ECRLogger.Error("Failed to close .env file: %v", closeErr)
                }</span>
        }()

        <span class="cov0" title="0">for key, value := range existingContent </span><span class="cov0" title="0">{
                _, err = file.WriteString(fmt.Sprintf("%s=%s\n", key, value))
                if err != nil </span><span class="cov0" title="0">{
                        ECRLogger.Error("Failed to write existing content to .env file: %v", err)
                        return fmt.Errorf("failed to write existing content to .env file: %w", err)
                }</span>
        }

        <span class="cov0" title="0">_, err = file.WriteString("AWS_ACCESS_KEY_ID=" + accessKey + "\n")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write AWS_ACCESS_KEY_ID to env file: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = file.WriteString("AWS_SECRET_ACCESS_KEY=" + secretKey + "\n")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write AWS_SECRET_ACCESS_KEY to env file: %w", err)
        }</span>

        // CREATE THE PROFILE NOW
        <span class="cov0" title="0">cfg, _ := config.Load()
        profile := cfg.App.Domain
        err = AddAWSProfile(
                profile,
                accessKey,
                secretKey,
        )
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to add AWS profile: %v", err)
                return fmt.Errorf("failed to add AWS profile: %w", err)
        }</span>

        <span class="cov0" title="0">ECRLogger.Info("Wrote AWS credentials to %s", envFile)
        return nil</span>
}

func GetECRToken(accessKey, secretKey, sessionToken string) (string, error) <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load configuration: %v", err)
                return "", fmt.Errorf("failed to load configuration: %w", err)
        }</span>
        <span class="cov0" title="0">image := cfg.Docker.Image
        _, region, repoName, err := ExtractECRDetails(image)
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to extract ECR details: %v", err)
                return "", fmt.Errorf("failed to extract ECR details: %w", err)
        }</span>
        <span class="cov0" title="0">ECRLogger.Debug("Extracted ECR details - Region: %s, Repository Name: %s", region, repoName)
        args := []string{
                "ecr",
                "get-login-password",
                "--region", region,
        }

        cmd := exec.Command("aws", args...)

        // Setup env
        env := os.Environ()
        env = append(env, "AWS_ACCESS_KEY_ID="+accessKey)
        env = append(env, "AWS_SECRET_ACCESS_KEY="+secretKey)
        if sessionToken != "" </span><span class="cov0" title="0">{
                env = append(env, "AWS_SESSION_TOKEN="+sessionToken)
        }</span>
        <span class="cov0" title="0">cmd.Env = env

        fmt.Println("Running AWS CLI with environment:")
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get ECR token here is the issue: %v, stderr: %s", err, stderr.String())
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(stdout.String()), nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package registry

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
)

func AddAWSProfile(profileName, accessKeyId, secretAccessKey string) error <span class="cov0" title="0">{
        // get home dir
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>
        <span class="cov0" title="0">credPath := filepath.Join(homeDir, ".aws", "credentials")
        // Create .aws directory if it doesn't exist
        if err := os.MkdirAll(filepath.Dir(credPath), 0700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .aws directory: %w", err)
        }</span>

        <span class="cov0" title="0">var existingContent string
        if _, err := os.Stat(credPath); err == nil </span><span class="cov0" title="0">{
                content, err := os.ReadFile(credPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read credentials file: %w", err)
                }</span>
                <span class="cov0" title="0">existingContent = string(content)</span>
        }
        // parse existing profiles
        <span class="cov0" title="0">profiles := parseProfiles(existingContent)
        // add/update the profile
        profiles[profileName] = profile{
                AccessKeyID:     accessKeyId,
                SecretAccessKey: secretAccessKey,
        }
        // write back to file
        if err := writeProfiles(credPath, profiles); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write credentials file: %w", err)
        }</span>
        <span class="cov0" title="0">ECRLogger.Info("Added AWS profile %s to %s", profileName, credPath)
        return nil</span>
}

type profile struct {
        AccessKeyID     string
        SecretAccessKey string
}

func parseProfiles(content string) map[string]profile <span class="cov0" title="0">{
        profiles := make(map[string]profile)
        var currentProfile string

        for _, line := range strings.Split(content, "\n") </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Detect profile section
                <span class="cov0" title="0">if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov0" title="0">{
                        currentProfile = strings.Trim(line, "[]")
                        if _, exists := profiles[currentProfile]; !exists </span><span class="cov0" title="0">{
                                profiles[currentProfile] = profile{}
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Parse key-value pairs only within a profile section
                <span class="cov0" title="0">if currentProfile != "" </span><span class="cov0" title="0">{
                        parts := strings.SplitN(line, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                key := strings.TrimSpace(parts[0])
                                value := strings.TrimSpace(parts[1])
                                p := profiles[currentProfile]

                                switch key </span>{
                                case "aws_access_key_id":<span class="cov0" title="0">
                                        p.AccessKeyID = value</span>
                                case "aws_secret_access_key":<span class="cov0" title="0">
                                        p.SecretAccessKey = value</span>
                                }
                                <span class="cov0" title="0">profiles[currentProfile] = p</span>
                        }
                }
        }
        <span class="cov0" title="0">return profiles</span>
}

func writeProfiles(path string, profiles map[string]profile) error <span class="cov0" title="0">{
        var builder strings.Builder

        for name, p := range profiles </span><span class="cov0" title="0">{
                builder.WriteString(fmt.Sprintf("[%s]\n", name))
                builder.WriteString(fmt.Sprintf("aws_access_key_id = %s\n", p.AccessKeyID))
                builder.WriteString(fmt.Sprintf("aws_secret_access_key = %s\n", p.SecretAccessKey))
                builder.WriteString("\n")
        }</span>

        // Write to temp file first
        <span class="cov0" title="0">tempPath := path + ".tmp"
        if err := os.WriteFile(tempPath, []byte(builder.String()), 0600); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Then rename to replace original
        <span class="cov0" title="0">return os.Rename(tempPath, path)</span>
}

type AWSCallerIdentity struct {
        Account string `json:"Account"`
        UserID  string `json:"UserId"`
        ARN     string `json:"Arn"`
}

// GetAWSIdentity fetches the AWS caller identity for a given profile
func GetAWSIdentity(profile string) (*AWSCallerIdentity, error) <span class="cov0" title="0">{
        // Construct the AWS CLI command
        cmd := exec.Command("aws", "sts", "get-caller-identity", "--profile", profile)

        // Run the command and capture output
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AWS CLI error: %v\nOutput: %s", err, string(output))
        }</span>

        // Parse JSON output
        <span class="cov0" title="0">var identity AWSCallerIdentity
        if err := json.Unmarshal(output, &amp;identity); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse AWS response: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;identity, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package registry

import (
        "context"
        "fmt"
        "github.com/aws/aws-sdk-go-v2/aws"
        awsConfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/ecr"
        "github.com/aws/aws-sdk-go-v2/service/iam"
        "github.com/aws/aws-sdk-go-v2/service/iam/types"
        "nextdeploy/shared/config"
        "strings"
)

const (
        policyDocument = `{        
          "Version": "2012-10-17",
                "Statement": [
                {
                        "Effect": "Allow",
                        "Action": [
                        "ecr:GetAuthorizationToken",
                                        "ecr:BatchCheckLayerAvailability",
                                        "ecr:GetDownloadUrlForLayer",
                                        "ecr:GetRepositoryPolicy",
                                        "ecr:DescribeRepositories",
                                        "ecr:ListImages",
                                        "ecr:DescribeImages",
                                        "ecr:BatchGetImage",
                                        "ecr:InitiateLayerUpload",
                                        "ecr:UploadLayerPart",
                                        "ecr:CompleteLayerUpload",
                                        "ecr:PutImage"
                        ],
                        "Resource": "*"
                }
                ]
        }`
)

func CheckUserExists() (bool, error) <span class="cov0" title="0">{
        ECRLogger.Info("Checking if ECR user exists")
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load configuration: %v", err)
                return false, err
        }</span>

        <span class="cov0" title="0">awsCfg, err := awsConfig.LoadDefaultConfig(context.TODO(),
                awsConfig.WithRegion(cfg.Docker.RegistryRegion),
                awsConfig.WithSharedConfigProfile("default"),
        )
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load AWS config: %v", err)
                return false, err
        }</span>

        <span class="cov0" title="0">iamClient := iam.NewFromConfig(awsCfg)
        userName := cfg.App.Domain

        _, err = iamClient.GetUser(context.TODO(), &amp;iam.GetUserInput{
                UserName: aws.String(userName),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to get user %s: %v", userName, err)
                if strings.Contains(err.Error(), "NoSuchEntity") </span><span class="cov0" title="0">{
                        return false, nil // User does not exist
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to check if user exists: %w", err)</span>
        }

        <span class="cov0" title="0">return true, nil</span> // User exists
}
func DeleteECRUserAndPolicy() error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load configuration: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">ECRLogger.Info("Deleting ECR user and policy")

        awsCfg, err := awsConfig.LoadDefaultConfig(context.TODO(),
                awsConfig.WithRegion(cfg.Docker.RegistryRegion))
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load AWS config: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">iamClient := iam.NewFromConfig(awsCfg)
        user := cfg.App.Domain

        err = cleanupUser(iamClient, user)
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to clean up user %s: %v", user, err)
                return err
        }</span>

        <span class="cov0" title="0">ECRLogger.Success("ECR user and policy deleted successfully")
        return nil</span>
}
func cleanupUser(iamClient *iam.Client, userName string) error <span class="cov0" title="0">{
        if err := deleteAccessKeys(iamClient, userName); err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to delete access keys for user %s: %v", userName, err)
                return err
        }</span>

        <span class="cov0" title="0">if err := detachManagedPolicies(iamClient, userName); err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to detach managed policies for user %s: %v", userName, err)
                return err
        }</span>

        <span class="cov0" title="0">if err := deleteInlinePolicies(iamClient, userName); err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to delete inline policies for user %s: %v", userName, err)
                return err
        }</span>

        <span class="cov0" title="0">if err := removeFromGroups(iamClient, userName); err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to remove user %s from groups: %v", userName, err)
                return err
        }</span>

        <span class="cov0" title="0">_, err := iamClient.DeleteUser(context.TODO(), &amp;iam.DeleteUserInput{
                UserName: aws.String(userName),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Warn("User %s does not exist, skipping deletion", userName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func deleteAccessKeys(iamClient *iam.Client, userName string) error <span class="cov0" title="0">{
        output, err := iamClient.ListAccessKeys(context.TODO(), &amp;iam.ListAccessKeysInput{
                UserName: aws.String(userName),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to list access keys for user %s: %v", userName, err)
                return err
        }</span>

        <span class="cov0" title="0">for _, key := range output.AccessKeyMetadata </span><span class="cov0" title="0">{
                _, err := iamClient.DeleteAccessKey(context.TODO(), &amp;iam.DeleteAccessKeyInput{
                        UserName:    aws.String(userName),
                        AccessKeyId: key.AccessKeyId,
                })
                if err != nil </span><span class="cov0" title="0">{
                        ECRLogger.Error("Failed to delete access key %s for user %s: %v", *key.AccessKeyId, userName, err)
                        return err
                }</span>
                <span class="cov0" title="0">ECRLogger.Info("Deleted access key %s for user %s", *key.AccessKeyId, userName)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func detachManagedPolicies(iamClient *iam.Client, userName string) error <span class="cov0" title="0">{
        output, err := iamClient.ListAttachedUserPolicies(context.TODO(), &amp;iam.ListAttachedUserPoliciesInput{
                UserName: aws.String(userName),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to list attached policies for user %s: %v", userName, err)
                return err
        }</span>

        <span class="cov0" title="0">for _, policy := range output.AttachedPolicies </span><span class="cov0" title="0">{
                _, err := iamClient.DetachUserPolicy(context.TODO(), &amp;iam.DetachUserPolicyInput{
                        UserName:  aws.String(userName),
                        PolicyArn: policy.PolicyArn,
                })
                if err != nil </span><span class="cov0" title="0">{
                        ECRLogger.Error("Failed to detach policy %s from user %s: %v", *policy.PolicyName, userName, err)
                        return err
                }</span>
                <span class="cov0" title="0">ECRLogger.Info("Detached policy %s from user %s", *policy.PolicyName, userName)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func deleteInlinePolicies(iamClient *iam.Client, userName string) error <span class="cov0" title="0">{
        output, err := iamClient.ListUserPolicies(context.TODO(), &amp;iam.ListUserPoliciesInput{
                UserName: aws.String(userName),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to list inline policies for user %s: %v", userName, err)
                return err
        }</span>

        <span class="cov0" title="0">for _, policyName := range output.PolicyNames </span><span class="cov0" title="0">{
                _, err := iamClient.DeleteUserPolicy(context.TODO(), &amp;iam.DeleteUserPolicyInput{
                        UserName:   aws.String(userName),
                        PolicyName: aws.String(policyName),
                })
                if err != nil </span><span class="cov0" title="0">{
                        ECRLogger.Error("Failed to delete inline policy %s for user %s: %v", policyName, userName, err)
                        return err
                }</span>
                <span class="cov0" title="0">ECRLogger.Info("Deleted inline policy %s for user %s", policyName, userName)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func removeFromGroups(iamClient *iam.Client, userName string) error <span class="cov0" title="0">{
        output, err := iamClient.ListGroupsForUser(context.TODO(), &amp;iam.ListGroupsForUserInput{
                UserName: aws.String(userName),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to list groups for user %s: %v", userName, err)
                return err
        }</span>

        <span class="cov0" title="0">for _, group := range output.Groups </span><span class="cov0" title="0">{
                _, err := iamClient.RemoveUserFromGroup(context.TODO(), &amp;iam.RemoveUserFromGroupInput{
                        GroupName: aws.String(*group.GroupName),
                        UserName:  aws.String(userName),
                })
                if err != nil </span><span class="cov0" title="0">{
                        ECRLogger.Error("Failed to remove user %s from group %s: %v", userName, *group.GroupName, err)
                        return err
                }</span>
                <span class="cov0" title="0">ECRLogger.Info("Removed user %s from group %s", userName, *group.GroupName)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func DeleteLoginProfile(iamClient *iam.Client, userName string) error <span class="cov0" title="0">{
        _, err := iamClient.DeleteLoginProfile(context.TODO(), &amp;iam.DeleteLoginProfileInput{
                UserName: aws.String(userName),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Warn("Login profile for user %s does not exist, skipping deletion", userName)
        }</span>

        <span class="cov0" title="0">ECRLogger.Info("Deleted login profile for user %s", userName)
        return nil</span>
}

func CreateECRUserAndPolicy() (*types.User, error) <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load configuration: %v", err)
                return nil, fmt.Errorf("failed to load configuration: %w", err)
        }</span>
        <span class="cov0" title="0">awsCfg, err := awsConfig.LoadDefaultConfig(context.TODO(),
                awsConfig.WithRegion(cfg.Docker.RegistryRegion),
                awsConfig.WithSharedConfigProfile("default"),
        )
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to load AWS config: %v", err)
                return nil, fmt.Errorf("failed to load AWS config: %w", err)
        }</span>

        <span class="cov0" title="0">iamClient := iam.NewFromConfig(awsCfg)
        name := cfg.App.Domain

        user, err := createUser(iamClient, name)
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to create IAM user for ECR access: %v", err)
                return nil, fmt.Errorf("failed to create IAM user for ECR access: %w", err)
        }</span>

        <span class="cov0" title="0">policyArn, err := createPolicy(iamClient, name+"-ecr-policy", policyDocument)
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to create IAM policy for ECR access: %v", err)
                return nil, fmt.Errorf("failed to create IAM policy for ECR access: %w", err)
        }</span>

        <span class="cov0" title="0">err = attachPolicyToUser(iamClient, policyArn, name, name+"-ecr-policy")
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to attach policy to user %s: %v", name, err)
                return nil, fmt.Errorf("failed to attach policy %s to user %s: %w", name+"-ecr-policy", name, err)
        }</span>

        <span class="cov0" title="0">ECRLogger.Success("ECR user and policy created successfully")

        accessKey, secretKey, err := createAccessKey(iamClient, name)
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to create access key for ECR user: %v", err)
                return nil, fmt.Errorf("failed to create access key for ECR user: %w", err)
        }</span>

        <span class="cov0" title="0">ECRLogger.Success("ECR user access key created successfully")

        err = writeCredentialsToEnvFile(accessKey, secretKey)
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to write ECR credentials to .env file: %v", err)
                return nil, fmt.Errorf("failed to write ECR credentials to .env file: %w", err)
        }</span>

        <span class="cov0" title="0">ECRLogger.Success("ECR credentials written to env file successfully")
        return user, nil</span>
}

func createUser(iamClient *iam.Client, userName string) (*types.User, error) <span class="cov0" title="0">{
        output, err := iamClient.CreateUser(context.TODO(), &amp;iam.CreateUserInput{
                UserName: aws.String(userName),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to create user %s: %v", userName, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return output.User, nil</span>
}

func createPolicy(iamClient *iam.Client, policyName string, policyDocument string) (string, error) <span class="cov0" title="0">{
        var maxPolicies int32 = 1000
        listPoliciesOutput, err := iamClient.ListPolicies(context.TODO(), &amp;iam.ListPoliciesInput{
                MaxItems: aws.Int32(maxPolicies),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to list policies: %v", err)
                return "", fmt.Errorf("failed to list policies: %w", err)
        }</span>

        <span class="cov0" title="0">for _, policy := range listPoliciesOutput.Policies </span><span class="cov0" title="0">{
                if aws.ToString(policy.PolicyName) == policyName </span><span class="cov0" title="0">{
                        ECRLogger.Info("Policy %s already exists, reusing ARN: %s", policyName, aws.ToString(policy.Arn))
                        return aws.ToString(policy.Arn), nil
                }</span>
        }

        <span class="cov0" title="0">policyOutput, err := iamClient.CreatePolicy(context.TODO(), &amp;iam.CreatePolicyInput{
                PolicyName:     aws.String(policyName),
                PolicyDocument: aws.String(policyDocument),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Info("Policy %s created by another process, looking up ARN", policyName)
                return getPolicyARN(iamClient, policyName)
        }</span>

        <span class="cov0" title="0">ECRLogger.Info("Created new policy %s", policyName)
        return aws.ToString(policyOutput.Policy.Arn), nil</span>
}

func getPolicyARN(iamClient *iam.Client, policyName string) (string, error) <span class="cov0" title="0">{
        var maxPolicies int32 = 1000
        listPoliciesOutput, err := iamClient.ListPolicies(context.TODO(), &amp;iam.ListPoliciesInput{
                MaxItems: aws.Int32(maxPolicies),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to list policies: %v", err)
                return "", fmt.Errorf("failed to list policies: %w", err)
        }</span>

        <span class="cov0" title="0">for _, policy := range listPoliciesOutput.Policies </span><span class="cov0" title="0">{
                if aws.ToString(policy.PolicyName) == policyName </span><span class="cov0" title="0">{
                        return aws.ToString(policy.Arn), nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("policy %s not found after creation conflict", policyName)</span>
}

func attachPolicyToUser(iamClient *iam.Client, policyArn string, userName string, policyName string) error <span class="cov0" title="0">{
        _, err := iamClient.AttachUserPolicy(context.TODO(), &amp;iam.AttachUserPolicyInput{
                UserName:  aws.String(userName),
                PolicyArn: aws.String(policyArn),
        })
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to attach policy %s to user %s: %v", policyName, userName, err)
                return err
        }</span>

        <span class="cov0" title="0">ECRLogger.Info("Attached policy %s to user %s for ECR access", policyName, userName)
        return nil</span>
}

func createAccessKey(iamClient *iam.Client, userName string) (string, string, error) <span class="cov0" title="0">{
        output, err := iamClient.CreateAccessKey(context.TODO(), &amp;iam.CreateAccessKeyInput{
                UserName: aws.String(userName),
        })
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "LimitExceeded") </span><span class="cov0" title="0">{
                        ECRLogger.Warn("Access key limit exceeded for user %s, deleting existing keys", userName)
                        if err := deleteAccessKeys(iamClient, userName); err != nil </span><span class="cov0" title="0">{
                                return "", "", fmt.Errorf("failed to delete existing access keys: %w", err)
                        }</span>
                        <span class="cov0" title="0">output, err = iamClient.CreateAccessKey(context.TODO(), &amp;iam.CreateAccessKeyInput{
                                UserName: aws.String(userName),
                        })</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        ECRLogger.Error("Failed to create access key for user %s: %v", userName, err)
                        return "", "", fmt.Errorf("failed to create access key for user %s: %w", userName, err)
                }</span>
        }

        <span class="cov0" title="0">ECRLogger.Info("Created access key for user %s", userName)
        return aws.ToString(output.AccessKey.AccessKeyId), aws.ToString(output.AccessKey.SecretAccessKey), nil</span>
}

func VerifyECRAccess(region, accessKey, secretKey, sessionToken string) error <span class="cov0" title="0">{
        cfg, err := awsConfig.LoadDefaultConfig(context.TODO(),
                awsConfig.WithRegion(region),
                awsConfig.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(accessKey, secretKey, sessionToken)),
        )
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Unable to load AWS config: %v", err)
                return fmt.Errorf("unable to load AWS config: %w", err)
        }</span>

        <span class="cov0" title="0">ecrClient := ecr.NewFromConfig(cfg)
        _, err = ecrClient.DescribeRepositories(context.TODO(), &amp;ecr.DescribeRepositoriesInput{})
        if err != nil </span><span class="cov0" title="0">{
                ECRLogger.Error("Failed to describe ECR repositories: %v", err)
                if strings.Contains(err.Error(), "AccessDeniedException") </span><span class="cov0" title="0">{
                        return fmt.Errorf("access denied to ECR in region %s with provided credentials", region)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to describe ECR repositories: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package registry

import (
        "context"
        "errors"
        "fmt"
        "io"
        "net/http"
        "nextdeploy/shared"
        "nextdeploy/shared/config"
        "nextdeploy/shared/envstore"
        "nextdeploy/shared/git"
        "os"
        "os/exec"
        "strings"
)

var (
        oceanlogs = shared.PackageLogger("DIGITALOCEAN", "DIGITALOCEAN")
)

func DigitalOceanRegistry(ctx context.Context) error <span class="cov0" title="0">{
        // Ensure the registry is set up
        if err := ensureRegistrySetup(); err != nil </span><span class="cov0" title="0">{
                oceanlogs.Error("Failed to ensure registry setup: %v", err)
                return fmt.Errorf("failed to ensure registry setup: %w", err)
        }</span>
        // Push the Docker image to the DigitalOcean registry
        <span class="cov0" title="0">if err := pushDockerImage(); err != nil </span><span class="cov0" title="0">{
                oceanlogs.Error("Failed to push Docker image: %v", err)
                return fmt.Errorf("failed to push Docker image: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func ensureRegistrySetup() error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                oceanlogs.Error("Failed to load config: %v", err)
                return fmt.Errorf("failed to load config: %w", err)
        }</span>
        // Check if the registry is already set up
        <span class="cov0" title="0">registryURL := cfg.Docker.Registry
        digitalocean := strings.Contains(registryURL, "digitalocean.com")

        if digitalocean &amp;&amp; registryURL != "" </span><span class="cov0" title="0">{
                fmt.Println("DigitalOcean registry is already set up:", registryURL)
                return nil
        }</span>
        <span class="cov0" title="0">store, err := envstore.New(envstore.WithEnvFile[string](".env"))
        oceanlogs.Info("Loading .env file for DigitalOcean registry setup:%v", store)
        if err != nil </span><span class="cov0" title="0">{
                oceanlogs.Error("Failed to load .env file: %v", err)
                return fmt.Errorf("failed to load .env file: %w", err)
        }</span>
        <span class="cov0" title="0">token, _ := store.GetEnv("DIGITALOCEAN_TOKEN")
        oceanlogs.Debug("DigitalOcean token: %s", token)
        if token == "" </span><span class="cov0" title="0">{
                oceanlogs.Error("DigitalOcean token is not set in .env file")
                return errors.New("digitalocean token is not set in .env file")
        }</span>
        <span class="cov0" title="0">result, err := GetRegistryInfo(token)
        oceanlogs.Info("DigitalOcean registry info: %s", string(result))
        if err != nil </span><span class="cov0" title="0">{
                oceanlogs.Error("Failed to get registry info: %v", err)
                return fmt.Errorf("failed to get registry info: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("DigitalOcean registry info:", string(result))
        return nil</span>
}

func GetRegistryInfo(token string) ([]byte, error) <span class="cov0" title="0">{
        // create a http clinent
        client := &amp;http.Client{}
        // create request
        req, err := http.NewRequest("GET", "https://api.digitalocean.com/v2/registry", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        // set headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))

        // send request
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get registry info: %s", resp.Status)
        }</span>
        // read response body
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>
        <span class="cov0" title="0">return body, nil</span>
}
func pushDockerImage() error <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>
        <span class="cov0" title="0">registryURL := cfg.Docker.Registry
        if registryURL == "" </span><span class="cov0" title="0">{
                return errors.New("registry URL is not set")
        }</span>
        <span class="cov0" title="0">commit, err := git.GetCommitHash()
        name := cfg.Docker.Image + ":" + commit
        oceanlogs.Info("Pushing Docker image to DigitalOcean registry: %s", name)
        imageName := fmt.Sprintf("%s/%s", registryURL, name)
        fmt.Println("Pushing Docker image:", imageName)

        // tag the Docker image
        cmdTag := exec.Command("docker", "tag", name, imageName)
        cmdTag.Stdout = os.Stdout
        cmdTag.Stderr = os.Stderr
        if err := cmdTag.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to tag Docker image: %w", err)
        }</span>

        // Push the Docker image to the DigitalOcean registry
        <span class="cov0" title="0">cmd := exec.Command("docker", "push", imageName)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to push Docker image: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Docker image pushed successfully:", imageName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package registry

import (
        "bufio"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/url"
        "nextdeploy/shared/config"
        "nextdeploy/shared/git"
        "nextdeploy/shared"
        "os/exec"
        "regexp"
        "strings"
        "time"
)

var (
        rlogger = shared.PackageLogger("RegistryValidator", "üÖ∞Ô∏è REGISTRY VALIDATOR")

        // imageNameRegex validates complete Docker image names
        imageNameRegex = regexp.MustCompile(`^([a-zA-Z0-9\-\.]+(?::[0-9]+)?/)?[a-z0-9]+(?:[._-][a-z0-9]+)*(/[a-z0-9]+(?:[._-][a-z0-9]+)*)*(?::[a-zA-Z0-9_\-\.]+)?$`)

        // tagRegex validates standalone image tags
        tagRegex = regexp.MustCompile(`^[a-zA-Z0-9_\-\.]+$`)
)

type RegistryValidator struct {
        cfg      *config.NextDeployConfig
        registry string
        image    string
        username string
        password string
        appName  string
}

// New creates a new RegistryValidator instance
func New() (*RegistryValidator, error) <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                rlogger.Error("Failed to load configuration: %v", err)
                return nil, fmt.Errorf("failed to load configuration: %w", err)
        }</span>
        <span class="cov0" title="0">if cfg == nil </span><span class="cov0" title="0">{
                return nil, errors.New("configuration cannot be nil")
        }</span>

        <span class="cov0" title="0">rv := &amp;RegistryValidator{
                cfg:      cfg,
                registry: cfg.Docker.Registry,
                image:    cfg.Docker.Image,
                username: cfg.Docker.Username,
                password: cfg.Docker.Password,
                appName:  cfg.App.Name,
        }

        if err := rv.ValidateConfig(); err != nil </span><span class="cov0" title="0">{
                rlogger.Error("Invalid registry configuration: %v", err)
                return nil, fmt.Errorf("invalid registry configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return rv, nil</span>
}

// ValidateConfig checks all required registry configuration
func (rv *RegistryValidator) ValidateConfig() error <span class="cov0" title="0">{
        if err := validateRequired("registry", rv.registry); err != nil </span><span class="cov0" title="0">{
                rlogger.Error("Registry validation failed: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">if !rv.IsValidRegistry(rv.registry) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid registry format: %s", rv.registry)
        }</span>

        <span class="cov0" title="0">if err := validateRequired("image", rv.image); err != nil </span><span class="cov0" title="0">{
                rlogger.Error("Image validation failed: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">if !isValidImageName(rv.image) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid image name format: %s", rv.image)
        }</span>

        <span class="cov0" title="0">if rv.NeedsAuth() </span><span class="cov0" title="0">{
                if err := validateRequired("username", rv.username); err != nil </span><span class="cov0" title="0">{
                        rlogger.Error("Username validation failed: %v", err)
                        return err
                }</span>
                <span class="cov0" title="0">if err := validateRequired("password", rv.password); err != nil </span><span class="cov0" title="0">{
                        rlogger.Error("Password validation failed: %v", err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// PushImage handles the complete image push workflow
func (rv *RegistryValidator) PushImage(localImage string) error <span class="cov0" title="0">{
        if localImage == "" </span><span class="cov0" title="0">{
                var err error
                localImage, err = rv.findLocalImage()
                if err != nil </span><span class="cov0" title="0">{
                        rlogger.Error("Failed to find local image: %v", err)
                        return fmt.Errorf("failed to find local image: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if err := validateLocalImage(localImage); err != nil </span><span class="cov0" title="0">{
                rlogger.Error("Invalid local image: %v", err)
                return fmt.Errorf("invalid local image: %w", err)
        }</span>

        <span class="cov0" title="0">targetTag, err := rv.BuildTargetTag()
        if err != nil </span><span class="cov0" title="0">{
                rlogger.Error("Failed to build target tag: %v", err)
                return fmt.Errorf("failed to build target tag: %w", err)
        }</span>

        <span class="cov0" title="0">if err := rv.tagImage(localImage, targetTag); err != nil </span><span class="cov0" title="0">{
                rlogger.Error("Failed to tag image: %v", err)
                return fmt.Errorf("failed to tag image: %w", err)
        }</span>

        <span class="cov0" title="0">if err := rv.pushImage(targetTag); err != nil </span><span class="cov0" title="0">{
                rlogger.Error("Failed to push image: %v", err)
                return fmt.Errorf("failed to push image: %w", err)
        }</span>

        <span class="cov0" title="0">rlogger.Success("Successfully pushed image %s to %s", localImage, targetTag)
        return nil</span>
}

// BuildTargetTag constructs the complete target image tag
func (rv *RegistryValidator) BuildTargetTag() (string, error) <span class="cov0" title="0">{
        tag, err := git.GetCommitHash()
        if err != nil </span><span class="cov0" title="0">{
                rlogger.Error("Failed to get commit hash: %v", err)
                return "", fmt.Errorf("failed to get commit hash: %w", err)
        }</span>

        <span class="cov0" title="0">if !isValidTag(tag) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid tag format: %s", tag)
        }</span>

        <span class="cov0" title="0">registry := normalizeRegistry(rv.registry)
        image := stripTag(rv.image)

        fullTag := fmt.Sprintf("%s/%s:%s", registry, image, tag)
        if !imageNameRegex.MatchString(fullTag) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid image tag format: %s", fullTag)
        }</span>

        <span class="cov0" title="0">return fullTag, nil</span>
}

// GeneratePullSecret creates Kubernetes image pull secret manifest
func (rv *RegistryValidator) GeneratePullSecret() (string, error) <span class="cov0" title="0">{
        if !rv.NeedsAuth() </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">authConfig := map[string]interface{}{
                "auths": map[string]interface{}{
                        rv.registry: map[string]string{
                                "username": rv.username,
                                "password": rv.password,
                                "auth":     base64.StdEncoding.EncodeToString([]byte(rv.username + ":" + rv.password)),
                        },
                },
        }

        configJSON, err := json.Marshal(authConfig)
        if err != nil </span><span class="cov0" title="0">{
                rlogger.Error("Failed to marshal auth config: %v", err)
                return "", fmt.Errorf("failed to marshal auth config: %w", err)
        }</span>

        <span class="cov0" title="0">secretName := strings.ReplaceAll(rv.appName, " ", "-") + "-regcred"

        return fmt.Sprintf(`
apiVersion: v1
kind: Secret
metadata:
  name: %s
  creationTimestamp: %s
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: %s
`, secretName, time.Now().Format(time.RFC3339), base64.StdEncoding.EncodeToString(configJSON)), nil</span>
}

// NeedsAuth checks if registry requires authentication
func (rv *RegistryValidator) NeedsAuth() bool <span class="cov0" title="0">{
        return !strings.HasPrefix(rv.registry, "localhost") &amp;&amp;
                !strings.HasPrefix(rv.registry, "127.0.0.1")
}</span>

// RegistryType identifies the registry provider
func (rv *RegistryValidator) RegistryType() string <span class="cov0" title="0">{
        reg := strings.ToLower(rv.registry)

        switch </span>{
        case strings.Contains(reg, "ghcr.io"):<span class="cov0" title="0">
                return "github"</span>
        case strings.Contains(reg, "ecr.aws"):<span class="cov0" title="0">
                return "ecr"</span>
        case strings.Contains(reg, "gcr.io"):<span class="cov0" title="0">
                return "gcr"</span>
        case strings.Contains(reg, "azurecr.io"):<span class="cov0" title="0">
                return "acr"</span>
        case strings.Contains(reg, "docker.io"):<span class="cov0" title="0">
                return "dockerhub"</span>
        case strings.Contains(reg, "digitalocean"):<span class="cov0" title="0">
                return "do-registry"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Helper methods
func (rv *RegistryValidator) findLocalImage() (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("docker", "images", "--format", "{{.Repository}}:{{.Tag}}", stripTag(rv.image))
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("docker images failed: %w\nOutput: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">images := strings.Split(strings.TrimSpace(string(output)), "\n")
        for _, img := range images </span><span class="cov0" title="0">{
                if img != "" &amp;&amp; isValidImageName(img) </span><span class="cov0" title="0">{
                        return img, nil
                }</span>
        }

        <span class="cov0" title="0">return "", errors.New("no valid local images found")</span>
}

func (rv *RegistryValidator) tagImage(source, target string) error <span class="cov0" title="0">{
        rlogger.Info("Tagging %s as %s", source, target)

        cmd := exec.Command("docker", "tag", source, target)
        if output, err := cmd.CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("docker tag failed: %w\nOutput: %s", err, string(output))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (rv *RegistryValidator) pushImage(image string) error <span class="cov0" title="0">{
        rlogger.Info("Pushing image %s", image)

        // cmd := exec.Command("docker", "push", image)
        // stdout, _ := cmd.StdoutPipe()
        // stderr, _ := cmd.StderrPipe()

        // if err := cmd.Start(); err != nil {
        //         return fmt.Errorf("docker push failed to start: %w", err)
        // }
        //
        // go streamOutput(stdout, "stdout")
        // go streamOutput(stderr, "stderr")
        //
        // if err := cmd.Wait(); err != nil {
        //         return fmt.Errorf("docker push failed: %w", err)
        // }
        //
        return nil
}</span>

func StreamOutput(reader io.Reader, label string) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(reader)
        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if strings.Contains(line, "error") </span><span class="cov0" title="0">{
                        rlogger.Error("[%s] %s", label, line)
                }</span> else<span class="cov0" title="0"> {
                        rlogger.Debug("[%s] %s", label, line)
                }</span>
        }
}

// Validation functions
func validateRequired(name, value string) error <span class="cov0" title="0">{
        if strings.TrimSpace(value) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is required", name)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (rv *RegistryValidator) IsValidRegistry(registry string) bool <span class="cov0" title="0">{
        registry = strings.TrimSpace(registry)
        return registry != "" &amp;&amp;
                !strings.Contains(registry, " ") &amp;&amp;
                !strings.HasPrefix(registry, "/") &amp;&amp;
                !strings.HasSuffix(registry, "/") &amp;&amp;
                isValidURL("https://"+registry)
}</span>

func isValidURL(rawURL string) bool <span class="cov0" title="0">{
        _, err := url.ParseRequestURI(rawURL)
        return err == nil
}</span>

func isValidImageName(image string) bool <span class="cov0" title="0">{
        return strings.TrimSpace(image) != "" &amp;&amp;
                !strings.ContainsAny(image, " \t\n\r") &amp;&amp;
                imageNameRegex.MatchString(image)
}</span>

func isValidTag(tag string) bool <span class="cov0" title="0">{
        return len(tag) &lt;= 128 &amp;&amp; tagRegex.MatchString(tag)
}</span>

func validateLocalImage(image string) error <span class="cov0" title="0">{
        if !isValidImageName(image) &amp;&amp; !strings.HasPrefix(image, "sha256:") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid local image reference: %s", image)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func normalizeRegistry(registry string) string <span class="cov0" title="0">{
        registry = strings.TrimPrefix(registry, "https://")
        registry = strings.TrimPrefix(registry, "http://")
        return strings.TrimSuffix(registry, "/")
}</span>

func stripTag(image string) string <span class="cov0" title="0">{
        return strings.Split(image, ":")[0]

}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package registry

import (
        "fmt"
        "nextdeploy/shared/config"
        "nextdeploy/shared/git"
        "regexp"
        "strings"
)

func ExtractECRDetails(ecrURI string) (string, string, string, error) <span class="cov0" title="0">{
        // Trim whitespace (in case input has leading/trailing spaces)
        trimmedURI := strings.TrimSpace(ecrURI)

        // Regex to validate and extract parts
        // Format: `ACCOUNT.dkr.ecr.REGION.amazonaws.com/REPO_NAME`
        re := regexp.MustCompile(`^([0-9]+)\.dkr\.ecr\.([a-z0-9-]+)\.amazonaws\.com/(.+)$`)
        matches := re.FindStringSubmatch(trimmedURI)

        if len(matches) &lt; 4 </span><span class="cov0" title="0">{
                return "", "", "", fmt.Errorf("invalid ECR URI format: %s", trimmedURI)
        }</span>

        <span class="cov0" title="0">accountID := matches[1]
        region := matches[2]
        repoName := matches[3]

        // matches[0] = full string
        // matches[1] = account ID (285688593966)
        // matches[2] = region (us-east-1)
        // matches[3] = repo name (hersiyussuf/hersi.dev)
        return accountID, region, repoName, nil</span>
}

func GetLatestImageName() string <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to load configuration: %v\n", err)
                return ""
        }</span>
        <span class="cov0" title="0">gitCommit, err := git.GetCommitHash()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to get git commit hash: %v\n", err)
                return ""
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s:%s", cfg.Docker.Image, gitCommit)</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package secrets

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "errors"
        "io"
)

// encrypt data using aes-gcm with provided key
func Encrypt(plaintext []byte, key []byte) ([]byte, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrEncryptFailed
        }</span>
        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrEncryptFailed
        }</span>

        <span class="cov0" title="0">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, ErrEncryptFailed
        }</span>
        <span class="cov0" title="0">ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
        return []byte(base64.StdEncoding.EncodeToString(ciphertext)), nil</span>
}

// decrypt data using aes-gcm with provided key
func Decrypt(ciphertext []byte, key []byte) ([]byte, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrDecryptFailed
        }</span>
        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrDecryptFailed
        }</span>
        <span class="cov0" title="0">nonceSize := gcm.NonceSize()
        if len(ciphertext) &lt; nonceSize </span><span class="cov0" title="0">{
                return nil, ErrDecryptFailed
        }</span>
        <span class="cov0" title="0">nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
        plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrDecryptFailed
        }</span>
        <span class="cov0" title="0">return plaintext, nil</span>
}

// GenerateKey creates a SHA-256 hash of the provided key
func DeriveKey(key string) ([]byte, error) <span class="cov0" title="0">{
        if key == "" </span><span class="cov0" title="0">{
                return nil, errors.New("key cannot be empty")
        }</span>
        <span class="cov0" title="0">hash := sha256.Sum256([]byte(key))
        return hash[:], nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package secrets

func (sm *SecretManager) IsDopplerEnabled() bool <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        if sm.manager == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">_, exists := sm.manager.providers["doppler"]
        return exists</span>
}
func (sm *SecretManager) GetDopplerProvider() (SecretProvider, bool) <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        if sm.manager == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">provider, exists := sm.manager.providers["doppler"]
        return provider, exists</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package secrets

import (
        "bytes"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
)

// EncryptEnvFile encrypts .env files using OpenSSL
func (sm *SecretManager) EncryptEnvFile(masterKey string) (map[string]string, error) <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get current working directory: %w", err)
        }</span>

        <span class="cov0" title="0">files, err := filepath.Glob(filepath.Join(cwd, "*.env"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find .env files: %w", err)
        }</span>

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                SLogs.Warn("No .env files found in the current directory")
                return nil, nil
        }</span>

        <span class="cov0" title="0">results := make(map[string]string)
        for _, file := range files </span><span class="cov0" title="0">{
                SLogs.Info("Encrypting .env file: %s", file)

                encryptedFile := file + ".enc"
                err := sm.encryptWithOpenSSL(file, encryptedFile, masterKey)
                if err != nil </span><span class="cov0" title="0">{
                        SLogs.Error("Failed to encrypt file %s: %v", file, err)
                        return nil, fmt.Errorf("%w: %v", ErrEncryptionFailed, err)
                }</span>

                <span class="cov0" title="0">results[file] = encryptedFile</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// EncryptFile encrypts a file using OpenSSL AES-256-CBC
func (sm *SecretManager) EncryptFile(filename string, key []byte) error <span class="cov0" title="0">{
        encryptedFilename := filename + ".enc"
        return sm.encryptWithOpenSSL(filename, encryptedFilename, string(key))
}</span>

// encryptWithOpenSSL is the core OpenSSL encryption function
func (sm *SecretManager) encryptWithOpenSSL(inputPath, outputPath, password string) error <span class="cov0" title="0">{
        cmd := exec.Command("openssl", "enc", "-aes-256-cbc", "-salt",
                "-in", inputPath, "-out", outputPath, "-pass", "pass:"+password, "-pbkdf2")

        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("openssl encryption failed: %v, stderr: %s", err, stderr.String())
        }</span>

        // Set secure permissions
        <span class="cov0" title="0">if err := os.Chmod(outputPath, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set permissions on encrypted file: %w", err)
        }</span>

        <span class="cov0" title="0">SLogs.Info("Successfully encrypted file %s to %s", inputPath, outputPath)
        return nil</span>
}

// DecryptFile decrypts a file using OpenSSL AES-256-CBC
func (sm *SecretManager) DecryptFile(filename string, key []byte) (string, error) <span class="cov0" title="0">{
        if !strings.HasSuffix(filename, ".enc") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("file %s is not an encrypted file", filename)
        }</span>

        <span class="cov0" title="0">decryptedFilename := strings.TrimSuffix(filename, ".enc")

        command, err := sm.decryptWithOpenSSL(filename, decryptedFilename, string(key))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decrypt file %s: %w", filename, err)
        }</span>
        <span class="cov0" title="0">SLogs.Info("Decrypted file %s to %s using command: %s", filename, decryptedFilename, command)

        return command, nil</span>
}

// decryptWithOpenSSL is the core OpenSSL decryption function
func (sm *SecretManager) decryptWithOpenSSL(inputPath, outputPath, password string) (string, error) <span class="cov0" title="0">{
        // decrypt command is
        command := "openssl enc -d -aes-256-cbc -in .env.enc -out .env -pass pass:%password"
        return command, nil
}</span>

// processSingleEnvFile handles decryption of a single environment file using OpenSSL
func (sm *SecretManager) ProcessSingleEnvFile(path, key string) (*EnvFile, error) <span class="cov0" title="0">{
        // SLogs.Debug("Processing env file: %s", path)
        //
        // decryptedPath := strings.TrimSuffix(path, ".enc")
        // if err := sm.decryptWithOpenSSL(path, decryptedPath, key); err != nil {
        //         return nil, fmt.Errorf("decryption failed: %w", err)
        // }
        //
        // content, err := os.ReadFile(decryptedPath)
        // if err != nil {
        //         return nil, fmt.Errorf("read failed: %w", err)
        // }
        //
        // SLogs.Info("Decrypted env file written to %s", decryptedPath)
        // return &amp;EnvFile{
        //         EncryptedPath: path,
        //         DecryptedPath: decryptedPath,
        //         Content:       content,
        // }, nil
        return nil, fmt.Errorf("processSingleEnvFile is not implemented yet")
}</span>

// ProcessConfigFile processes the config file using OpenSSL
func (sm *SecretManager) ProcessConfigFile(cwd, key string) (*ConfigFile, error) <span class="cov0" title="0">{
        // const configFileName = "nextdeploy.yml"
        // encryptedPath := filepath.Join(cwd, configFileName+".enc")
        //
        // // Verify config file exists
        // if _, err := os.Stat(encryptedPath); os.IsNotExist(err) {
        //         // We can encrypt the file here
        //         _, err := os.ReadFile(filepath.Join(cwd, configFileName))
        //         if err != nil {
        //                 return nil, fmt.Errorf("failed to read config file: %w", err)
        //         }
        // }
        //
        // // Decrypt config using OpenSSL
        // decryptedPath := filepath.Join(cwd, configFileName)
        // if err := sm.decryptWithOpenSSL(encryptedPath, decryptedPath, key); err != nil {
        //         return nil, fmt.Errorf("config decryption failed: %w", err)
        // }
        //
        // return &amp;ConfigFile{
        //         EncryptedPath: encryptedPath,
        // }, nil
        return nil, fmt.Errorf("ProcessConfigFile is not implemented yet")
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package secrets

import (
        "encoding/base64"
        "errors"
        "fmt"
        "github.com/zalando/go-keyring"
        "os"
        "path/filepath"

        "crypto/rand"
        "runtime"
)

func (sm *SecretManager) getCachedKey(name string) (string, error) <span class="cov0" title="0">{
        if key, exists := sm.keyCache[name]; exists </span><span class="cov0" title="0">{
                return string(key), nil
        }</span>

        <span class="cov0" title="0">key, err := sm.GeneratePlatformKey()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">sm.keyCache[name] = []byte(key)
        return key, nil</span>
}
func (sm *SecretManager) GenerateMasterKey() ([]byte, error) <span class="cov0" title="0">{
        key := make([]byte, 32)
        if _, err := rand.Read(key); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %v", ErrKeyGenerationFailed, err)
        }</span>
        <span class="cov0" title="0">return key, nil</span>
}

// GenerateWindowsKey generates a key for Windows platforms
func (sm *SecretManager) GenerateWindowsKey() (string, error) <span class="cov0" title="0">{
        // Windows-specific key generation logic could go here
        // For now, we'll use the same approach as other platforms
        key, err := sm.GenerateMasterKey()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate master key for Windows: %w", err)
        }</span>
        // Convert to hex string for storage
        <span class="cov0" title="0">return string(key), nil</span>
}

func (sm *SecretManager) GeneratePlatformKey() (string, error) <span class="cov0" title="0">{
        currentOS := runtime.GOOS
        SLogs.Debug("Generating platform key for OS: %s", currentOS)
        switch currentOS </span>{
        case "linux", "darwin":<span class="cov0" title="0"> // Linux or macOS
                return sm.derivePlatformKey("linux-mac-salt")</span>
        case "windows":<span class="cov0" title="0"> // Windows
                return sm.derivePlatformKey("windows-salt")</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("%w: %s", ErrUnsupportedPlatform, currentOS)</span>
        }
}

func (sm *SecretManager) derivePlatformKey(salt string) (string, error) <span class="cov0" title="0">{
        masterkey, err := sm.getOrCreateMasterKey()
        SLogs.Debug("Using master key: %s", masterkey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get or create master key: %w", err)
        }</span>
        // Logout the derivePlatformKey
        <span class="cov0" title="0">SLogs.Debug("Derived key: %s", masterkey)
        return base64.StdEncoding.EncodeToString(masterkey), nil</span>
}

func (sm *SecretManager) getOrCreateMasterKey() ([]byte, error) <span class="cov0" title="0">{
        // Try to load existing key
        key, err := sm.loadMasterKey()
        if err == nil </span><span class="cov0" title="0">{
                SLogs.Debug("Master key loaded successfully: %s", key)
                return key, nil
        }</span>
        <span class="cov0" title="0">SLogs.Debug("Master key not found, generating new key")
        if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load master key: %w", err)
        }</span>
        // generate new key if none exists
        <span class="cov0" title="0">newKey, err := sm.GenerateMasterKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate new master key: %w", err)
        }</span>
        <span class="cov0" title="0">return []byte(newKey), nil</span>
}

func (sm *SecretManager) loadMasterKey() ([]byte, error) <span class="cov0" title="0">{
        // platform specifc secure storage
        switch runtime.GOOS </span>{
        case "linux", "darwin":<span class="cov0" title="0">
                return sm.loadUnixKey()</span>
        case "windows":<span class="cov0" title="0">
                key, err := sm.loadWindowsKey()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate master key for Windows: %w", err)
                }</span>

                <span class="cov0" title="0">return []byte(key), nil</span>
        default:<span class="cov0" title="0">
                return nil, ErrUnsupportedPlatform</span>
        }
}

func (sm *SecretManager) storeMasterKey(key []byte) error <span class="cov0" title="0">{
        // platform specific secure storage
        switch runtime.GOOS </span>{
        case "linux", "darwin":<span class="cov0" title="0">
                SLogs.Debug("The key that is supposed to stored is :%s", key)
                return sm.storeUnixKey(key)</span>
        case "windows":<span class="cov0" title="0">
                return sm.storeWindowsKey(key)</span>
        default:<span class="cov0" title="0">
                return ErrUnsupportedPlatform</span>
        }
}

func (sm *SecretManager) storeUnixKey(key []byte) error <span class="cov0" title="0">{
        appname := sm.cfg.App.Name

        // get home directory
        homedir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov0" title="0">SLogs.Debug("Storing master key in keyring for app: %s", appname)

        // Create application directory
        appDir := filepath.Join(homedir, ".nextdeploy", appname)
        if err := os.MkdirAll(appDir, 0700); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create app directory: %w", err)
        }</span>

        // Set full key path
        <span class="cov0" title="0">keyPath := filepath.Join(appDir, "master.key")
        SLogs.Debug("Key path for master key: %s", keyPath)

        // Write key file with restricted permissions
        if err := os.WriteFile(keyPath, key, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write master key to file: %w", err)
        }</span>

        <span class="cov0" title="0">SLogs.Success("Successfully stored master key at: %s", keyPath)
        return nil</span>
}
func (sm *SecretManager) IsKeyExist() bool <span class="cov0" title="0">{
        // Check if the key exists in the keyring
        switch runtime.GOOS </span>{
        case "linux", "darwin":<span class="cov0" title="0">
                return sm.isUnixKeyExist()</span>
        case "windows":<span class="cov0" title="0">
                return sm.isWindowsKeyExist()</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
func (sm *SecretManager) isUnixKeyExist() bool <span class="cov0" title="0">{
        const filename = "master.key"
        // Validate configuration
        if sm.cfg == nil || sm.cfg.App.Name == "" </span><span class="cov0" title="0">{
                SLogs.Error("Invalid configuration: app name not set")
                return false
        }</span>
        // Setup paths
        <span class="cov0" title="0">homedir, _ := os.UserHomeDir()
        filePath := homedir + "/.nextdeploy/" + sm.cfg.App.Name + "/" + filename
        file, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                SLogs.Error("Failed to check if master key exists: %v", err)
                return false
        }</span>
        <span class="cov0" title="0">if file != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if os.IsNotExist(err) </span><span class="cov0" title="0">{
                SLogs.Debug("Master key does not exist at: %s", filePath)
                return false
        }</span> else<span class="cov0" title="0"> {
                SLogs.Error("Error checking master key existence: %v", err)
                return false
        }</span>
}
func (sm *SecretManager) isWindowsKeyExist() bool <span class="cov0" title="0">{
        // appname := sm.cfg.App.Name
        // _, err := keyring.Get(appname, "master_key")
        // if err != nil {
        //         if errors.Is(err, keyring.ErrNotFound) {
        //                 SLogs.Debug("Master key not found in Windows keyring")
        //                 return false
        //         }
        //         SLogs.Error("Failed to check if master key exists in Windows keyring: %v", err)
        //         return false
        // }
        // SLogs.Debug("Master key exists in Windows keyring")
        return true
}</span>
func (sm *SecretManager) loadUnixKey() ([]byte, error) <span class="cov0" title="0">{
        const keyFilename = "master.key"

        // Validate configuration
        if sm.cfg == nil || sm.cfg.App.Name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: app name not set")
        }</span>

        // Setup paths
        <span class="cov0" title="0">homedir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov0" title="0">appDir := filepath.Join(homedir, ".nextdeploy", sm.cfg.App.Name)
        keyPath := filepath.Join(appDir, keyFilename)
        SLogs.Debug("Attempting to load master key from: %s", keyPath)

        // Try reading existing key
        keyData, err := os.ReadFile(keyPath)
        if err == nil </span><span class="cov0" title="0">{
                if len(keyData) == 0 </span><span class="cov0" title="0">{
                        SLogs.Warn("Existing master key file is empty")
                        return nil, fmt.Errorf("empty master key")
                }</span>
                <span class="cov0" title="0">SLogs.Debug("Successfully loaded existing master key")
                return keyData, nil</span>
        }

        // Handle key not found case
        <span class="cov0" title="0">if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read key file: %w", err)
        }</span>

        <span class="cov0" title="0">SLogs.Info("No master key found, generating new one")

        // Generate and store new key
        newKey, err := sm.GenerateMasterKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate master key: %w", err)
        }</span>

        // Ensure directory exists
        <span class="cov0" title="0">if err := os.MkdirAll(appDir, 0700); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create app directory: %w", err)
        }</span>

        // Store the key before returning
        <span class="cov0" title="0">if err := os.WriteFile(keyPath, newKey, 0600); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store master key: %w", err)
        }</span>

        <span class="cov0" title="0">SLogs.Info("Successfully generated and stored new master key at %s", keyPath)
        return newKey, nil</span>
}
func (sm *SecretManager) storeWindowsKey(key []byte) error <span class="cov0" title="0">{
        appname := sm.cfg.App.Name
        // Optional: encrypt key here with DPAPI or AES

        err := keyring.Set(appname, "master_key", string(key))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store master key in Windows keyring: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (sm *SecretManager) loadWindowsKey() ([]byte, error) <span class="cov0" title="0">{
        appname := sm.cfg.App.Name
        encryptedKey, err := keyring.Get(appname, "master_key")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load master key from Windows keyring: %w", err)
        }</span>

        // Optional: decrypt key here if you encrypted it
        <span class="cov0" title="0">return []byte(encryptedKey), nil</span>
}

func (sm *SecretManager) GetKeyOsAgnosticPath() string <span class="cov0" title="0">{
        // platform agnostic key path
        home, _ := os.UserHomeDir()
        appname := sm.GetAppName()
        return home + "/.nextdeploy/" + appname + "/master.key"
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package secrets

import (
        "fmt"
)

func (sm *SecretManager) MigrateToProvider(providerName string) error <span class="cov0" title="0">{
        if sm.manager == nil </span><span class="cov0" title="0">{
                return ErrProviderNotConfigured
        }</span>

        <span class="cov0" title="0">provider, exists := sm.manager.providers[providerName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %s", ErrInvalidProvider, providerName)
        }</span>

        <span class="cov0" title="0">sm.mu.Lock()
        defer sm.mu.Unlock()

        for name, secret := range sm.secrets </span><span class="cov0" title="0">{
                value := secret.Value
                if secret.IsEncrypted </span><span class="cov0" title="0">{
                        key, err := sm.getCachedKey(name)
                        if err != nil </span><span class="cov0" title="0">{
                                SLogs.Warn("Failed to get key for %s during migration: %v", name, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">decrypted, err := Decrypt([]byte(value), []byte(key))
                        if err != nil </span><span class="cov0" title="0">{
                                SLogs.Warn("Failed to decrypt %s during migration: %v", name, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">value = string(decrypted)</span>
                }

                <span class="cov0" title="0">if err := provider.SetSecret(name, value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to migrate secret %s: %w", name, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package secrets

import (
        "nextdeploy/shared/config"
        "nextdeploy/shared"
        "os"
        "path/filepath"
        "sync"
)

var (
        SLogs = shared.PackageLogger("Secrets::", "üîê Secrets Manager::")
)

// SecretManager handles secure secret storage and retrieval
type SecretManager struct {
        keyPath  string                   // Path for key storage
        cfg      *config.NextDeployConfig // Application configuration
        secrets  map[string]*Secret       // Map of stored secrets
        keyCache map[string][]byte        // Cache for derived keys
        manager  *providerManager         // Manages different secret providers
        mu       sync.RWMutex             // Mutex for thread safety
}

// Secret represents a stored secret with metadata
type Secret struct {
        Value       string `json:"value"`        // The secret value (may be encrypted)
        Version     int    `json:"version"`      // Version for rotation
        CreatedAt   int64  `json:"created_at"`   // Creation timestamp
        ModifiedAt  int64  `json:"modified_at"`  // Last modification timestamp
        IsEncrypted bool   `json:"is_encrypted"` // Encryption status flag
}

// providerManager handles multiple secret providers
type providerManager struct {
        providers map[string]SecretProvider
}

// SecretProvider defines the interface for secret storage backends
type SecretProvider interface {
        GetSecret(key string) (string, error)
        SetSecret(key, value string) error
        DeleteSecret(key string) error
        ListSecrets() ([]string, error)
        Encrypt(data []byte, key string) ([]byte, error)
        Decrypt(data []byte, key string) ([]byte, error)
        GenerateMasterKey() (string, error)
        DeriveKey(key string) ([]byte, error)
        ValidateSecretFormat(secret string) error
}

// Option configures a SecretManager
type Option func(*SecretManager)

// WithConfig provides application configuration
func WithConfig(cfg *config.NextDeployConfig) Option <span class="cov0" title="0">{
        return func(sm *SecretManager) </span><span class="cov0" title="0">{
                sm.cfg = cfg
        }</span>
}

// WithKeyPath sets a custom key storage path
func WithKeyPath(path string) Option <span class="cov0" title="0">{
        return func(sm *SecretManager) </span><span class="cov0" title="0">{
                if path != "" </span><span class="cov0" title="0">{
                        sm.keyPath = path
                        return
                }</span>

                // Default path construction
                <span class="cov0" title="0">homedir, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        SLogs.Error("Failed to get home directory: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">appName := "default"
                if sm.cfg != nil &amp;&amp; sm.cfg.App.Name != "" </span><span class="cov0" title="0">{
                        appName = sm.cfg.App.Name
                }</span>

                <span class="cov0" title="0">sm.keyPath = filepath.Join(homedir, ".nextdeploy", appName)</span>
        }
}

// WithProvider registers a new secret provider
func WithProvider(name string, provider SecretProvider) Option <span class="cov0" title="0">{
        return func(sm *SecretManager) </span><span class="cov0" title="0">{
                sm.ensureProviderManager()
                sm.manager.providers[name] = provider
        }</span>
}

// NewSecretManager creates a new secret manager with options
func NewSecretManager(opts ...Option) (*SecretManager, error) <span class="cov0" title="0">{
        sm := &amp;SecretManager{
                secrets:  make(map[string]*Secret),
                keyCache: make(map[string][]byte),
        }

        // Apply all options
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(sm)
        }</span>

        // Load default config if none provided
        <span class="cov0" title="0">if sm.cfg == nil </span><span class="cov0" title="0">{
                cfg, err := config.Load()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, ErrConfigNotFound
                }</span>
                <span class="cov0" title="0">sm.cfg = cfg</span>
        }

        <span class="cov0" title="0">return sm, nil</span>
}

// ensureProviderManager initializes the provider manager if nil
func (sm *SecretManager) ensureProviderManager() <span class="cov0" title="0">{
        if sm.manager == nil </span><span class="cov0" title="0">{
                sm.manager = &amp;providerManager{
                        providers: make(map[string]SecretProvider),
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package secrets

import (
        "crypto/subtle"
        "encoding/json"

        "errors"
        "fmt"
        "os"
        "time"
)

func (sm *SecretManager) ValidateSecret(name, value string) error <span class="cov0" title="0">{
        if len(value) &lt; 12 </span><span class="cov0" title="0">{
                return errors.New("secret must be at least 12 characters long")
        }</span>

        // Add more validation rules as needed
        <span class="cov0" title="0">return nil</span>
}

// SecureCompare performs constant-time comparison of secrets
func (sm *SecretManager) SecureCompare(a, b string) bool <span class="cov0" title="0">{
        return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}</span>
func (sm *SecretManager) RotateSecrets() error <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()

        newKey, err := sm.GeneratePlatformKey()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for name, secret := range sm.secrets </span><span class="cov0" title="0">{
                if !secret.IsEncrypted </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Decrypt with old key
                <span class="cov0" title="0">oldKey, err := sm.getCachedKey(name)
                if err != nil </span><span class="cov0" title="0">{
                        SLogs.Warn("Failed to get cached key for %s: %v", name, err)
                        continue</span>
                }

                <span class="cov0" title="0">decrypted, err := Decrypt([]byte(secret.Value), []byte(oldKey))
                if err != nil </span><span class="cov0" title="0">{
                        SLogs.Warn("Failed to decrypt secret %s: %v", name, err)
                        continue</span>
                }

                // Encrypt with new key
                <span class="cov0" title="0">encrypted, err := Encrypt(decrypted, []byte(newKey))
                if err != nil </span><span class="cov0" title="0">{
                        SLogs.Warn("Failed to re-encrypt secret %s: %v", name, err)
                        continue</span>
                }

                <span class="cov0" title="0">secret.Value = string(encrypted)
                secret.Version++
                secret.ModifiedAt = time.Now().Unix()
                sm.keyCache[name] = []byte(newKey)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
func (sm *SecretManager) PrepareSecretsContext() error <span class="cov0" title="0">{
        sm.mu.Lock()
        //ensure config is load properly on sm
        defer sm.mu.Unlock()
        if sm.cfg == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration is not set")
        }</span>
        // ensure manager is initialized
        <span class="cov0" title="0">if sm.manager == nil </span><span class="cov0" title="0">{
                sm.manager = &amp;providerManager{
                        providers: make(map[string]SecretProvider),
                }
        }</span>

        <span class="cov0" title="0">for _, provider := range sm.manager.providers </span><span class="cov0" title="0">{
                if err := provider.ValidateSecretFormat(""); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid secret format: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (sm *SecretManager) SetSecret(name, value string, encrypt bool) error <span class="cov0" title="0">{
        // TODO: ‚ùó Enforce naming rules, avoid reserved/system keys.
        // TODO: üîê Store encryption metadata (alg version, salt, iv) with each secret.

        sm.mu.Lock()
        defer sm.mu.Unlock()

        if _, exists := sm.secrets[name]; exists </span><span class="cov0" title="0">{
                return ErrSecretAlreadyExists
        }</span>

        <span class="cov0" title="0">secret := &amp;Secret{
                Value:       value,
                Version:     1,
                CreatedAt:   time.Now().Unix(),
                ModifiedAt:  time.Now().Unix(),
                IsEncrypted: encrypt,
        }

        if encrypt </span><span class="cov0" title="0">{
                key, err := sm.GeneratePlatformKey()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">encrypted, err := Encrypt([]byte(value), []byte(key))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">secret.Value = string(encrypted)</span>
        }

        <span class="cov0" title="0">sm.secrets[name] = secret
        return nil</span>
}

// GetSecret retrieves a secret, decrypting if necessary
func (sm *SecretManager) GetSecret(name string) (string, error) <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        secret, exists := sm.secrets[name]
        if !exists </span><span class="cov0" title="0">{
                // Try external providers
                if sm.manager != nil </span><span class="cov0" title="0">{
                        for _, provider := range sm.manager.providers </span><span class="cov0" title="0">{
                                if value, err := provider.GetSecret(name); err == nil </span><span class="cov0" title="0">{
                                        return value, nil
                                }</span>
                        }
                }
                <span class="cov0" title="0">return "", ErrSecretNotFound</span>
        }

        <span class="cov0" title="0">if !secret.IsEncrypted </span><span class="cov0" title="0">{
                return secret.Value, nil
        }</span>

        <span class="cov0" title="0">key, err := sm.GeneratePlatformKey()
        SLogs.Debug("The key from get secret is: %s", key)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">decrypted, err := Decrypt([]byte(secret.Value), []byte(key))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%w: %v", ErrDecryptionFailed, err)
        }</span>

        <span class="cov0" title="0">return string(decrypted), nil</span>
}

// ImportSecrets imports secrets from a JSON file
func (sm *SecretManager) ImportSecrets(filePath string) error <span class="cov0" title="0">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read import file: %w", err)
        }</span>

        <span class="cov0" title="0">var secrets map[string]*Secret
        if err := json.Unmarshal(data, &amp;secrets); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse secrets: %w", err)
        }</span>

        <span class="cov0" title="0">sm.mu.Lock()
        defer sm.mu.Unlock()

        for name, secret := range secrets </span><span class="cov0" title="0">{
                sm.secrets[name] = secret
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExportSecrets exports secrets to a JSON file
func (sm *SecretManager) ExportSecrets(filePath string) error <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()

        data, err := json.MarshalIndent(sm.secrets, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal secrets: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(filePath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write secrets file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package secrets

import (
        "os"
        "path/filepath"
)

func (sm *SecretManager) GetAppName() string <span class="cov0" title="0">{
        if sm.cfg != nil &amp;&amp; sm.cfg.App.Name != "" </span><span class="cov0" title="0">{
                return sm.cfg.App.Name
        }</span>
        <span class="cov0" title="0">return "default"</span>
}

func (sm *SecretManager) GetKey() string <span class="cov0" title="0">{
        if sm.cfg == nil &amp;&amp; sm.cfg.App.Name == "" </span><span class="cov0" title="0">{
                return "nokey"
        }</span>
        <span class="cov0" title="0">homedir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                SLogs.Error("Failed to get home directory: %v", err)
                return "nokey"
        }</span>
        <span class="cov0" title="0">return filepath.Join(homedir, ".nextdeploy", sm.cfg.App.Name, "master.key")</span>

}
</pre>
		
		<pre class="file" id="file68" style="display: none">package shared

import (
        "crypto/ecdh"
        "encoding/json"
        "fmt"
        "strings"
        "time"
)

type AgentType string

const (
        AgentDaemon    AgentType = "daemon"
        AgentCLI       AgentType = "cli"
        AgentDashboard AgentType = "dashboard"
)

type MessageType string

const (
        TypeCommand         MessageType = "command" // Command to execute
        TypeCommandResponse MessageType = "command_response"
        TypeStatus          MessageType = "status"   // Status update
        TypeResponse        MessageType = "response" // Response to a command
        TypeEvent           MessageType = "event"    // Event notification
        TypeLog             MessageType = "log"      // Log message
        TypeError           MessageType = "error"    // Error message
        TypeAuth            MessageType = "auth"     // Authentication message
        TypeStatusAck       MessageType = "status_ack"
        TypeAuthResponse    MessageType = "auth_response"
)

type AgentMessage struct {
        Source    AgentType       `json:"source"`
        Target    AgentType       `json:"target"`
        Type      MessageType     `json:"type"`
        Payload   json.RawMessage `json:"payload"`
        Timestamp int64           `json:"timestamp"`
        AgentID   string          `json:"agent_id"`
        Signature string          `json:"signature,omitempty"` // ECC signature of the message
        Context  map[string]string `json:"context,omitempty"` // Additional context for the message
}

// CommandPayload represents a command sent to an agent
type CommandPayload struct {
        Name string      `json:"name"`           // Command name (e.g., "restart", "deploy")
        Args []string    `json:"args,omitempty"` // Command arguments
        ID   string      `json:"id"`             // Unique command ID for tracking
        Meta interface{} `json:"meta,omitempty"` // Additional metadata
}

// StatusPayload represents an agent status update
type StatusPayload struct {
        Status  string                 `json:"status"`            // Current status (e.g., "healthy", "degraded")
        Metrics map[string]interface{} `json:"metrics,omitempty"` // System metrics
        Load    SystemLoad             `json:"load,omitempty"`    // System load information
}

// SystemLoad contains system load information
type SystemLoad struct {
        CPU    float64 `json:"cpu"`    // CPU usage percentage
        Memory float64 `json:"memory"` // Memory usage percentage
        Disk   float64 `json:"disk"`   // Disk usage percentage
}

// AuthPayload represents an authentication request
type AuthPayload struct {
        Token    string `json:"token"`              // Authentication token
        Version  string `json:"version"`            // Agent version
        Hostname string `json:"hostname,omitempty"` // Agent hostname
}

// EventPayload represents an event notification
type EventPayload struct {
        Type string      `json:"type"` // Event type (e.g., "deployment_started")
        Data interface{} `json:"data"` // Event-specific data
}

// ErrorPayload represents an error response
type ErrorPayload struct {
        Message string `json:"message"`           // Error message
        Code    int    `json:"code,omitempty"`    // Optional error code
        Details string `json:"details,omitempty"` // Additional error details
}

// Helper functions

// GetCurrentTimestamp returns the current Unix timestamp
func GetCurrentTimestamp() int64 <span class="cov0" title="0">{
        return time.Now().Unix()
}</span>

// NewCommandMessage creates a new command message
func NewCommandMessage(agentID string, command CommandPayload) (AgentMessage, error) <span class="cov0" title="0">{
        payload, err := json.Marshal(command)
        if err != nil </span><span class="cov0" title="0">{
                return AgentMessage{}, err
        }</span>

        <span class="cov0" title="0">return AgentMessage{
                Type:      TypeCommand,
                Timestamp: GetCurrentTimestamp(),
                AgentID:   agentID,
                Payload:   payload,
        }, nil</span>
}

// NewStatusMessage creates a new status message
func NewStatusMessage(agentID string, status StatusPayload) (AgentMessage, error) <span class="cov0" title="0">{
        payload, err := json.Marshal(status)
        if err != nil </span><span class="cov0" title="0">{
                return AgentMessage{}, err
        }</span>

        <span class="cov0" title="0">return AgentMessage{
                Type:      TypeStatus,
                Timestamp: GetCurrentTimestamp(),
                AgentID:   agentID,
                Payload:   payload,
        }, nil</span>
}

// EncryptedEnv represents the encrypted environment variables
type EncryptedEnv struct {
        KeyID        string            `json:"key_id"`         // Daemon's key ID used for encryption
        EnvBlob      string            `json:"env_blob"`       // Base64 encoded encrypted full .env content
        Variables    map[string]string `json:"variables"`      // Map of encrypted individual variables
        Nonce        string            `json:"nonce"`          // Base64 encoded nonce used for encryption
        Timestamp    time.Time         `json:"timestamp"`      // When the payload was created
        CLIPublicKey string            `json:"cli_public_key"` // Base64 encoded CLI's ECDH public key
}

// RBAC Roles
const (
        RoleOwner    = "owner"
        RoleAdmin    = "admin"
        RoleDeployer = "deployer"
        RoleReader   = "reader"
)

type Identity struct {
        Fingerprint string    `json:"fingerprint"` // SHA-256 of public key
        PublicKey   string    `json:"public_key"`  // Base64 encoded public key
        SignPublic  string    `json:"sign_public"` // Base64 encoded Ed25519 public key
        Role        string    `json:"role"`        // RBAC role (owner, admin, deployer, etc.)
        Email       string    `json:"email"`       // User email/identifier
        AddedBy     string    `json:"added_by"`    // Who added this identity
        CreatedAt   time.Time `json:"created_at"`  // When this identity was added
}

type Envelope struct {
        Payload   []byte `json:"payload"`   // JSON string of EncryptedEnv
        Signature string `json:"signature"` // Base64 encoded signature of the payload
}

// PublicKeyResponse is the response from the daemon's /public-key endpoint
type PublicKeyResponse struct {
        KeyID      string `json:"key_id"`      // Identifier for the key
        PublicKey  string `json:"public_key"`  // Base64 encoded ECDH public key
        SignPublic string `json:"sign_public"` // Base64 encoded Ed25519 public key
}

// TrustedKey represents a trusted daemon public key stored by the CLI
type TrustedKey struct {
        KeyID       string          `json:"key_id"`
        PublicKey   *ecdh.PublicKey `json:"public_key"`
        SignPublic  string          `json:"sign_public"`
        Fingerprint string          `json:"fingerprint"`
}

// TrustStore is a collection of trusted keys
type TrustStore struct {
        Keys       []TrustedKey `json:"keys"`
        Identities []Identity
}

type AuditLogEntry struct {
        Action    string    `json:"action"`       // What happened
        Actor     string    `json:"actor"`        // Who did it (fingerprint)
        Target    string    `json:"target"`       // What was affected
        Timestamp time.Time `json:"timestamp"`    // When it happened
        Signature string    `json:"signature"`    // Signature of the action
        IP        string    `json:"ip,omitempty"` // Optional IP address
        Message   string    `json:"message"`      // Optional message or details:
        Client    string    `json:"client_id"`    // Client identifier (if applicable)
}

// EnvFile represents a parsed .env file
type EnvFile struct {
        Variables map[string]string
        Raw       []byte
}

func ParseEnvFile(content []byte) (*EnvFile, error) <span class="cov0" title="0">{
        // Simplified parser
        variables := make(map[string]string)
        lines := strings.Split(string(content), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span> // Skip empty lines and components
                }
                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        SharedLogger.Error("Invalid line in .env file: %s", line)
                        return nil, fmt.Errorf("invalid line in .env file: %s", line)

                }</span>
                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])
                if key == "" || value == "" </span><span class="cov0" title="0">{
                        SharedLogger.Error("Empty key or value in .env file: %s", line)
                        return nil, fmt.Errorf("empty key or value in .env file: %s", line)
                }</span>
                <span class="cov0" title="0">variables[key] = value</span>
        }
        <span class="cov0" title="0">return &amp;EnvFile{
                Variables: variables,
                Raw:       content,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package shared

import (
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
)

func EncodeToBase64(data []byte) string <span class="cov0" title="0">{
        return base64.StdEncoding.EncodeToString(data)
}</span>

func DecodeFromBase64(encoded string) ([]byte, error) <span class="cov0" title="0">{
        data, err := base64.StdEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode base64: %w", err)
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}
func EncodeToHex(data []byte) string <span class="cov0" title="0">{
        return hex.EncodeToString(data)
}</span>
func DecodeFromHex(encoded string) ([]byte, error) <span class="cov0" title="0">{
        data, err := hex.DecodeString(encoded)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode hex: %w", err)
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

func HasRequiredRole(role Identity, Role string) bool <span class="cov0" title="0">{
        return false
}</span>

// serialize
func SerializeToJSON(data interface{}) (string, error) <span class="cov0" title="0">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to serialize to JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return string(jsonData), nil</span>
}
func DeserializeFromJSON(jsonStr string, data interface{}) error <span class="cov0" title="0">{
        err := json.Unmarshal([]byte(jsonStr), data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deserialize from JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validate key id
func ValidateKeyID(keyID string) error <span class="cov0" title="0">{
        if len(keyID) != 64 </span><span class="cov0" title="0">{
                return errors.New("invalid key ID length, must be 64 characters")
        }</span>
        <span class="cov0" title="0">if _, err := hex.DecodeString(keyID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid key ID format: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package websocket

import (
        "crypto/ecdsa"
        "errors"
        "fmt"
        "net/http"
        "nextdeploy/shared"
        "time"

        "github.com/gorilla/websocket"
)

var (
        websockerlogger = shared.PackageLogger("api", "üåê API")
)

func NewWSClient(agentID string, privateKey *ecdsa.PrivateKey) *WSClient <span class="cov0" title="0">{
        return &amp;WSClient{
                agentID:    agentID,
                privateKey: privateKey,
                pingPeriod: 15 * time.Second,
                writeWait:  10 * time.Second,
                pongWait:   20 * time.Second,
        }
}</span>

func (c *WSClient) ReceiveMessage() (shared.AgentMessage, error) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if !c.connected </span><span class="cov0" title="0">{
                websockerlogger.Error("WebSocket client is not connected")
                return shared.AgentMessage{}, errors.New("websocket client is not connected")
        }</span>

        <span class="cov0" title="0">messsageType, message, err := c.conn.ReadMessage()
        fmt.Printf("Received message type: %v", message)
        fmt.Printf("Message type: %d\n", messsageType)
        if err != nil </span><span class="cov0" title="0">{
                websockerlogger.Error("Failed to read message from WebSocket error:%s", err)
                return shared.AgentMessage{}, err
        }</span>
        // FIX: Deserialize the message into AgentMessage and use returned message from ReadMessage
        <span class="cov0" title="0">var agentMessage shared.AgentMessage
        return agentMessage, nil</span>
}
func (c *WSClient) Connect(url string, headers http.Header) error <span class="cov0" title="0">{
        dialer := websocket.DefaultDialer
        conn, _, err := dialer.Dial(url, headers)
        if err != nil </span><span class="cov0" title="0">{
                websockerlogger.Error("Failed to connect to WebSocket server:%s", err)
                return err
        }</span>

        <span class="cov0" title="0">c.conn = conn
        c.connected = true

        // Start reader/writer goroutines
        go c.readPump()
        go c.writePump()

        return nil</span>

}
func (c *WSClient) SendMessage(msg interface{}) error <span class="cov0" title="0">{

        c.mu.Lock()
        defer c.mu.Unlock()
        if !c.connected </span><span class="cov0" title="0">{
                websockerlogger.Error("WebSocket client is not connected")
                return errors.New("websocket client is not connected")
        }</span>

        <span class="cov0" title="0">return c.conn.WriteJSON(msg)</span>

}

func (c *WSClient) Close() error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if !c.connected </span><span class="cov0" title="0">{
                websockerlogger.Error("WebSocket client is not connected")
                return errors.New("websocket client is not connected")
        }</span>

        <span class="cov0" title="0">err := c.conn.Close()
        if err != nil </span><span class="cov0" title="0">{
                websockerlogger.Error("Failed to close WebSocket connection error:%s", err)
                return err
        }</span>

        <span class="cov0" title="0">c.connected = false
        return nil</span>
}

func (c *WSClient) readPump() <span class="cov0" title="0">{
        defer c.Close()

        c.conn.SetReadDeadline(time.Now().Add(c.pongWait))
        c.conn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                c.conn.SetReadDeadline(time.Now().Add(c.pongWait))
                return nil
        }</span>)

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                _, message, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                websockerlogger.Error("WebSocket read error:%s", err)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">websockerlogger.Info("Received message from WebSocket server message:%s", string(message))</span>
        }

}

func (c *WSClient) writePump() <span class="cov0" title="0">{
        ticker := time.NewTicker(c.pingPeriod)
        defer func() </span><span class="cov0" title="0">{
                ticker.Stop()
                c.Close()
        }</span>()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.mu.Lock()
                        if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov0" title="0">{
                                websockerlogger.Error("Failed to send ping error:%s", err)
                                c.mu.Unlock()
                                return
                        }</span>
                        <span class="cov0" title="0">c.mu.Unlock()</span>

                default:<span class="cov0" title="0">
                        time.Sleep(1 * time.Second)</span> // Avoid busy waiting
                }
        }
}
</pre>
		
		<pre class="file" id="file71" style="display: none">// /*
// NextDeploy Master Control Script
//
// This script provides unified control for:
// 1. Building components (daemon and CLI)
// 2. Running the daemon with proper configuration
// 3. Development environment setup
// 4. Production deployment
//
// USAGE:
//
//        Build: go run start.go build [flags]
//        Run:   go run start.go run [flags]
//        Dev:   go run start.go dev
//        Clean: go run start.go clean
//
// BUILD FLAGS:
//
//        -target  string  Build target: 'daemon', 'cli', or 'all' (default "all")
//        -output  string  Output directory (default "./bin")
//        -version string  Override version number
//
// RUN FLAGS:
//
//        -config string   Config file path
//        -port   string   Server port (default "8080")
//        -host   string   Server host (default "0.0.0.0")
//        -debug           Enable debug mode
//
// ENVIRONMENT VARIABLES:
//
//        NEXTDEPLOY_VERSION  Set build version
//        BUILD_STATIC        Force static linking ("true" or "false")
//
// */
package main

import (
        "flag"
        "fmt"
        "log"
        "os"
        "os/exec"
        "path/filepath"
        "strconv"
        "strings"
        "time"
)

// Constants
const (
        defaultPort        = "8080"
        defaultHost        = "0.0.0.0"
        defaultConfigFile  = "config.yaml"
        defaultOutputDir   = "./bin"
        defaultTarget      = "all"
        defaultVersionFile = "VERSION"
)

// Project paths
var (
        projectRoot = "."
        daemonPath  = filepath.Join(projectRoot, "daemon", "main.go")
        cliPath     = filepath.Join(projectRoot, "cli", "main.go")
        homeDir     = getHomeDir()
)

// Config holds runtime configuration
type Config struct {
        Port    string
        Host    string
        Debug   bool
        LogFile string
        KeyDir  string
        PidFile string
}

// isDaemonRunning checks if the NextDeploy daemon is currently running
func isDaemonRunning() (bool, int, error) <span class="cov0" title="0">{
        // Try systemctl first (Linux systems with systemd)
        if _, err := exec.LookPath("systemctl"); err == nil </span><span class="cov0" title="0">{
                cmd := exec.Command("systemctl", "is-active", "nextdeploy.service")
                output, err := cmd.CombinedOutput()
                if err == nil &amp;&amp; strings.TrimSpace(string(output)) == "active" </span><span class="cov0" title="0">{
                        // Get PID if running
                        pidCmd := exec.Command("systemctl", "show", "--property=MainPID", "nextdeploy.service")
                        pidOutput, err := pidCmd.Output()
                        if err == nil </span><span class="cov0" title="0">{
                                pidStr := strings.TrimPrefix(strings.TrimSpace(string(pidOutput)), "MainPID=")
                                if pid, err := strconv.Atoi(pidStr); err == nil &amp;&amp; pid &gt; 0 </span><span class="cov0" title="0">{
                                        return true, pid, nil
                                }</span>
                        }
                        <span class="cov0" title="0">return true, 0, nil</span>
                }
        }

        // Fallback to pgrep for non-systemd systems
        <span class="cov0" title="0">if _, err := exec.LookPath("pgrep"); err == nil </span><span class="cov0" title="0">{
                cmd := exec.Command("pgrep", "-f", "nextdeployd")
                output, err := cmd.CombinedOutput()
                if err == nil </span><span class="cov0" title="0">{
                        pids := strings.Fields(string(output))
                        if len(pids) &gt; 0 </span><span class="cov0" title="0">{
                                if pid, err := strconv.Atoi(pids[0]); err == nil </span><span class="cov0" title="0">{
                                        return true, pid, nil
                                }</span>
                        }
                }
        }

        // Final fallback - check process list
        <span class="cov0" title="0">cmd := exec.Command("ps", "aux")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return false, 0, fmt.Errorf("failed to check processes: %v", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "nextdeployd") &amp;&amp; !strings.Contains(line, "start.go") </span><span class="cov0" title="0">{
                        parts := strings.Fields(line)
                        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                if pid, err := strconv.Atoi(parts[1]); err == nil </span><span class="cov0" title="0">{
                                        return true, pid, nil
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false, 0, nil</span>
}

// daemonStatusCmd adds a new command to check daemon status
func daemonStatusCmd() <span class="cov0" title="0">{
        log.Println("üîç Checking NextDeploy daemon status...")

        running, pid, err := isDaemonRunning()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ö†Ô∏è Error checking daemon status: %v", err)
                return
        }</span>

        <span class="cov0" title="0">if running </span><span class="cov0" title="0">{
                log.Printf("‚úÖ Daemon is running (PID: %d)", pid)

                // Additional info for systemd systems
                if _, err := exec.LookPath("systemctl"); err == nil </span><span class="cov0" title="0">{
                        cmd := exec.Command("systemctl", "status", "nextdeploy.service", "--no-pager")
                        cmd.Stdout = os.Stdout
                        cmd.Stderr = os.Stderr
                        _ = cmd.Run()
                }</span>
        } else<span class="cov0" title="0"> {
                log.Println("‚ùå Daemon is not running")
        }</span>
}

// Update main() to include the status command
func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                printUsage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">switch os.Args[1] </span>{
        case "build":<span class="cov0" title="0">
                buildCmd()</span>
        case "run":<span class="cov0" title="0">
                runCmd()</span>
        case "dev":<span class="cov0" title="0">
                devCmd()</span>
        case "clean":<span class="cov0" title="0">
                cleanCmd()</span>
        case "status":<span class="cov0" title="0"> // New status command
                daemonStatusCmd()</span>
        case "purge":<span class="cov0" title="0">
                purgeCmd()</span>
        default:<span class="cov0" title="0">
                printUsage()
                os.Exit(1)</span>
        }
}

// Update usage information
func printUsage() <span class="cov0" title="0">{
        fmt.Println(`NextDeploy Master Control

Commands:
  build    Build components (daemon and CLI)
  run      Run the daemon with configuration
  dev      Set up development environment
  clean    Clean build artifacts
  status   Check daemon status

Flags:
  Use 'go run start.go &lt;command&gt; -help' for command-specific flags`)
}</span>

// ---------------------- BUILD COMMAND ----------------------
func buildCmd() <span class="cov0" title="0">{
        log.Println("üöÄ Starting build process...")

        buildFlags := flag.NewFlagSet("build", flag.ExitOnError)
        target := buildFlags.String("target", defaultTarget, "Build target")
        outputDir := buildFlags.String("output", defaultOutputDir, "Output directory")
        versionOverride := buildFlags.String("version", "", "Version override")
        buildFlags.Parse(os.Args[2:])

        // Verify output directory exists
        if err := os.MkdirAll(*outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to create output directory: %v", err)
        }</span>

        <span class="cov0" title="0">version := getVersion(*versionOverride)
        commit := getGitCommit()
        buildTime := time.Now().Format(time.RFC3339)

        targets := []struct {
                name        string
                source      string
                output      string
                environment []string
                ldflags     string
        }{
                {
                        name:        "nextdeployd (daemon)",
                        source:      "./daemon", // Package path instead of file path
                        output:      filepath.Join(*outputDir, "nextdeployd"),
                        environment: getDaemonEnv(),
                        ldflags:     fmt.Sprintf("-s -w -X main.Version=%s -X main.Commit=%s -X main.BuildTime=%s", version, commit, buildTime),
                },
                {
                        name:    "nextdeploy (CLI)",
                        source:  "./cli", // Package path instead of file path
                        output:  filepath.Join(*outputDir, "nextdeploy"),
                        ldflags: fmt.Sprintf("-X main.Version=%s -X main.Commit=%s", version, commit),
                },
        }

        // Build each target
        for _, t := range targets </span><span class="cov0" title="0">{
                if *target != "all" &amp;&amp; !strings.Contains(strings.ToLower(t.name), *target) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">log.Printf("üî® Building %s...", t.name)

                // Build the PACKAGE, not just the main.go file
                pkgPath := strings.TrimSuffix(t.source, "/main.go")
                if pkgPath == t.source </span><span class="cov0" title="0">{
                        // Fallback if the path doesn't end with /main.go
                        pkgPath = filepath.Dir(t.source)
                }</span>

                // With this:
                <span class="cov0" title="0">pkgPath = strings.TrimSuffix(t.source, "/main.go")
                cmd := exec.Command("go", "build", "-ldflags", t.ldflags, "-o", t.output, pkgPath)
                cmd.Env = append(os.Environ(), t.environment...)
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr

                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("‚ùå Build failed for %s: %v", t.name, err)
                }</span>
                <span class="cov0" title="0">log.Printf("‚úÖ Successfully built %s", t.output)</span>
        }
}

// ---------------------- RUN COMMAND ----------------------
func runCmd() <span class="cov0" title="0">{
        log.Println("üöÄ Starting NextDeploy daemon...")

        runFlags := flag.NewFlagSet("run", flag.ExitOnError)
        configFile := runFlags.String("config", defaultConfigFile, "Config file path")
        port := runFlags.String("port", defaultPort, "Server port")
        host := runFlags.String("host", defaultHost, "Server host")
        debug := runFlags.Bool("debug", false, "Debug mode")
        runFlags.Parse(os.Args[2:])

        config := Config{
                Port:  *port,
                Host:  *host,
                Debug: *debug,
        }

        // Verify daemon exists
        daemonPath := filepath.Join(defaultOutputDir, "nextdeployd")
        if _, err := os.Stat(daemonPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Println("‚ö†Ô∏è Daemon not found, building first...")
                buildCmd()
        }</span>

        <span class="cov0" title="0">log.Printf("‚öôÔ∏è  Configuration:\n- Host: %s\n- Port: %s\n- Debug: %t",
                config.Host, config.Port, config.Debug)

        cmd := exec.Command(daemonPath,
                "--host", config.Host,
                "--port", config.Port,
                fmt.Sprintf("--debug=%t", config.Debug),
                "--config", *configFile,
        )

        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        log.Println("üåê Starting daemon process...")
        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to start daemon: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("‚úÖ Daemon running (PID: %d)", cmd.Process.Pid)
        log.Println("üõë Press CTRL+C to stop")

        if err := cmd.Wait(); err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ö†Ô∏è Daemon exited: %v", err)
        }</span>
}

// ---------------------- DEV COMMAND ----------------------
func devCmd() <span class="cov0" title="0">{
        log.Println("üöÄ Setting up development environment...")

        // 1. Build components
        log.Println("üî® Building development binaries...")
        buildCmd()

        // 2. Create directory structure
        devDirs := []string{
                filepath.Join(homeDir, ".nextdeploy", "keys"),
                filepath.Join(homeDir, ".nextdeploy", "logs"),
                filepath.Join(homeDir, ".nextdeploy", "cache"),
        }

        for _, dir := range devDirs </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("‚ùå Failed to create directory %s: %v", dir, err)
                }</span>
        }
        <span class="cov0" title="0">log.Println("üìÅ Created development directories")

        // 3. Setup binaries (install as service)
        binariesSetup()

        // 4. Check service status instead of starting manually
        log.Println("‚úÖ Development environment ready!")
        log.Println("üåç Server should be running on http://localhost:8080")
        log.Printf("üìù Logs: %s", filepath.Join(homeDir, ".nextdeploy", "logs", "daemon.log"))
        log.Println("Check status with: sudo systemctl status nextdeploy")</span>
}

// ----------------- Setup the built binarues ------------
func binariesSetup() <span class="cov0" title="0">{
        log.Println("üöÄ Setting up binaries for system-wide use...")

        // Paths to built binaries
        cliBinary := filepath.Join(defaultOutputDir, "nextdeploy")
        daemonBinary := filepath.Join(defaultOutputDir, "nextdeployd")

        // Verify binaries exist
        if _, err := os.Stat(cliBinary); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Println("‚ö†Ô∏è CLI binary not found, building first...")
                buildCmd()
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(daemonBinary); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Println("‚ö†Ô∏è Daemon binary not found, building first...")
                buildCmd()
        }</span>

        // Installation paths
        <span class="cov0" title="0">installDir := "/usr/local/bin"
        systemdDir := "/etc/systemd/system"

        // Check if we have sudo privileges
        sudo := ""
        if os.Geteuid() != 0 </span><span class="cov0" title="0">{
                sudo = "sudo "
                log.Println("üîí Requires sudo privileges for system installation")
        }</span>

        // 1. Install binaries to /usr/local/bin
        <span class="cov0" title="0">log.Printf("üì¶ Installing binaries to %s...", installDir)
        installCmd := fmt.Sprintf("%scp %s %s %s", sudo, cliBinary, daemonBinary, installDir)
        if err := exec.Command("sh", "-c", installCmd).Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to install binaries: %v", err)
        }</span>

        // 2. Create systemd service for the daemon
        <span class="cov0" title="0">log.Println("‚öôÔ∏è Creating systemd service...")
        serviceContent := fmt.Sprintf(`[Unit]
Description=NextDeploy Daemon
After=network.target

[Service]
Type=simple
User=%s
ExecStart=%s/nextdeployd --host=%s --port=%s
Restart=on-failure
RestartSec=5s
Environment=CONFIG_FILE=%s/.nextdeploy/config.yaml
Environment=LOG_FILE=%s/.nextdeploy/logs/daemon.log

[Install]
WantedBy=multi-user.target
`, os.Getenv("USER"), installDir, defaultHost, defaultPort, homeDir, homeDir)
        servicePath := filepath.Join(systemdDir, "nextdeploy.service")
        tmpServicePath := filepath.Join(os.TempDir(), "nextdeploy.service")

        // Write to temp file first
        if err := os.WriteFile(tmpServicePath, []byte(serviceContent), 0644); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to create service file: %v", err)
        }</span>

        // Move to systemd directory
        <span class="cov0" title="0">moveCmd := fmt.Sprintf("%smv %s %s", sudo, tmpServicePath, servicePath)
        if err := exec.Command("sh", "-c", moveCmd).Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to install service file: %v", err)
        }</span>

        // 3. Reload systemd and enable service
        <span class="cov0" title="0">log.Println("üîÑ Reloading systemd...")
        if err := exec.Command("sh", "-c", sudo+"systemctl daemon-reload").Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to reload systemd: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("‚ö° Enabling nextdeploy service...")
        if err := exec.Command("sh", "-c", sudo+"systemctl enable nextdeploy.service").Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to enable service: %v", err)
        }</span>

        // 4. Add CLI to bashrc/zshrc
        <span class="cov0" title="0">log.Println("üìù Adding CLI to shell configuration...")
        shellConfig := filepath.Join(homeDir, ".bashrc")
        if _, err := os.Stat(filepath.Join(homeDir, ".zshrc")); err == nil </span><span class="cov0" title="0">{
                shellConfig = filepath.Join(homeDir, ".zshrc")
        }</span>

        // Check if already configured
        <span class="cov0" title="0">configLine := fmt.Sprintf("\nexport PATH=$PATH:%s\n", installDir)
        configData, _ := os.ReadFile(shellConfig)
        if !strings.Contains(string(configData), configLine) </span><span class="cov0" title="0">{
                f, err := os.OpenFile(shellConfig, os.O_APPEND|os.O_WRONLY, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to open shell config: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        if _, err := f.WriteString(configLine); err != nil </span><span class="cov0" title="0">{
                                log.Printf("‚ö†Ô∏è Failed to update shell config: %v", err)
                        }</span>
                        <span class="cov0" title="0">f.Close()
                        log.Printf("‚úÖ Updated %s", shellConfig)</span>
                }
        } else<span class="cov0" title="0"> {
                log.Printf("‚ÑπÔ∏è %s already configured", shellConfig)
        }</span>

        // 5. Start the service
        <span class="cov0" title="0">log.Println("üöÄ Starting nextdeploy daemon...")
        if err := exec.Command("sh", "-c", sudo+"systemctl start nextdeploy.service").Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to start service: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("‚úÖ Successfully installed NextDeploy system-wide!")
        log.Println("   CLI available as 'nextdeploy'")
        log.Println("   Daemon running as system service")
        log.Printf("   Check status with: sudo systemctl status nextdeploy")</span>
} // ---------------------- CLEAN COMMAND ----------------------
func cleanCmd() <span class="cov0" title="0">{
        log.Println("üßπ Cleaning build artifacts...")

        toRemove := []string{
                filepath.Join(defaultOutputDir, "nextdeployd"),
                filepath.Join(defaultOutputDir, "nextdeploy"),
        }

        for _, file := range toRemove </span><span class="cov0" title="0">{
                if err := os.Remove(file); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to remove %s: %v", file, err)
                }</span> else<span class="cov0" title="0"> if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        log.Printf("‚ÑπÔ∏è %s does not exist", file)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("‚úÖ Removed %s", file)
                }</span>
        }
}

// ---------------------- PURGE COMMAND ----------------------
func purgeCmd() <span class="cov0" title="0">{
        log.Println("üí£ PURGING all NextDeploy artifacts...")

        paths := []string{
                "/usr/local/bin/nextdeploy",
                "/usr/local/bin/nextdeployd",
                "/usr/local/bin/ndctl",
                filepath.Join(homeDir, ".nextdeploy"),
                "/etc/systemd/system/nextdeploy.service",
        }

        sudo := ""
        if os.Geteuid() != 0 </span><span class="cov0" title="0">{
                sudo = "sudo "
                log.Println("üîí Using sudo for privileged operations")
        }</span>

        <span class="cov0" title="0">for _, path := range paths </span><span class="cov0" title="0">{
                cmdStr := fmt.Sprintf("%srm -rf %s", sudo, path)
                if err := exec.Command("sh", "-c", cmdStr).Run(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to remove %s: %v", path, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("‚úÖ Removed %s", path)
                }</span>
        }

        <span class="cov0" title="0">log.Println("üîÑ Reloading systemd daemon...")
        if err := exec.Command("sh", "-c", sudo+"systemctl daemon-reload").Run(); err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ö†Ô∏è Failed to reload systemd: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("üõë Disabling nextdeploy service...")
        exec.Command("sh", "-c", sudo+"systemctl disable nextdeploy.service").Run()
        exec.Command("sh", "-c", sudo+"systemctl stop nextdeploy.service").Run()

        // Clean up shell PATH additions
        shellFiles := []string{".bashrc", ".zshrc"}
        for _, f := range shellFiles </span><span class="cov0" title="0">{
                shellPath := filepath.Join(homeDir, f)
                if _, err := os.Stat(shellPath); err == nil </span><span class="cov0" title="0">{
                        data, _ := os.ReadFile(shellPath)
                        lines := strings.Split(string(data), "\n")
                        var cleaned []string
                        for _, line := range lines </span><span class="cov0" title="0">{
                                if !strings.Contains(line, "nextdeploy") </span><span class="cov0" title="0">{
                                        cleaned = append(cleaned, line)
                                }</span>
                        }
                        <span class="cov0" title="0">_ = os.WriteFile(shellPath, []byte(strings.Join(cleaned, "\n")), 0644)
                        log.Printf("‚úÖ Cleaned PATH references in %s", shellPath)</span>
                }
        }

        <span class="cov0" title="0">log.Println("üíÄ NextDeploy fully purged from system.")</span>
}

// ---------------------- HELPER FUNCTIONS ----------------------
func getHomeDir() string <span class="cov0" title="0">{
        home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to get home directory: %v", err)
        }</span>
        <span class="cov0" title="0">return home</span>
}

func getDaemonEnv() []string <span class="cov0" title="0">{
        env := []string{"GOOS=linux", "GOARCH=amd64"}
        if os.Getenv("BUILD_STATIC") != "false" </span><span class="cov0" title="0">{
                env = append(env, "CGO_ENABLED=0")
        }</span>
        <span class="cov0" title="0">return env</span>
}

func getVersion(override string) string <span class="cov0" title="0">{
        if override != "" </span><span class="cov0" title="0">{
                return override
        }</span>
        <span class="cov0" title="0">if version := os.Getenv("NEXTDEPLOY_VERSION"); version != "" </span><span class="cov0" title="0">{
                return version
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(defaultVersionFile); err == nil </span><span class="cov0" title="0">{
                if data, err := os.ReadFile(defaultVersionFile); err == nil </span><span class="cov0" title="0">{
                        return strings.TrimSpace(string(data))
                }</span>
        }
        <span class="cov0" title="0">return "dev"</span>
}

func getGitCommit() string <span class="cov0" title="0">{
        cmd := exec.Command("git", "rev-parse", "--short", "HEAD")
        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(out))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
